<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>优化和调试实时渲染项目 on zentia</title><link>https://zentia.github.io/categories/%E4%BC%98%E5%8C%96%E5%92%8C%E8%B0%83%E8%AF%95%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E9%A1%B9%E7%9B%AE/</link><description>Recent content in 优化和调试实时渲染项目 on zentia</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://zentia.github.io/categories/%E4%BC%98%E5%8C%96%E5%92%8C%E8%B0%83%E8%AF%95%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E9%A1%B9%E7%9B%AE/index.xml" rel="self" type="application/rss+xml"/><item><title>构建纹理流送数据</title><link>https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%95%B0%E6%8D%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%95%B0%E6%8D%AE/ue5-hero.png" alt="Featured image of post 构建纹理流送数据" />&lt;p>每次修改和重新保存材质或材质实例时，会重新计算与使用的每个纹理有关的纹理流送数据。 每个纹理数据包含UV通道索引和缩放，UV通道索引用于对纹理采样， 缩放是应用于被采样通道的乘法因数。&lt;/p>
&lt;p>但是，这不涵盖所有情况，因为采样可能基于场景位置、网格体顶点颜色或任何UV通道组合。这可能会导致无法通过分析 找到相关数据，引擎会假设依赖于UV通道0和缩放1。&lt;/p>
&lt;p>分析在多个不同的步骤运行，具体取决于所编辑的内容：&lt;/p>
&lt;ol>
&lt;li>材质：当用户应用或保存修改时运行。&lt;/li>
&lt;li>材质实例：材质实例编辑器关闭或者保存包含材质实例的包时运行。&lt;/li>
&lt;li>关卡：用户运行&amp;quot;构建纹理流送&amp;quot;时针对每个所用材质运行。用于确保每个材质都是最新的。材质不是最新的原因包括：
&lt;ul>
&lt;li>4.15之前的材质没有任何数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>抗锯齿和上采样</title><link>https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/ue5-hero.png" alt="Featured image of post 抗锯齿和上采样" />&lt;p>抗锯齿（Anti-Aliasing）是指在原本应该平滑的边缘和对象上删除锯齿状或阶梯状线条。抗锯齿的方法有很多种，可以减少这些类型的视觉瑕疵。有些方法用于特定渲染器和平台，而有些则非常适合提高性能和保真度。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-no-aa.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-no-aa_hu_26e4af9b79899ccf.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-no-aa_hu_7fc73724bfe86beb.png 1024w"
loading="lazy"
alt="NO AA"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>抗锯齿方法&lt;/th>
&lt;th>台式机/主机：延迟渲染器&lt;/th>
&lt;th>台式机/主机：正向渲染器&lt;/th>
&lt;th>移动：延迟渲染器&lt;/th>
&lt;th>移动：正向渲染器&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-tsr.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-tsr_hu_9f95e8c4d0f0ccc5.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-tsr_hu_86c08a3921b17e34.png 1024w"
loading="lazy"
alt="时间超级分辨率（TSR）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-taau.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-taau_hu_4667a9742d312003.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-taau_hu_bf41b082c629e164.png 1024w"
loading="lazy"
alt="时间抗锯齿上采样（TAAU）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-fxaa.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-fxaa_hu_5949c8321a4962c8.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-fxaa_hu_6838d61c29aed8cd.png 1024w"
loading="lazy"
alt="快速近似抗锯齿（FXAA）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-msaa.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-msaa_hu_e9220de2f264c372.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-msaa_hu_6e389f3672691dd3.png 1024w"
loading="lazy"
alt="多重采样抗锯齿（MSAA）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>N&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="时间超级分辨率tsr">时间超级分辨率（TSR）
&lt;/h1>&lt;h1 id="时间抗锯齿上采样taau">时间抗锯齿上采样（TAAU）
&lt;/h1>&lt;h1 id="快速近似抗锯齿fxaa">快速近似抗锯齿（FXAA）
&lt;/h1>&lt;h1 id="多重采样抗锯齿msaa">多重采样抗锯齿（MSAA）
&lt;/h1></description></item><item><title>时间超级分辨率</title><link>https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/ue5-hero.png" alt="Featured image of post 时间超级分辨率" />&lt;p>时间超级分辨率 （TSR）是一个与平台无关的时间分辨率修改器，它使虚幻引擎能够渲染美丽的4K图像。由于将一些开销大的渲染计算分摊到了许多帧，图像的开销只占一小部分。TSR的做法是渲染比虚幻引擎4中的时间抗锯齿上采样（TAAU）更低的内部分辨率。&lt;/p>
&lt;p>TSR提供了一种原生的高质量上采样技术，以满足次世代游戏的需求。它实现了Nanite几何体要求的保真度和细节所需的可能性，同时以低得多的分辨率渲染帧，从而为Lumen提供足够的性能。&lt;/p></description></item><item><title>虚拟纹理内存池</title><link>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E6%B1%A0/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E6%B1%A0/ue5-hero.png" alt="Featured image of post 虚拟纹理内存池" />&lt;p>虚拟纹理系统主要有两种GPU内存分配方式：页表内存（Page Table Memory）和物理内存池（Physical Memory Pool）。&lt;/p></description></item><item><title>运行时虚拟纹理快速入门</title><link>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5-hero.png" alt="Featured image of post 运行时虚拟纹理快速入门" />&lt;blockquote>
&lt;p>本指南要求使用了在Epic Games启动程序中示例选项卡下的内容示例项目中的材质。虽然不使用这些材质也可以完成以下步骤，但为了设置地形，使其正常生效，需要使用绘制好的地形材质。在继续前，打开 示例 选项卡下的内容示例项目 Landscapes 地图，以配合本指南的学习。&lt;/p>&lt;/blockquote>
&lt;p>在运行时 虚拟纹理（RVT） 快速入门中，将介绍在你的项目中针对地形和非地形组件设置和使用RVT的过程。&lt;/p>
&lt;p>在开始本指南前，出于以下原因，理解运行时虚拟纹理最适用于地形十分重要：&lt;/p>
&lt;ul>
&lt;li>复杂的地形材质缓存着色效果，可提高性能。&lt;/li>
&lt;li>使用样条型和贴花类效果可提高质量和加强变体。&lt;/li>
&lt;li>由同一RVT资产处理非地形Acor与地形的混合。&lt;/li>
&lt;/ul>
&lt;p>完成本指南后，你会更了解：&lt;/p>
&lt;ul>
&lt;li>设置运行时虚拟纹理资产以及它连接到不同组件的方式。&lt;/li>
&lt;li>为地形材质启用运行时虚拟纹理。&lt;/li>
&lt;li>在关卡中设置运行时虚拟纹理体积。&lt;/li>
&lt;li>设置更多Actor以渲染至运行时虚拟纹理。&lt;/li>
&lt;/ul>
&lt;h1 id="项目设置">项目设置
&lt;/h1>&lt;p>使用运行时虚拟纹理前，必须先为项目启用它。执行以下步骤：&lt;/p>
&lt;ol>
&lt;li>在主菜单中，选择 编辑（Edit） 菜单并选择 项目设置（Project Settings）。在 引擎（Engine） &amp;gt; 渲染（Rendering） &amp;gt; 虚拟纹理（Virtual Textures） 类目下，将 启用虚拟纹理支持（Enable Virtual texture support） 设为true。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-1-1-project-settings.png"
width="1335"
height="841"
srcset="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-1-1-project-settings_hu_1b525a045f762b43.png 480w, https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-1-1-project-settings_hu_ad61ae4b957f1e3b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
>&lt;/p>
&lt;ol start="2">
&lt;li>重启 项目。&lt;/li>
&lt;/ol>
&lt;h1 id="创建运行时虚拟纹理资产">创建运行时虚拟纹理资产
&lt;/h1>&lt;p>运行时虚拟纹理 资产包含指定给运行时虚拟纹理体积的RVT资产的配置详情。RVT资产的工作原理是链接场景中需共享数据的材质和其他Actor。&lt;/p>
&lt;ol>
&lt;li>在 内容侧滑菜单 中，利用右键点击快捷菜单或 添加（+Add） 按钮从 纹理（Textures） 类目创建 运行时虚拟纹理 资产。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-content-drawer-add-new-runtime-virtual-texturing-asset.png"
width="612"
height="906"
srcset="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-content-drawer-add-new-runtime-virtual-texturing-asset_hu_64120219a2e20565.png 480w, https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-content-drawer-add-new-runtime-virtual-texturing-asset_hu_c54ac6ca6feb8f6a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="67"
data-flex-basis="162px"
>&lt;/p>
&lt;ol start="2">
&lt;li>为 运行时虚拟纹理 资产命名。在本指南中，命名为 VT_Test。&lt;/li>
&lt;li>双击打开此 运行时虚拟纹理 资产编辑器，以配置其可用属性。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-runtime-virtual-texturing-asset-window.png"
width="960"
height="768"
srcset="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-runtime-virtual-texturing-asset-window_hu_9aa5a3f872bb81ed.png 480w, https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-runtime-virtual-texturing-asset-window_hu_57c88a2caeaa1f65.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="300px"
>&lt;/p>
&lt;p>在此窗口中，你可以定义运行时虚拟纹理（RSV）支持的大小、图块大小和材质属性类型。这些熟悉可以实时调整，并在编辑器中实时查看改动效果。&lt;/p>
&lt;blockquote>
&lt;p>欲知这些设置的详情和用途，参阅虚拟纹理设置页面。&lt;/p>&lt;/blockquote></description></item><item><title>动态分辨率</title><link>https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/ue5-hero.png" alt="Featured image of post 动态分辨率" />&lt;p>动态分辨率可根据先前画面的GPU工作负载调节主要屏幕百分比。分辨率是基于启发法（按需要）调节的，例如，如果在屏幕上有太多Object，或者有成本高昂的效果突然进入画面，GPU渲染时间将会延长，此时为了维持目标珍露就会降低屏幕分辨率。&lt;/p>
&lt;h1 id="启用动态分辨率">启用动态分辨率
&lt;/h1>&lt;h2 id="在运行时启用动态分辨率">在运行时启用动态分辨率
&lt;/h2>&lt;p>动态分辨率可以通过在 Game User Settings 节点上获取一个布尔数值来启用。你可以在使用蓝图或C++时设置它。&lt;/p>
&lt;p>在 蓝图 中，你可以使用 Game User Settings 节点选择此功能来启用动态分辨率，如下图：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/dynamicresblueprint.png"
width="1405"
height="397"
srcset="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/dynamicresblueprint_hu_2999e788d01f08d0.png 480w, https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/dynamicresblueprint_hu_a22a5d9e60b063e5.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="353"
data-flex-basis="849px"
>&lt;/p>
&lt;p>在 C++ 中，你可以在 UGameUserSettings 设置如下布尔值：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">GEngine&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">GetDynamicResolutionStatus&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetEnabled&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>将 SetEnabled 设置为 false 可将其禁用。&lt;/p>
&lt;blockquote>
&lt;p>在实际启用或禁用动态分辨率时，游戏线程逻辑掌握最终程序控制权限，所以如果你是用蓝图在运行时启动它，这会优先于代码设置。要将游戏用户设置恢复到初始状态，请使用以下命令行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEngine-&amp;gt;GameUserSettings-&amp;gt;ApplyNonResolutionSettings();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/blockquote>
&lt;h2 id="使用运算模式控制动态分辨率">使用运算模式控制动态分辨率
&lt;/h2>&lt;p>你可以使用 &lt;strong>运算模式（Operation Mode）&lt;/strong> 设置如何在游戏中覆盖和使用动态分辨率，设置在游戏中覆盖它和使用它的方式。为了控制这种模式，在项目所对应平台（Xbox One、PlayStation 4等）的平台配置描述（或设备描述）中，你可以使用下列控制台命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.DynamicRes.OperationMode
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用下列数值之一来设置运算模式如何针对项目的平台工作：&lt;/p>
&lt;ul>
&lt;li>根据游戏用户设置状态（在C++或蓝图中设置）启用动态分辨率。&lt;/li>
&lt;li>无论游戏用户设置状态如何都启用动态分辨率。&lt;/li>
&lt;/ul>
&lt;p>启用动态分辨率后，下列控制台变量会设置屏幕百分比的最大值和最小值，以及在降低分辨率之前任何给定帧的最大预算。如果你不设置，这些变量都有默认值：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制台变量&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.DynamicRes.MinScreenPercentage&lt;/td>
&lt;td>50&lt;/td>
&lt;td>设置要使用的最小屏幕百分比。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.DynamicRes.MaxScreenPercentage&lt;/td>
&lt;td>100&lt;/td>
&lt;td>设置用于分配渲染目标的最大主要屏幕百分比。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.DynamicRes.FrameTimeBudget&lt;/td>
&lt;td>33.3&lt;/td>
&lt;td>设置帧预算（以毫秒为单位）。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>你可以使用Unreal Engine中的&amp;quot;设备描述（Device Profiles）&amp;ldquo;窗口设置和管理配置文件。可以通过&amp;quot;文件（File）&amp;ldquo;菜单选择 编辑（Edit）&amp;gt; Developer Tools（开发者工具）&amp;gt; Device Profiles（设备描述） 来访问此窗口。&lt;/p>&lt;/blockquote>
&lt;h2 id="暂停和恢复动态分辨率">暂停和恢复动态分辨率
&lt;/h2>&lt;p>有时你可能需要为项目启用动态分辨率，但你又不想对主大厅之类的区域启用。动态分辨率可以随运作模式暂停和恢复。下列控制台变量可用于设置动态分辨率的运算模式：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.DynamicRes.OperationMode
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>禁用（默认）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>根据GameUserSettings中使用的设置启用。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>无论GameUserSettings中的设置如何都会启用。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>下表概括了当启用或禁用特定运算模式时可用的不同状态，以及GameUserSettings所受的影响：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Game User Settings = False&lt;/th>
&lt;th>&lt;/th>
&lt;th>Game User Settings = True&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>暂停&lt;/td>
&lt;td>不暂停&lt;/td>
&lt;td>暂停&lt;/td>
&lt;td>不暂停&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OperationMode=0&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OperationMode=1&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OperationMode=2&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 C++ 中，你可以使用下列函数控制和检查动态分辨率的状态：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>操作&lt;/th>
&lt;th>C++函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>暂停&lt;/td>
&lt;td>GEngine-&amp;gt;PauseDynamicResolution();&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>恢复&lt;/td>
&lt;td>GEngine-&amp;gt;ResumeDynamicResolution();&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>检查状态（禁用/启用或暂停）&lt;/td>
&lt;td>GEngine-&amp;gt;GetDynamicResolutionStatus();&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="动态分辨率巡航">动态分辨率巡航
&lt;/h1>&lt;p>在虚幻引擎中，动态分辨率功能的实现与以前其他引擎中同类功能有所不同，因为我们允许分辨率根据需要在一个给定的范围内变化，而不是限制为单一的分辨率（1080p、900p、720p）。在这张示例图中，此模型演示了控制台变量所控制的对象。它演示了当一切都运行顺利、没有超过给定帧的预算时，动态分辨率是如何在给定范围（3）中自动调节的。可以把这个范围想象为飞机的巡航高度，飞机在这一高度范围可以自由机动，以实现到达目的地的理想速度。和飞机一样，分辨率也可以根据需要上下调节，从而在分辨率和充足的性能之间保持良好的平衡。&lt;/p>
&lt;blockquote>
&lt;p>这个模型是用于演示的，没有考虑在给定场景中发生的所有情况。例如，它没有体现GPU不与CPU同步会是什么情况，甚至也没有体现启发法正确估算出分辨率应该变化多少的情况。它的目的是清晰地演示&amp;quot;理想&amp;quot;情况，从而展现动态分辨率控制态变量的运算方式。&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/framegpugraph.png"
width="1694"
height="826"
srcset="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/framegpugraph_hu_c4adeb21008ffde8.png 480w, https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/framegpugraph_hu_248532d90ebc0f3c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="205"
data-flex-basis="492px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参考号&lt;/th>
&lt;th>控制台变量&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>r.DynamicRes.FrameTimeBudget&lt;/td>
&lt;td>以毫秒（ms）计的帧时间预算。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>r.DynamicRes.TargetedGPUHeadRoom&lt;/td>
&lt;td>在超出预算前可供GPU增加的余量（按帧预算的百分比计）。这很可能要取决于发布平台或根据启用的渲染功能而定。例如，动态模糊需要另外留出成本余量用于摄像机的快速旋转运动。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>r.DynamicRes.ChangePercentageThreshold&lt;/td>
&lt;td>为了实际调整分配大小，在屏幕百分比中需要的最小变化。如果不想经常在非常相近的分辨率大小之间变换，可以利用此变量。如果它的数值过小，分辨率最终可能还是会经常改变，而如果它过大，可能会增加超出GPU预算的风险。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>r.DynamicRes.MinResolutionChangePeriod&lt;/td>
&lt;td>在允许进行任何分辨率更改之前，必须达到的最小帧数。此命令有多种用途。这包括提高启发法在给定主要屏幕百分比下排除测量噪点模拟GPU消耗的可靠性，避免可能在逐帧偏移抖动之间发生的时序上采样的输入样本偏移干扰，以及更改可能造成抗锯齿发散的分辨率。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果你的瓶颈是在CPU而非GPU，还可以使用下列控制台变量调节用于动态分辨率的启发法历史记录和要使用的屏幕百分比：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制台变量&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.DynamicRes.HistorySize&lt;/td>
&lt;td>启发法帧历史记录中的帧数。如果历史记录过短，可能包含过多噪点，影响可靠性；而如果历史记录过长，调节延迟可能会非常严重。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.DynamicRes.CPUBoundScreenPercentage&lt;/td>
&lt;td>当你遇到CPU瓶颈时应该瞄准的主要屏幕百分比。如果平台上的CPU和GPU共享相同的内存带宽，可以用它设置较低的屏幕百分比来降低分辨率。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="超预算应急">超预算应急
&lt;/h2>&lt;p>如果你发现动态分辨率会非常迅速地超出预算，例如在镜头切换时或者成本高昂的视觉效果出现时，那就说明使用的启发法实际上无法预测这种情况何时会发生。在这类情况确实发生时，可以使用某种&amp;quot;应急&amp;quot;按钮快速降低分辨率，从而减少超出预算的帧数。如果启发法发现有N（一定数量）个连续帧的可用GPU时间超出预算，它将会立即调整分辨率来应对这些超预算时间。它还会自动执行历史记录重置，使得先前成本较低的帧时间不会影响启发法对成本较高的帧的判断。&lt;/p>
&lt;p>请使用下列控制台命令来控制在启用&amp;quot;应急&amp;quot;开关降低分辨率之前可以出现的超GPU预算的连续帧数：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.DynamicRes.MaxConsecutiveOverbudgetGPUFrameCount
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在此图中，画面中突然发生跳跃，因此有两个以上的连续帧超过了设定的33.3毫秒的预算。系统激活了应急开关来快速降低分辨率，使得后续帧不再超出预算。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/overbudgetpanicgraph.png"
width="1019"
height="879"
srcset="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/overbudgetpanicgraph_hu_88c9a253e65af047.png 480w, https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/overbudgetpanicgraph_hu_9710b4667aba4be0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="278px"
>&lt;/p>
&lt;ol>
&lt;li>超出预算的最大连续GPU帧数。&lt;/li>
&lt;li>从检测到GPU导致分辨率变化为止未与渲染线程同步的帧延迟。&lt;/li>
&lt;li>发生紧急情况检测，引发帧率下降。&lt;/li>
&lt;li>一定数量的帧发生分辨率更改。&lt;/li>
&lt;/ol>
&lt;h1 id="支持动态分辨率的平台">支持动态分辨率的平台
&lt;/h1>&lt;p>支持以下平台&lt;/p>
&lt;ul>
&lt;li>微软的Xbox One、Xbox Series S和Xbox Series X&lt;/li>
&lt;li>PlayStation 4 和 PlayStation 5 （不包括PSVR）&lt;/li>
&lt;li>Nintendo Switch&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>针对不在此白名单中的平台启用动态分辨率支持是很危险的，可能造成意外后果。这类后果包括GPU时间错误，这可能使分辨率不必要地下降，或者分辨率提高过多，发生丢帧。这最终可能毁掉Gameplay体验。默认情况下，引擎不允许你在此白名单中的平台上使用动态分辨率。&lt;/p>&lt;/blockquote></description></item><item><title>可视性和遮挡剔除参考</title><link>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E5%8F%82%E8%80%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E5%8F%82%E8%80%83/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E5%8F%82%E8%80%83/ue5-hero.png" alt="Featured image of post 可视性和遮挡剔除参考" />&lt;p>本页面包含虚拟纹理系统的要求、设置、控制台命令的相关信息。&lt;/p>
&lt;h1 id="流送虚拟纹理设置">流送虚拟纹理设置
&lt;/h1>&lt;p>以下为用于设置和处理流送虚拟纹理的设置和属性。&lt;/p></description></item><item><title>时序上采样器</title><link>https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/ue5-hero.png" alt="Featured image of post 时序上采样器" />&lt;p>时序上采样器（Temporal Upscalers） 使用来自当前和之前帧的数据来产生高质量的增强结果。 无论是虚幻引擎4的Temporal Anti-Aliasing Upscaling (TAAU)、虚幻引擎5的Temporal Super Resolution，还是诸如NVIDIA的DLSS 2+ Super Resolution、AMD的FSR 2.0+和Intel的XeSS等第三方插件，时序上采样器都在虚幻引擎里以相同方式运作。它们都在同一位置插入后期处理链&amp;ndash;在景深和动态模糊之间。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/8-pipeline-tsr.png"
width="1078"
height="308"
srcset="https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/8-pipeline-tsr_hu_12ff33fc38a98b0d.png 480w, https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/8-pipeline-tsr_hu_909ab58fec84c7ed.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="350"
data-flex-basis="840px"
>&lt;/p>
&lt;p>无论使用哪种时序上采样器，渲染分辨率都是由Screen Percentage，或在支持时同时由Dynamic Resolution来控制。&lt;/p></description></item><item><title>纹理流送配置</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E9%85%8D%E7%BD%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E9%85%8D%E7%BD%AE/ue5-hero.png" alt="Featured image of post 纹理流送配置" />&lt;p>在检查构建的纹理流送的准确性之后，您可能需要调整纹理流送的行为和优先级。 下面的参数可以通过配置文件进行调整，而其中的大多数参数也可以在运行时从控制台窗口进行更新。&lt;/p>
&lt;p>|命令|说明|
|r.TextureStreaming|此命令用于启用或禁用纹理流送器。当纹理流送器被禁用后，所有纹理mip都将被完全加载到内存中，即使在纹理从来没有被用于渲染的情况下也是如此。如果需要，您可以在运行时切换此选项。|
|r.Streaming.PoolSize|引擎中纹理可用的池大小(MB)。这个池包含UI纹理、NeverStream纹理、立方体贴图和流送纹理。在某些平台上，这个池还可以保存非纹理资源，例如GPU粒子缓冲区和顶点缓冲区。设置为0时，池的大小将不受限制。|
|r.Streaming.UseFixedPoolSize|当使用非零值时，可以在运行时更改纹理池大小。|
|r.Streaming.FramesForFullUpdate|纹理流送器的每次完整更新之间的帧数。每次更新都会重新计算每个纹理所需的分辨率，并生成mip加载或卸载请求。较高的值会降低纹理流送器CPU使用率，而较低的值会提高其反应能力。|
|r.Streaming.UseNewMetrics|仅用于兼容性。当设置为假时，纹理流送器将按照4.12版本继续进行处理。|&lt;/p></description></item><item><title>预计算可视性体积</title><link>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ue5-hero.png" alt="Featured image of post 预计算可视性体积" />&lt;p>像其他剔除方法一样，预计算可视性体积用于实现中小型场景的性能优化，通常用于因为硬件问题而使动态遮挡剔除受到限制的移动平台。预计算可视性体积根据玩家或摄像机的位置，将Actor位置的可视性状态存储在场景中。因此，预计算可视性对于主要为静态点亮的环境项目、玩家运动受限和某些2D游戏区域最有用。&lt;/p>
&lt;p>在照明构建期间，会在阴影投射几何体上方生成可视性单元格。Actor可视性从每个单元格位置存储。由于预计算可视性是在线下生成的，因此你省去的是通常用于硬件遮挡查询的渲染线程时间，但代价是会增加运行时内存和照明构建时间。基于这一点，建议仅在玩家或摄像机可访问区域放置体积来保持可视性剔除。&lt;/p>
&lt;h1 id="设置和用法">设置和用法
&lt;/h1>&lt;p>首先，需要为关卡启用预计算可视性。方法是打开世界场景设置（World Settings）并找到预计算可视性（Precomputed Visibility）部分。找到后，启用预计算可视性（Precomputed Visibility）旁边的复选框。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis.png"
width="501"
height="243"
srcset="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_ff7454136b0cf587.png 480w, https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_fd5ffa0c6d38ac85.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="494px"
>&lt;/p>
&lt;p>从模式（Modes）面板中，将预计算可视性&lt;/p></description></item><item><title>预计算可视性体积</title><link>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ue5-hero.png" alt="Featured image of post 预计算可视性体积" />&lt;p>像其他剔除方法一样，预计算可视性体积用于实现中小型场景的性能优化，通常用于因为硬件问题而使动态遮挡剔除受到限制的移动平台。预计算可视性体积根据玩家或摄像机的位置，将Actor位置的可视性状态存储在场景中。因此，预计算可视性对于主要为静态点亮的环境项目、玩家运动受限和某些2D游戏区域最有用。&lt;/p>
&lt;p>在照明构建期间，会在阴影投射几何体上方生成可视性单元格。Actor可视性从每个单元格位置存储。由于预计算可视性是在线下生成的，因此你省去的是通常用于硬件遮挡查询的渲染线程时间，但代价是会增加运行时内存和照明构建时间。基于这一点，建议仅在玩家或摄像机可访问区域放置体积来保持可视性剔除。&lt;/p>
&lt;h1 id="设置和用法">设置和用法
&lt;/h1>&lt;p>首先，需要为关卡启用预计算可视性。方法是打开世界场景设置（World Settings）并找到预计算可视性（Precomputed Visibility）部分。找到后，启用预计算可视性（Precomputed Visibility）旁边的复选框。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis.png"
width="501"
height="243"
srcset="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_ff7454136b0cf587.png 480w, https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_fd5ffa0c6d38ac85.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="494px"
>&lt;/p>
&lt;p>从模式（Modes）面板中，将预计算可视性&lt;/p></description></item><item><title>Nanite虚拟几何体</title><link>https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/</guid><description>&lt;img src="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/ue5-hero.png" alt="Featured image of post Nanite虚拟几何体" />&lt;p>Nanite是虚幻引擎5的虚拟化几何体系统，它采用全新的内部网格体格式和渲染技术来渲染像素级别的细节以及海量对象。它可以智能的仅处理你能感受到的细节。另外，Nanite采用高度压缩的数据格式，并且支持具有自动细节级别的颗粒度流送。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/nanite-in-unreal-engine.png"
width="3840"
height="3174"
srcset="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/nanite-in-unreal-engine_hu_86c148fb16e944c0.png 480w, https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/nanite-in-unreal-engine_hu_f35cbd38f3710ec.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;h1 id="nanite的优势">Nanite的优势
&lt;/h1>&lt;ul>
&lt;li>几何体形状的复杂度提高了数个数量级，三角形和对象的实时渲染数量达到了前所未有的高度&lt;/li>
&lt;li>帧预算不再会因为多边形数量、绘制调用和网格体内存使用情况而受限&lt;/li>
&lt;li>现在可以直接导入电影级品质的美术资源，例如ZBrush雕刻模型和摄影测量扫描数据&lt;/li>
&lt;li>通过高模实现细节，而非将细节烘培到法线贴图纹理&lt;/li>
&lt;li>自动处理细节级别（LOD），不再需要手动设置单个网格体的LOD&lt;/li>
&lt;li>品质损失极少或没有损失，特别是在LOD发生过渡时&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>尽管Nanite带来了前所未有的变革，但在实际使用上，仍会存在一些限制。 例如，在考虑实例总数、单个网格体的三角形数量、材质复杂度、输出分辨率、项目性能等方面时，还是需要根据实际项目内容和硬件水平来仔细衡量。 与此同时，在虚幻引擎未来的版本中，Nanite将不断扩展功能并提升性能。&lt;/p>&lt;/blockquote>
&lt;h1 id="nanite网格体和传统静态网格体的不同之处">Nanite网格体和传统静态网格体的不同之处
&lt;/h1>&lt;p>Nanite网格体是一种启用了Nanite的特殊静态网格体。 Nanite网格体本质上仍是三角形网格体，但对其数据进行了大量细节和压缩处理。 此外，Nanite使用了一种全新系统，能以极高效的方式来渲染这种数据格式。&lt;/p>
&lt;p>要让静态网格体利用Nanite，只需一个标记来启用它即可。 编辑Nanite网格体的内容和传统网格体没太大不同，区别就在于相比使用传统方法渲染的几何体，Nanite能够渲染的三角形和实例要多出数个数量级。 将摄像机移到足够近的位置后，Nanite就会绘制出导入的原始源三角形。&lt;/p>
&lt;p>Nanite网格体支持多重UV和顶点颜色。 材质可以被分配给网格体的不同分段，并且这些材质可以使用不同的着色模型和动态效果（在着色器中完成）。 材质指定可以动态切换，就像其他静态网格体一样。Nanite也无需任何烘焙材质的过程。&lt;/p>
&lt;p>&lt;a class="link" href="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/" target="_blank" rel="noopener"
>虚拟纹理&lt;/a>并非必须与Nanite一起使用，但强烈建议使用虚拟纹理。 虚拟纹理是正交虚幻引擎功能，它与纹理数据的关系类似于Nanite与网格体数据的关系。&lt;/p>
&lt;h1 id="nanite如何工作">Nanite如何工作？
&lt;/h1>&lt;p>Nanite可最大限度地与现有的引擎工作流程无缝集成，可使用前所未有的方法来存储和渲染网格体数据。&lt;/p>
&lt;ul>
&lt;li>导入期间 — 分析网格体，并将其拆分成由三角形组构成的分层群集。&lt;/li>
&lt;li>渲染期间 — 根据摄像机视图以不同LOD随时切换群集，并且可以在不破坏同一对象中相邻群集的情况下完美连接。 数据会根据需求流送，因此只有可见细节才会保存在内存中。 Nanite在自己的渲染通道中运行，该通道完全绕过了传统的绘制调用。 你可以使用可视化模式来检视Nanite管线。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于Nanite需要从磁盘快速流送网格体数据。 建议使用固态硬盘（即SSD）来存储运行时数据。&lt;/p>&lt;/blockquote>
&lt;h1 id="应该将nanite用于哪些类型的网格体">应该将Nanite用于哪些类型的网格体？
&lt;/h1>&lt;p>一般来说，能启用时应该尽量启用Nanite。 启用了Nanite的静态网格体通常可以更快地渲染，占用的内存和磁盘空间会更少。&lt;/p>
&lt;p>具体来说，如果网格体满足以下条件，则尤其适合使用Nanite：&lt;/p>
&lt;ul>
&lt;li>包含很多三角形，或屏幕上的三角形非常小&lt;/li>
&lt;li>场景中有很多实例&lt;/li>
&lt;li>是其他Nanite几何体的主要遮挡物&lt;/li>
&lt;li>使用虚拟阴影贴图投射阴影&lt;/li>
&lt;/ul></description></item><item><title>如何修复GPU驱动程序崩溃</title><link>https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/ue5-hero.png" alt="Featured image of post 如何修复GPU驱动程序崩溃" />&lt;p>在处理含有大量图形的项目时，你有可能会遇到GPU崩溃。发生这种情况时，你将看到如下所示的窗口。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/gpu-crash.png"
width="360"
height="243"
srcset="https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/gpu-crash_hu_e395c92000460a5d.png 480w, https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/gpu-crash_hu_6555e6d4ec9126cc.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="148"
data-flex-basis="355px"
>&lt;/p></description></item><item><title>纹理流送概述</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/ue5-hero.png" alt="Featured image of post 纹理流送概述" />&lt;p>纹理流送系统或流送器是引擎的一部分，负责增大和减小每个纹理的分辨率。该系统使您可以拥有良好的视觉质量， 同时有效地管理可用内存。这在一定程度上是通过Mip或Mipmap实现的，Mip或Mipmap是为您的纹理分辨率预先计算的图像序列。您可以将它们视为纹理的LOD。 有关Mip的更多信息，您可以在我们的纹理支持和设置页面上加以了解。&lt;/p>
&lt;p>流送器有自己的场景视图，它的更新周期包括&lt;/p>
&lt;ol>
&lt;li>更新场景视图&lt;/li>
&lt;li>计算每个纹理的理想分辨率&lt;/li>
&lt;li>根据流送池大小选择哪个分辨率实际上是可行的&lt;/li>
&lt;li>选择要更新的纹理&lt;/li>
&lt;li>生成加载/卸载请求&lt;/li>
&lt;/ol>
&lt;p>为完成这些任务，流送器使用异步工作线程来降低游戏线程上的工作负载，这样上述只有第一个和最后一个任务需要在游戏更新循环中完成。 场景视图包含每个Primitive组件使用的所有纹理列表以及每个纹理的场景边界和纹素场景大小。根据该信息和给定视点，可以计算出 获得良好的逐像素比率纹素所必需的分辨率。然后还会考虑一些额外的信息，例如该组件实际上是否可以在屏幕上看到。 这最终会定义每个纹理的理想分辨率。然后流送器会计算流送内存池是不是足够大，能容纳这些分辨率。如果不够，流送器会降低所选纹理的计划质量， 一次降低一个mip，直到计划的分辨率降低到预算之下。&lt;/p>
&lt;p>降低mip时处理纹理的顺序由保留时间优先级来定义，请按以下顺序遵循这些规则：&lt;/p>
&lt;ol>
&lt;li>保留地形纹理、强制加载纹理和已经缺失分辨率的纹理&lt;/li>
&lt;li>保留在屏幕上可见的mip&lt;/li>
&lt;li>保留角色纹理和不占用过多内存的纹理&lt;/li>
&lt;li>删掉不可见的mip，先删掉最新看到的mip&lt;/li>
&lt;/ol>
&lt;p>流送器确定针对每个纹理加载的分辨率后，就会根据加载顺序优先级计算先更新哪个纹理。优先级根据按照以下顺序评估的多个条件定义：&lt;/p>
&lt;ol>
&lt;li>先加载可见mip&lt;/li>
&lt;li>先加载强制加载纹理、地形纹理和角色纹理&lt;/li>
&lt;li>先加载远离目标分辨率的纹理&lt;/li>
&lt;li>对于不可见的纹理，先加载最新看到的&lt;/li>
&lt;/ol>
&lt;p>最后一步是为了生成一批更新请求，每个请求增大或降低当前纹理分辨率。针对一批更新的内存量 受到内存池大小的限制，以便保持较低的动态请求数量。&lt;/p></description></item><item><title>运行时虚拟纹理</title><link>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 运行时虚拟纹理" />&lt;p>运行时虚拟纹理 (RVT)在运行时使用GPU按需创建其纹素数据，工作方式与传统纹理映射类似。较大区域上的RVT缓存着色数据非常适用于使用贴花类材质的地形和适配地形的样条。&lt;/p>
&lt;h1 id="工作流程">工作流程
&lt;/h1>&lt;p>使用以下高级步骤在项目中设置和使用运行时虚拟纹理：&lt;/p>
&lt;ol>
&lt;li>在内容浏览器中创建 运行时虚拟纹理 资产。用于将所有组件（包括RVT体积Actor和RVT材质）链接在一起，渲染运行时虚拟纹理。&lt;/li>
&lt;li>在 模式（Modes） 面板中将 运行时虚拟纹理体积（Runtime Virtual Texture Volume） 添加到场景。此操作用于将RVT资产放置到场景中。&lt;/li>
&lt;li>配置材质以 写入 到RVT资产。&lt;/li>
&lt;li>配置材质以从RVT资产 采样。&lt;/li>
&lt;li>设置一个或多个图元组件或地形Actor，以渲染至RVT资产。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>欲了解设置RVT的详细步骤指南，参见运行时虚拟纹理快速入门。本指南将设置地形材质和其他场景组件，以使用运行时虚拟纹理。&lt;/p>&lt;/blockquote></description></item><item><title>流送虚拟纹理</title><link>https://zentia.github.io/p/%E6%B5%81%E9%80%81%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B5%81%E9%80%81%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B5%81%E9%80%81%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 流送虚拟纹理" />&lt;p>流送虚拟纹理 (SVT)是一种在项目中从硬盘流送纹理的替代方法，与虚幻引擎4（UE4）中现有基于mip的纹理流送相比，其既有优点也有缺点。&lt;/p></description></item><item><title>纹理流送指标</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/ue5-hero.png" alt="Featured image of post 纹理流送指标" />&lt;p>可使用 STAT STREAMING 控制台命令分析纹理流送状态。此分析报告性能、内存使用，以及纹理流送器使用的其他指标。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">STAT STREAMING sortby=name maxhistoryframes=1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/statstreaming.png"
width="1136"
height="626"
srcset="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/statstreaming_hu_7d663e3bd6568f81.png 480w, https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/statstreaming_hu_53f6b5ad6d3d0ecc.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>读取内存数据时，术语&amp;quot;pool&amp;quot;代表概念（保留）内存，与实际使用的内存无关。 术语&amp;quot;mips&amp;quot;代表纹理当前使用的内存，而非未发生或未来的使用。内存指标分为三种主要的池：&lt;/p>
&lt;ul>
&lt;li>Texture&lt;/li>
&lt;li>Streaming&lt;/li>
&lt;li>Wanted&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这些池的大小显示在 Memory Counters 类目中每行的右方。&lt;/p>&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数据&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Game Thread Update Time&lt;/td>
&lt;td>流送器更新函数所占用的时间。这负责大多数的纹理流送工作。只有少数任务在纹理流送器外处理，如移除对纹理、组件或关卡的引用。在一个游戏线程更新中，流送器向完整更新执行一步。完成更新将持续数帧，并与 r.Streaming.FramesForFullUpdate 相关。如数据的 Counter 部分所定义，更新步骤各有不同。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Texture Pool&lt;/td>
&lt;td>纹理资源可用的总内存。这包含各种非流送资源，如渲染目标、GPU 粒子缓存、立方体贴图、UI 纹理和不可流送纹理。在部分平台上，此内存可用于保存静态网格体之类的非纹理资源。Texture Pool 约等于 Safety Pool + Temporary Pool + Streaming Pool + NonStreaming Mips（如有，仅限波动的量，上至安全池的大小）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Safety Pool&lt;/td>
&lt;td>此值在 Engine 配置文件中设置（在 [TextureStreaming] 下，作为 MemoryMargin）。这是为意外（非流送）分配预留的内存。如可用的内存因低于此值的量形成周期波动，纹理流送器将在此波动下最大程度地稳定其流送池如正常（预计）的波动超过安全池大小，纹理流送器将不断应用其预算，可能会创建流入和流出纹理的无限循环。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Temporary Pool&lt;/td>
&lt;td>此值由 r.Streaming.MaxTempMemoryAllowed 控制，并指定调整纹理大小时流送器可用的额外内存量。变更纹理的 mip 数量时，引擎需要新建一个纹理（无论大小），用于保存之后的 mip 数据。这能间接控制进行中请求的数量，因为流送器将向 IO 系统发送临时池允许的请求数量。注意：临时池最小尺寸必须与需要流送的最大资源相同，但设为过大会浪费内存（因其正是为此目的而预留）。从另一方面而言，设为过小会减缓流送速度（无法为 IO 系统生成足够的工作，使其进入待机状态）。此外还需注意：流送器无法对进行中请求内的处理顺序进行较大程度的控制。这意味着使用相对较小的临时池可更大程度地控制加载顺序。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Streaming Pool&lt;/td>
&lt;td>纹理流送器可用的内存量。流送器通常会将所有可用内存用于流送新 mip，或将之前流送的 mip 尽可能久地保存在内存中。流送池（Streaming Pool）包含可见 Mip（Visible Mip）、隐藏 Mip（Hidden Mip）、强制 Mip（Force Mip）和缓存 Mip（Cached Mip）。Streaming Pool 约等于 Visible Mips* + Hidden Mips + Forced Mips + Cached Mips（完全使用时为 *:，否则未使用的空间必须被占用）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NonStreaming Mips&lt;/td>
&lt;td>非流送分配使用的内存量。如这些分配因超过安全池的值而出现定期波动，这将影响流送池的预算，应避免出现此状况（减少分配次数或增加安全池）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Required Pool&lt;/td>
&lt;td>纹理流送器需要根据其指标加载的 mip 数据量。这可超过纹理流送池的 100%，但同时也会进行一些妥协，部分纹理将不会以其所要求的分辨率加载。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Visible Mips&lt;/td>
&lt;td>可见纹理 mip 当前占用的所需内存。这并不包含强制 mip。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hidden Mips&lt;/td>
&lt;td>非可见纹理 mip 当前占用的所需内存。这并不包含强制 mip。为防止首次显示纹理时出现低精度纹理，流送器会提前预流送纹理，但通常会比所需要的少一个 mip（详见 r.Streaming.HiddenPrimitiveScale）。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>GPU转储文件查看器工具</title><link>https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/</guid><description>&lt;img src="https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/ue5-hero.png" alt="Featured image of post GPU转储文件查看器工具" />&lt;p>DumpGPU是一个不受平台限制的控制台命令，能够将中间渲染资源二进制或采集帧转储到磁盘中。转储文件会保存为.json和.bin文件，可以使用轻量级网页浏览器查看。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/gpu-dump-viewer.png"
width="1920"
height="1040"
srcset="https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/gpu-dump-viewer_hu_2764e0b66fdcbb5c.png 480w, https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/gpu-dump-viewer_hu_de89706a1b9f7dd.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p></description></item><item><title>实时渲染优化指南</title><link>https://zentia.github.io/p/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/ue5-hero.png" alt="Featured image of post 实时渲染优化指南" />&lt;p>本文提供了关于如何识别并优化移动设备性能的指南和最佳实践，同时介绍了如何在这种情况下获得最逼真的实时渲染功能。&lt;/p>
&lt;p>在本文中，你将了解：&lt;/p>
&lt;ul>
&lt;li>哪些因素会影响性能预算&lt;/li>
&lt;li>关于项目打包的最佳实践&lt;/li>
&lt;li>哪些工具可用于检测性能瓶颈&lt;/li>
&lt;/ul>
&lt;h1 id="了解你的性能预算">了解你的性能预算
&lt;/h1>&lt;p>开发项目时，应用程序的目标设备只有有限的可用资源，包括用来保存和处理对象的内存资源。在构建你的项目时，你必须决定将这些资源用于哪些地方。所以，你应该自行了解设备izai速度、线程、CPU和GPU带宽方面的能力，以及设备的内存、图形内存和可用磁盘控件，这些都是很重要的考量因素。&lt;/p></description></item><item><title>可延展性设置</title><link>https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/ue5-hero.png" alt="Featured image of post 可延展性设置" />&lt;h1 id="可延展性设置">可延展性设置
&lt;/h1>&lt;p>要在编辑器中访问可延展性设置，可使用工具栏中的设置（Settings）菜单。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_viewqual.png"
width="870"
height="648"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_viewqual_hu_660a2bbe38fd2601.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_viewqual_hu_eb94a814a012fbd6.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="322px"
>&lt;/p>
&lt;h1 id="分辨率缩放">分辨率缩放
&lt;/h1>&lt;p>UE可以较低分辨率渲染场景，然后将图像延展到目标分辨率。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00007.png"
width="939"
height="353"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00007_hu_8b00d92bde1ea5f.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00007_hu_b363202e6dacd546.png 1024w"
loading="lazy"
alt="左：50%无AA，中间：50%有AA，右：100%（无分辨率缩放）有AA"
class="gallery-image"
data-flex-grow="266"
data-flex-basis="638px"
>&lt;/p>
&lt;h1 id="视图距离">视图距离
&lt;/h1>&lt;p>对象可以根据与查看者的距离而剔除。默认情况下，所有对象都不会随距离而剔除（所需最大绘制距离为0）。除了设计者指定的值之外，还有一个全局可延展性设置，其作用类似于乘数（r.ViewDistanceScale）。下图您可以看到一些草对象（所需最大绘制距离为1000）：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00006.png"
width="1431"
height="314"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00006_hu_d40726dcea105a47.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00006_hu_9697e1379c2915c4.png 1024w"
loading="lazy"
alt="左： r.ViewDistanceScale 0.4，中间：r.ViewDistanceScale 0.7，右：r.ViewDistanceScale 1.0（默认值）"
class="gallery-image"
data-flex-grow="455"
data-flex-basis="1093px"
>&lt;/p>
&lt;h1 id="抗锯齿">抗锯齿
&lt;/h1>&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_aa_small.png"
width="920"
height="216"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_aa_small_hu_298278cc3782843.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_aa_small_hu_548e393c642400f7.png 1024w"
loading="lazy"
alt="从左开始：r.PostProcessAAQuality 0到6。前3个等于 视图（View）-&amp;gt;可延展性选项（Scalability Options）-&amp;gt;AA 设置中的 低（Low）、中（Medium）、高（High）、Epic 设置。"
class="gallery-image"
data-flex-grow="425"
data-flex-basis="1022px"
>&lt;/p>
&lt;h1 id="后期处理sgpostprocessquality">后期处理——sg.PostProcessQuality
&lt;/h1>&lt;h1 id="阴影sgshadowquality">阴影——sg.ShadowQuality
&lt;/h1>&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_shadowquallevels.png"
width="4065"
height="665"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_shadowquallevels_hu_83ca908e3725a514.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_shadowquallevels_hu_a2c094256dc9599c.png 1024w"
loading="lazy"
alt="sg.ShadowQuality左侧设置为0，依次向右递增到3。"
class="gallery-image"
data-flex-grow="611"
data-flex-basis="1467px"
>&lt;/p>
&lt;p>视图（View）-&amp;gt;引擎可延展性设置（Engine Scalability Settings）-&amp;gt;阴影（Shadows） 选项根据[UE_InstallPath]/Engine/Config文件夹中 BaseScalability.ini 文件中的设置，调节动态阴影的质量。低（Low） 设置等于 sg.ShadowQuality 0，Epic 等于 sg.ShadowQuality 3。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>sg.ShadowQuality 0&lt;/th>
&lt;th>sg.ShadowQuality 1&lt;/th>
&lt;th>sg.ShadowQuality 2&lt;/th>
&lt;th>sg.ShadowQuality 3&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.LightFunctionQuality=0&lt;/td>
&lt;td>r.LightFunctionQuality=1&lt;/td>
&lt;td>r.LightFunctionQuality=1&lt;/td>
&lt;td>r.LightFunctionQuality=1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.ShadowQuality=0&lt;/td>
&lt;td>r.ShadowQuality=2&lt;/td>
&lt;td>r.ShadowQuality=5&lt;/td>
&lt;td>r.ShadowQuality=5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.CSM.MaxCascades=1&lt;/td>
&lt;td>r.Shadow.CSM.MaxCascades=1&lt;/td>
&lt;td>r.Shadow.CSM.MaxCascades=2&lt;/td>
&lt;td>r.Shadow.CSM.MaxCascades=4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.MaxResolution=512&lt;/td>
&lt;td>r.Shadow.MaxResolution=1024&lt;/td>
&lt;td>r.Shadow.MaxResolution=1024&lt;/td>
&lt;td>r.Shadow.MaxResolution=1024&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.RadiusThreshold=0.06&lt;/td>
&lt;td>r.Shadow.RadiusThreshold=0.05&lt;/td>
&lt;td>r.Shadow.RadiusThreshold=0.03&lt;/td>
&lt;td>r.Shadow.RadiusThreshold=0.03&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.DistanceScale=0.6&lt;/td>
&lt;td>r.Shadow.DistanceScale=0.7&lt;/td>
&lt;td>r.Shadow.DistanceScale=0.85&lt;/td>
&lt;td>r.Shadow.DistanceScale=1.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.CSM.TransitionScale=0&lt;/td>
&lt;td>r.Shadow.CSM.TransitionScale=0.25&lt;/td>
&lt;td>r.Shadow.CSM.TransitionScale=0.8&lt;/td>
&lt;td>r.Shadow.CSM.TransitionScale=1.0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="纹理sgtexturequality">纹理——sg.TextureQuality
&lt;/h1>&lt;p>主流渲染引擎需要更多GPU内存（纹理、网格体、GBuffer、深度缓冲、阴影贴图）。其中一些根据屏幕分辨率缩放（例如GBuffer），另一些有特定的质量设置（例如，阴影贴图）。使用大量GPU内存的另一个因素是所用的纹理（通常压缩并流送）。您可以指示流送系统在管理上更主动一些（缩小池大小、剔除不用的纹理），或者在mip等级计算中拥有更少或更多细节。这样会影响图像质量、您能够注意到的纹理流送瑕疵数量以及游戏的运行流畅度（更新需要高成本内存传输）。结果不尽相同，具体取决于介质（例如，更快/更慢的硬盘/SSD）。从DVD/蓝光流送会大幅增加延迟，因此应当尽量避免。&lt;/p></description></item><item><title>屏幕百分比与时序上采样</title><link>https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/ue5-hero.png" alt="Featured image of post 屏幕百分比与时序上采样" />&lt;p>屏幕百分比 是一种分辨率调节技术，用于渲染分辨率低于或高于实际显示图像的图像。通过调节屏幕百分比，你的游戏可以在性能和图像分辨率之间保持平衡。&lt;/p>
&lt;p>在虚幻引擎4（UE4）4.19版之前，你只需要更改屏幕百分比，但现在它分成了渲染管道中的两类缩放：主要和次要空间放大。&lt;/p>
&lt;ul>
&lt;li>主要空间放大（Primary Spatial Upscaling） 就是以前使用的屏幕百分比功能。它的基本理念是以较低的分辨率渲染画面，然后先放大，再绘制用户界面（UI）。&lt;/li>
&lt;li>次要空间放大（Secondary Spatial Upscaling） 执行第二次也是最终的空间放大传递，与主要放大传递无关。&lt;/li>
&lt;/ul>
&lt;h1 id="主要屏幕百分比">主要屏幕百分比
&lt;/h1>&lt;p>主要空间放大（即主要屏幕百分比）的工作方式是按屏幕百分比渲染屏幕分辨率，然后进行缩放以适应你的当前屏幕分辨率。如果使用较低的屏幕百分比（或较低的分辨率），然后放大，就称为上采样。或者，在屏幕百分比增大之后（按较高的分辨率渲染），会缩小到当前屏幕的分辨率，这称为 超级取样。这一切都发生在绘制用户界面（UI）之前，可能对性能产生影响。&lt;/p>
&lt;p>关于屏幕分辨率如何对组成屏幕上所渲染图像的所有缓冲区渲染目标起作用并使其组成一个GPU帧的概念，可以作如下说明：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/noupscaling.png"
width="3438"
height="756"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/noupscaling_hu_a56b0b94ff49f685.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/noupscaling_hu_68d8d1e071c3ada9.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="454"
data-flex-basis="1091px"
>&lt;/p>
&lt;p>对于每个GPU帧，所有渲染目标在管道中自始至终使用其全分辨率。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialupscale.png"
width="3846"
height="894"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialupscale_hu_fd607ba54dfd06c.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialupscale_hu_d615b3a5f061052b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="430"
data-flex-basis="1032px"
>&lt;/p>
&lt;p>在使用空间放大的情况下，在UI之前绘制的一切都根据所用的屏幕百分比使用或高或低的分辨率。屏幕百分比已经降低（从UI之前变窄的渲染目标可以看出），为渲染目标产生了降低分辨率的图像。空间缩放发生在UI之前，将图像缩放至将要输出的屏幕分辨率。例如，如果当前分辨率设置为1920x1080，并且使用83%的屏幕分辨率，那么渲染目标的大小将调整为近似的1600x900分辨率，然后重新放大到1920x1080。&lt;/p>
&lt;h2 id="空间放大质量">空间放大质量
&lt;/h2>&lt;p>在放大渲染目标时，可以使用以下控制台变量定义放大质量：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.Upscale.Quality
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它控制屏幕百分比和全屏窗口模式缩放3D渲染的质量&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>上采样质量数值&lt;/th>
&lt;th>上采样结果&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>最接近的过滤&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>简单双线&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>定向模糊，带有非锐化遮罩上采样&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>5-tap Catmull-Rom双立方插值，近似Lanczos 2（默认）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>13-tap Lanczos 3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>36-tap高斯过滤非锐化遮罩（成本非常高，但很适合极端上采样）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>或者，你可以使用下列控制台变量来控制如何处理色调映射器传递：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.Tonemapper.MergeWithUpscale.Mode
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>色调映射器集成了一个简单的颜色空间空间放大，可以因为性能原因而使用值 1 来启用它。但是，如果材质后期处理在色调映射器之后插入，那么色调映射器就不会执行放大。它将重新使用主要空间放大，就像被禁用了一样。&lt;/p>
&lt;h1 id="时序抗锯齿上采样">时序抗锯齿上采样
&lt;/h1>&lt;p>除了主要空间放大外，主要屏幕分辨率还支持第二种放大技术：时序上采样。在时序抗锯齿上采样（TAAU）中，不是先使用时序抗锯齿（TAA）执行临时集成，然后再执行主要空间放大，实际上这两者是同时发生的。它们也可以收敛为比仅使用空间放大时更锐利的图像，不过这样做的成本也会比较高，因为要在较高的分辨率下运行更多后期处理。动态分辨率还可以隐藏主要屏幕百分比更改，从而更频繁地进行更改，尽可能接近地匹配GPU预算。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialandtemporalupsample.png"
width="3438"
height="900"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialandtemporalupsample_hu_c8f09a40596542b4.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialandtemporalupsample_hu_ddb8b500a85c5109.png 1024w"
loading="lazy"
alt="TAAU在管道中发生得比较早，这导致在其后的传递会以较高的分辨率渲染，因此以较高的成本产生更为锐利的图像。"
class="gallery-image"
data-flex-grow="382"
data-flex-basis="916px"
>&lt;/p>
&lt;p>应该注意的是，在使用时序上采样时，不同的后期处理顺序不会因为增加TAAU而改变，因为它只是取代了TAA。真正的差别是，在TAAU之前进行的所有处理都将先使用较低的分辨率，然后上采样到TAAU传递之后的分辨率。在4.19版之前，是假定后期处理中的分辨率始终不变。&lt;/p>
&lt;blockquote>
&lt;p>在主要屏幕百分比降低后，到干净的全分辨率输出的收敛会改变。因此，一些原有的TAA瑕疵会变得更明显。例如在非常细的几何体上，锯齿可能成为问题，增加在降低主要屏幕百分比时丢失此几何体细节的概率。&lt;/p>&lt;/blockquote>
&lt;h2 id="启用时序上采样">启用时序上采样
&lt;/h2>&lt;p>要使用时序抗锯齿上采样，你需要进入&amp;quot;项目设置（Project Setting）&amp;ldquo;中找到 时序上采样（Temporal Upsampling），更简单的办法是使用下列控制台变量：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.TemporalAA.Upsampling 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果使用空间放大的主要屏幕百分比较低，在降低分辨率时，可能丢失重要细节。例如，对于铁链栅栏或者车头的格栅，当使用时序抗锯齿时，可能在较远的距离比较难以看清细节。如果启用TAAU，就可以在仍然使用降低的屏幕百分比的情况下减少这一问题。&lt;/p>
&lt;h2 id="automatic-view-texture-mip-bias">Automatic View Texture Mip Bias
&lt;/h2>&lt;p>因为屏幕百分比会导致几何体以较低的像素密度渲染，所以时序上采样需要更多来自 表面 和 延迟贴花 材质域的纹理信息才能保持输出锐利度不变。为此，在默认情况下可以使用纹理取样表达式 Automatic View Mip Bias。&lt;/p>
&lt;p>纹理取样表达式可使用 Automatic View Mip Bias 来切换是否应该通过逐视图的Mip偏差对纹理进行取样，从而使时序抗锯齿具有更锐利的输出。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbias.png"
width="738"
height="341"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbias_hu_1bd7afd8befa9033.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbias_hu_b711cde2c84d739e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;p>对于高频纹理（例如下面的示例），自动Mip偏差在较低的屏幕百分比下可能问题较多。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/hftexture.png"
width="512"
height="512"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/hftexture_hu_58bc6f70ef516626.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/hftexture_hu_72b2ecfa6ec94149.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>&lt;/p>
&lt;p>在这种情况下，可以使用Mip偏差输入来补偿，或者选择不使用 Automatic View Mip Bias。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbiasunchecked.png"
width="738"
height="341"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbiasunchecked_hu_2d727bab8ab3de8d.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbiasunchecked_hu_dc4107ed014c88b3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;blockquote>
&lt;p>Automatic View Mip Bias 仅发生在启用TAAU的情况下。常规抗锯齿方法（TAA、MSAA和FXAA）将无法使用此选项。&lt;/p>&lt;/blockquote>
&lt;h2 id="实现抗锯齿质量的着色器性能permutation">实现抗锯齿质量的着色器性能Permutation
&lt;/h2>&lt;p>和TAA一样，临时放大采样附带用于实现后期处理质量3和4的更快着色器Permutation。着色器Permutation换来的是一定的质量，能够在主机平台上发布60Hz运行的作品。质量设置与设置后期处理质量时已经使用的设置相似。此外还应牢记，TAAU需要比TAA更多的工作，因为它是在较高的分辨率下运行，并且在TAAU传递之后还有后期处理。&lt;/p>
&lt;p>可以使用下列控制台变量调节后期处理质量：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.PostProcessAAQuality
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>值得注意的是，时序上采样之后的后期处理是在全分辨率下运行的，所以禁用TAA将使它们在较低的分辨率下运行，这是因为它们将在最后进行空间放大，从而加快后期处理的速度。请使用命令profileGPU来调查每次传递中GPU性能的明细，使用的是什么传递，以及大部分预算用在哪里。&lt;/p>
&lt;p>下表说明了使用这些范围中的主要屏幕百分比值设置时你可以期待的结果：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>屏幕范围&lt;/th>
&lt;th>百分比&lt;/th>
&lt;th>备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>50%&lt;/td>
&lt;td>71%&lt;/td>
&lt;td>这是提高性能的最快方法，因为它在内存中使用较小的本地数据存储（LDS）块。如果目标是在台式机和游戏机上时序上采样到4K，这是理想的选择。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>71%&lt;/td>
&lt;td>100%&lt;/td>
&lt;td>对于台式机和游戏机上的普通DPI（每英寸点数）渲染是理想选择。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>100%&lt;/td>
&lt;td>200%&lt;/td>
&lt;td>如果要使动态分辨率在不被用于渲染目标的GPU内存限制的前提下具有超过100%的理论可能，那么这是理想选择。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>纹理流送</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81/ue5-hero.png" alt="Featured image of post 纹理流送" />&lt;p>纹理流送系统，又称纹理流送器，是引擎中负责提高和降低每个纹理分辨率的部分。这能让你有用出色的视觉效果的同时，可以有效管理内存。&lt;/p>
&lt;h1 id="入门">入门
&lt;/h1></description></item><item><title>虚拟纹理</title><link>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 虚拟纹理" />&lt;p>利用项目对虚拟纹理的这次hi，可在运行时以更低内存占用率和更高一致性创建和使用大尺寸纹理。&lt;/p>
&lt;h1 id="虚拟纹理方法">虚拟纹理方法
&lt;/h1>&lt;p>虚幻引擎4(UE4)支持两种虚拟纹理方法：运行时虚拟纹理 (RVT) 和 流送虚拟纹理 (SVT)。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运行时虚拟纹理&lt;/th>
&lt;th>流送虚拟纹理&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>支持超高纹理分辨率。&lt;/td>
&lt;td>支持超高纹理分辨率。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>按需将纹素数据缓存于内存中。&lt;/td>
&lt;td>按需将纹素数据缓存于内存中。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>运行时由GPU生成的纹素数据。&lt;/td>
&lt;td>在硬盘中烘焙和加载纹素数据。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>非常适用于可按需渲染的纹理数据，如过程纹理或合成分层材质。&lt;/td>
&lt;td>非常适用于生成时间较长的纹理数据，如光照贴图或美术师创建的大型细节纹理。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="运行时虚拟纹理">运行时虚拟纹理
&lt;/h2>&lt;p>利用 运行时虚拟纹理 可有效渲染过程生成或分层的复杂材质，使运行时虚拟纹理适用于渲染复杂的地形材质。其能改善地形样条、网格体和材质贴花，及一般地形与对象混合的渲染性能和工作流程。&lt;/p>
&lt;blockquote>
&lt;p>欲了解更多详情，参见运行时虚拟纹理。&lt;/p>&lt;/blockquote></description></item><item><title>可视性和遮挡剔除</title><link>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/randg_herobanner.png" alt="Featured image of post 可视性和遮挡剔除" />&lt;p>虚幻引擎提供了可视性和遮挡剔除方法。这些剔除方法用于优化游戏性能。每种方法都可以通过设置是否应绘制到屏幕上来减少关卡中的可见Actor数量。部分方法（如视锥体和硬件遮挡查询）可以同时使用，或者更好的适应特定设备和平台（如用于虚拟显示的轮询遮挡）。&lt;/p></description></item><item><title>剔除距离体积</title><link>https://zentia.github.io/p/%E5%89%94%E9%99%A4%E8%B7%9D%E7%A6%BB%E4%BD%93%E7%A7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%89%94%E9%99%A4%E8%B7%9D%E7%A6%BB%E4%BD%93%E7%A7%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%89%94%E9%99%A4%E8%B7%9D%E7%A6%BB%E4%BD%93%E7%A7%AF/randg_herobanner.png" alt="Featured image of post 剔除距离体积" />&lt;p>剔除距离体积（Cull Distance Volume） 是非常有用的优化工具，它定义绘制（显现）该体积中的Actor的距离。这些体积可存储任意数量的&amp;quot;大小&amp;quot;和&amp;quot;距离&amp;quot;组合（称为 剔除距离对）。这些剔除距离对会被映射到Actor（沿其最长有效维度）的边界，然后指定给关卡中的该Actor实例。剔除距离体积（Cull Distance Volume）对于优化包含精细内部空间的大型室外关卡非常有用。当室内空间小到可被视为不重要时，可以剔除它们。&lt;/p></description></item></channel></rss>