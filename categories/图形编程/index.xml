<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>图形编程 on zentia</title><link>https://zentia.github.io/categories/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</link><description>Recent content in 图形编程 on zentia</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://zentia.github.io/categories/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>FShaderCache</title><link>https://zentia.github.io/p/fshadercache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/fshadercache/</guid><description>&lt;img src="https://zentia.github.io/p/fshadercache/ue5-hero.png" alt="Featured image of post FShaderCache" />&lt;h1 id="总览">总览
&lt;/h1>&lt;p>FShaderCache提供的机制可减少游戏中着色器的卡顿。它支持OpenGLDrv和MetalRHI RHIs，可在Mac、Linux和windows平台上使用。&lt;/p>
&lt;p>可通过多个控制台命令启用或禁用FShaderCache功能。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制台命令&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.UseShaderCaching [0/1]&lt;/td>
&lt;td>着色器反序列化中早提交，不为请求式。追踪束缚着色器态，使它们在早提交中被预束缚。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="使用">使用
&lt;/h1>&lt;p>应在开发机上启用&lt;code>r.UseShaderCaching&lt;/code>和&lt;code>r.UseShaderDrawLog&lt;/code>填充缓存。用户/玩家启用&lt;code>r.UseShaderCaching&lt;/code>和&lt;code>r.UseShaderPredraw&lt;/code>消耗缓存。&lt;/p></description></item><item><title>插件中的 Shader</title><link>https://zentia.github.io/p/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84-shader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84-shader/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84-shader/ue5-hero.png" alt="Featured image of post 插件中的 Shader" />&lt;p>全局着色器（Global Shaders）是不通过材质编辑器创建的着色器。相反，全局着色器使用C++创建，它们在固定的几何体上运行，并且无需与材质或网格体结合。有时候，必须使用更高级的功能才能实现某些外观，为此，有必要自定义着色器通道。&lt;/p>
&lt;p>全局着色器的部分示例包括渲染后期处理效果、分配计算着色器和清空屏幕。&lt;/p>
&lt;h1 id="虚幻着色器文件">虚幻着色器文件
&lt;/h1></description></item><item><title>在虚幻引擎中添加全局着色器</title><link>https://zentia.github.io/p/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E7%9D%80%E8%89%B2%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E7%9D%80%E8%89%B2%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E7%9D%80%E8%89%B2%E5%99%A8/ue5-hero.png" alt="Featured image of post 在虚幻引擎中添加全局着色器" />&lt;p>全局着色器（Global Shaders）是不通过材质编辑器创建的着色器。相反，全局着色器使用C++创建，它们在固定的几何体上运行，并且无需与材质或网格体结合。有时候，必须使用更高级的功能才能实现某些外观，为此，有必要自定义着色器通道。&lt;/p>
&lt;p>全局着色器的部分示例包括渲染后期处理效果、分配计算着色器和清空屏幕。&lt;/p>
&lt;h1 id="虚幻着色器文件">虚幻着色器文件
&lt;/h1></description></item><item><title>HLSL 交叉编译器</title><link>https://zentia.github.io/p/hlsl-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/hlsl-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/hlsl-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/ue5-hero.png" alt="Featured image of post HLSL 交叉编译器" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>引擎中的渲染器模块管理并渲染场景，而场景拥有和每个世界场景相关的可渲染信息。它包括所有绘制规则和着色器的定义。&lt;/p>
&lt;p>RHI 模块是渲染 API 的接口，是图形编程的另一个关键组件。图形编程介绍包含许多可研究的键类、设置和变量，以下子页面包含详细的渲染要点。&lt;/p></description></item><item><title>网格体绘制管道</title><link>https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/ue5-hero.png" alt="Featured image of post 网格体绘制管道" />&lt;p>本页包含的信息适用于那些想要添加自定义网格体通道，或者想要理解虚幻引擎网格绘制性能特征的程序员。&lt;/p>
&lt;p>网格体绘制管道基于保留模式的概念，其中所有场景绘制都是预先准备好的，而不是每帧都构建它们。它还具有积极缓存和绘制调用合并功能，以便利用静态网格体的属性，这些属性很少变化，可能跨帧重用。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/meshpipelineoverview_1.png"
width="1440"
height="818"
srcset="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/meshpipelineoverview_1_hu_fc257fa650f13a0f.png 480w, https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/meshpipelineoverview_1_hu_1157196d3358ca6c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="422px"
>&lt;/p>
&lt;p>网格体渲染从&lt;code>FPrimitiveSceneProxy&lt;/code>开始，这是游戏线程的&lt;code>UPrimitiveComponent&lt;/code>渲染线程表示。&lt;/p></description></item><item><title>调试着色器编译过程</title><link>https://zentia.github.io/p/%E8%B0%83%E8%AF%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%B0%83%E8%AF%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%B0%83%E8%AF%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/ue5-hero.png" alt="Featured image of post 调试着色器编译过程" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>引擎中的渲染器模块管理并渲染场景，而场景拥有和每个世界场景相关的可渲染信息。它包括所有绘制规则和着色器的定义。&lt;/p>
&lt;p>RHI 模块是渲染 API 的接口，是图形编程的另一个关键组件。图形编程介绍包含许多可研究的键类、设置和变量，以下子页面包含详细的渲染要点。&lt;/p></description></item><item><title>并行渲染介绍</title><link>https://zentia.github.io/p/%E5%B9%B6%E8%A1%8C%E6%B8%B2%E6%9F%93%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%B9%B6%E8%A1%8C%E6%B8%B2%E6%9F%93%E4%BB%8B%E7%BB%8D/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%B9%B6%E8%A1%8C%E6%B8%B2%E6%9F%93%E4%BB%8B%E7%BB%8D/ue5-hero.png" alt="Featured image of post 并行渲染介绍" />&lt;h1 id="线程概述">线程概述
&lt;/h1>&lt;p>最初，渲染器运行在渲染线程中，游戏线程将该线程的命令排队，以便稍后在帧中运行。这些命令会调用渲染硬件接口（RHI）曾，它是受支持的平台上不同图形API的跨平台接口。&lt;/p>
&lt;p>为了提高此过程的效率并利用受支持的平台功能，渲染线程现在作为一个前端，将不受平台限制的图形命令排入渲染器的命令列表，然后新的RHI线程通过后端的相应图形API转换（执行）这些命令。借助这种分离，可在支持它的平台（例如游戏机、DX12和Vulkan）上实现独立的后端并行化。一般来说，在前端并行生成的任何内容都会在后端并行转换。&lt;/p>
&lt;blockquote>
&lt;p>某些命令可在不使用命令列表系统的情况下执行，例如锁定和解锁操作。这些命令由渲染线程直接发出。在这些情况下，引擎要么转储清楚RHI线程并等待操作完成，要么复制数据并对其进行排队。实现方式根据操作和平台的不同而异。&lt;/p>&lt;/blockquote></description></item><item><title>着色器调试工作流程</title><link>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/ue5-hero.png" alt="Featured image of post 着色器调试工作流程" />&lt;h1 id="渲染线程">渲染线程
&lt;/h1>&lt;p>在虚幻引擎中，整个渲染器在其自身的线程中执行操作，该线程位于游戏线程的一两帧后。&lt;/p>
&lt;p>执行渲染操作时，必须仔细地考虑内存读写，确保线程安全，以及行为的确定性。功能行为取决于两个线程之间的执行速度差，这种情况被称作竞争条件。需要尽量避免竞争条件的出现，因为它们难以重现；且因为速度差的缘故，它们可能依赖于机器、平台、调试器或配置。这类 bug 很难进行调试，所花费的修复时间约为可重现的普通 bug 的 10 倍。&lt;/p></description></item><item><title>渲染依赖图</title><link>https://zentia.github.io/p/%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/ue5-hero.png" alt="Featured image of post 渲染依赖图" />&lt;p>渲染依赖图（Render Dependency Graph），也称为渲染图或RDG，是一种即时模式应哟个程序编程接口（API），它将要编译和执行的渲染命令记录到图数据结构中。RDG通过自动化易出错的操作来简化代码，并遍历依赖图以优化内存使用并在CPU和GPU上进行渲染通道。&lt;/p></description></item><item><title>异步计算</title><link>https://zentia.github.io/p/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/ue5-hero.png" alt="Featured image of post 异步计算" />&lt;p>渲染硬件接口（RHI）现支持 Xbox One 的异步计算（AsyncCompute）。此法可运行与渲染异步的 dispatch() 调用，有效利用未使用的 GPU 资源（计算单元（CU）、寄存器和带宽）。异步计算使用单独的上下文，我们通过 RHI 函数同步渲染和计算上下文。Dr PIX 可用于识别从异步计算获益的区域。例如，特定渲染通道中半数 CU 均未使用，这些 CU 则可能被异步计算任务所利用。异步计算存在一些限制：&lt;/p></description></item><item><title>图形编程介绍</title><link>https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D/ue5-hero.png" alt="Featured image of post 图形编程介绍" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>虚幻引擎中有许多渲染代码，因此要通过粗略的观察来迅速了解渲染状况较为困难。阅读代码时，比较好的入手之处是&lt;code>FDefferedShadingSceneRenderer::Render&lt;/code>，这是渲染线程中渲染新帧之处。此外，执行profilegpu命令并查看绘制事件也很有帮助。然后，您可以在Visual Studio中对绘制事件名称进行Find in Files操作，找出对应的C++实现。&lt;/p></description></item><item><title>线程渲染</title><link>https://zentia.github.io/p/%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/ue5-hero.png" alt="Featured image of post 线程渲染" />&lt;h1 id="渲染线程">渲染线程
&lt;/h1>&lt;p>在虚幻引擎中，整个渲染器在其自身的线程中执行操作，该线程位于游戏线程的一两帧后。&lt;/p>
&lt;p>执行渲染操作时，必须仔细地考虑内存读写，确保线程安全，以及行为的确定性。功能行为取决于两个线程之间的执行速度差，这种情况被称作竞争条件。需要尽量避免竞争条件的出现，因为它们难以重现；且因为速度差的缘故，它们可能依赖于机器、平台、调试器或配置。这类 bug 很难进行调试，所花费的修复时间约为可重现的普通 bug 的 10 倍。&lt;/p></description></item><item><title>着色器开发</title><link>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91/ue5-hero.png" alt="Featured image of post 着色器开发" />&lt;h1 id="快速入门">快速入门
&lt;/h1>&lt;p>处理着色器时，请务必将&lt;code>r.ShaderDevelopmentMode&lt;/code>设置为1，以将其启用。最简单的方法是编辑&lt;code>ConsoleVariables.ini&lt;/code>，以便每次加载时都进行启用。这将启用“出错时重试”以及与着色器开发的日志和警告。&lt;/p>
&lt;p>请使用&lt;code>Ctrl+Shift+.&lt;/code>，这样会执行recompileshaders changed命令。这个命令应该在你将更改保存到Unreal Shader (.usf)文件后执行。&lt;/p></description></item></channel></rss>