<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计视觉、渲染和图形效果 on zentia</title><link>https://zentia.github.io/categories/%E8%AE%BE%E8%AE%A1%E8%A7%86%E8%A7%89%E6%B8%B2%E6%9F%93%E5%92%8C%E5%9B%BE%E5%BD%A2%E6%95%88%E6%9E%9C/</link><description>Recent content in 设计视觉、渲染和图形效果 on zentia</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://zentia.github.io/categories/%E8%AE%BE%E8%AE%A1%E8%A7%86%E8%A7%89%E6%B8%B2%E6%9F%93%E5%92%8C%E5%9B%BE%E5%BD%A2%E6%95%88%E6%9E%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>FShaderCache</title><link>https://zentia.github.io/p/fshadercache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/fshadercache/</guid><description>&lt;img src="https://zentia.github.io/p/fshadercache/ue5-hero.png" alt="Featured image of post FShaderCache" />&lt;h1 id="总览">总览
&lt;/h1>&lt;p>FShaderCache提供的机制可减少游戏中着色器的卡顿。它支持OpenGLDrv和MetalRHI RHIs，可在Mac、Linux和windows平台上使用。&lt;/p>
&lt;p>可通过多个控制台命令启用或禁用FShaderCache功能。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制台命令&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.UseShaderCaching [0/1]&lt;/td>
&lt;td>着色器反序列化中早提交，不为请求式。追踪束缚着色器态，使它们在早提交中被预束缚。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="使用">使用
&lt;/h1>&lt;p>应在开发机上启用&lt;code>r.UseShaderCaching&lt;/code>和&lt;code>r.UseShaderDrawLog&lt;/code>填充缓存。用户/玩家启用&lt;code>r.UseShaderCaching&lt;/code>和&lt;code>r.UseShaderPredraw&lt;/code>消耗缓存。&lt;/p></description></item><item><title>材质基本概念</title><link>https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ue5-hero.png" alt="Featured image of post 材质基本概念" />&lt;p>虚幻引擎中的材质（Materials）定义了场景中对象的表现属性。从广义上来讲，你可以将材质理解为涂在网格体上用来控制其视觉外观的“涂料”。&lt;/p>
&lt;p>更具体地说，材质能准确地告诉引擎某个表现应该如何与场景中地光源交互。材质定义了表现地各种特性，包括颜色、反射率、粗糙度、透明度等。&lt;/p>
&lt;h1 id="着色管线概述">着色管线概述
&lt;/h1>&lt;p>在渲染管线中，着色器是定义每个顶点或像素应该如何渲染的程序。虚幻引擎中的着色器用高级着色语言（HLSL）编写。然后，将着色器代码转化为GPU硬件可以执行的一系列汇编语言指令。最终像素颜色就这样输出到了你的显示器。&lt;/p>
&lt;p>在虚幻编辑器中，你无需编写HLSL代码即可为你的项目创建着色器。你在名为材质编辑器（Material Editor）的可视化脚本界面中创建名为材质（Material）的资产。&lt;/p></description></item><item><title>插件中的 Shader</title><link>https://zentia.github.io/p/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84-shader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84-shader/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84-shader/ue5-hero.png" alt="Featured image of post 插件中的 Shader" />&lt;p>全局着色器（Global Shaders）是不通过材质编辑器创建的着色器。相反，全局着色器使用C++创建，它们在固定的几何体上运行，并且无需与材质或网格体结合。有时候，必须使用更高级的功能才能实现某些外观，为此，有必要自定义着色器通道。&lt;/p>
&lt;p>全局着色器的部分示例包括渲染后期处理效果、分配计算着色器和清空屏幕。&lt;/p>
&lt;h1 id="虚幻着色器文件">虚幻着色器文件
&lt;/h1></description></item><item><title>构建纹理流送数据</title><link>https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%95%B0%E6%8D%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%95%B0%E6%8D%AE/ue5-hero.png" alt="Featured image of post 构建纹理流送数据" />&lt;p>每次修改和重新保存材质或材质实例时，会重新计算与使用的每个纹理有关的纹理流送数据。 每个纹理数据包含UV通道索引和缩放，UV通道索引用于对纹理采样， 缩放是应用于被采样通道的乘法因数。&lt;/p>
&lt;p>但是，这不涵盖所有情况，因为采样可能基于场景位置、网格体顶点颜色或任何UV通道组合。这可能会导致无法通过分析 找到相关数据，引擎会假设依赖于UV通道0和缩放1。&lt;/p>
&lt;p>分析在多个不同的步骤运行，具体取决于所编辑的内容：&lt;/p>
&lt;ol>
&lt;li>材质：当用户应用或保存修改时运行。&lt;/li>
&lt;li>材质实例：材质实例编辑器关闭或者保存包含材质实例的包时运行。&lt;/li>
&lt;li>关卡：用户运行&amp;quot;构建纹理流送&amp;quot;时针对每个所用材质运行。用于确保每个材质都是最新的。材质不是最新的原因包括：
&lt;ul>
&lt;li>4.15之前的材质没有任何数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>过场动画景深</title><link>https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/randg_herobanner.png" alt="Featured image of post 过场动画景深" />&lt;p>以下景深方法具有影视级视觉效果，十分接近使用延迟着色渲染器和群集前向渲染器的桌面及主机平台上照片和电影的效果。&lt;/p>
&lt;p>类似于圆圈景深和散景景深，&amp;ldquo;影视级&amp;quot;景深的效果跟真实摄像机不相上下，你可以在锐化&lt;a class="link" href="" >高动态范围 (HDR)&lt;/a>内容中看到圆形散景（离焦区域）。此方法使用程序化散景模拟技术，具有动态分辨率稳定性和阿尔法通道支持，在台式机和主机上开发的项目还具有更快速、可扩展和性能优化等特性。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_disabled.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_disabled_hu_3989771e759a9fa6.png 480w, https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_disabled_hu_216ec5c823000df5.png 1024w"
loading="lazy"
alt="Depth of Field Disabled"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>
&lt;img src="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_enabled.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_enabled_hu_75955f69df7591d6.png 480w, https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_enabled_hu_38507762aa83299c.png 1024w"
loading="lazy"
alt="Cinematic Depth of Field"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;h1 id="对焦拍摄对象">对焦拍摄对象
&lt;/h1>&lt;p>实现美学意义上宜人景深效果的关键在于对焦拍摄对象。对于特定拍摄情形，影响景深设置的核心因素有三个：&lt;/p>
&lt;ul>
&lt;li>确定镜头要使用的 焦距（Focal Length）。&lt;/li>
&lt;li>选择合适的 孔径（Aperture）（F值）。&lt;/li>
&lt;li>选择拍摄对象与摄像机之间的 对象距离（Distance to your Subject）。&lt;/li>
&lt;/ul>
&lt;p>为了理解调整这些设置时会产生怎样的效果，我们来分析一下构成摄像机和拍摄场景的各个要素：&lt;/p></description></item><item><title>抗锯齿和上采样</title><link>https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/ue5-hero.png" alt="Featured image of post 抗锯齿和上采样" />&lt;p>抗锯齿（Anti-Aliasing）是指在原本应该平滑的边缘和对象上删除锯齿状或阶梯状线条。抗锯齿的方法有很多种，可以减少这些类型的视觉瑕疵。有些方法用于特定渲染器和平台，而有些则非常适合提高性能和保真度。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-no-aa.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-no-aa_hu_26e4af9b79899ccf.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-no-aa_hu_7fc73724bfe86beb.png 1024w"
loading="lazy"
alt="NO AA"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>抗锯齿方法&lt;/th>
&lt;th>台式机/主机：延迟渲染器&lt;/th>
&lt;th>台式机/主机：正向渲染器&lt;/th>
&lt;th>移动：延迟渲染器&lt;/th>
&lt;th>移动：正向渲染器&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-tsr.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-tsr_hu_9f95e8c4d0f0ccc5.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-tsr_hu_86c08a3921b17e34.png 1024w"
loading="lazy"
alt="时间超级分辨率（TSR）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-taau.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-taau_hu_4667a9742d312003.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-taau_hu_bf41b082c629e164.png 1024w"
loading="lazy"
alt="时间抗锯齿上采样（TAAU）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-fxaa.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-fxaa_hu_5949c8321a4962c8.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-fxaa_hu_6838d61c29aed8cd.png 1024w"
loading="lazy"
alt="快速近似抗锯齿（FXAA）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-msaa.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-msaa_hu_e9220de2f264c372.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-msaa_hu_6e389f3672691dd3.png 1024w"
loading="lazy"
alt="多重采样抗锯齿（MSAA）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>N&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="时间超级分辨率tsr">时间超级分辨率（TSR）
&lt;/h1>&lt;h1 id="时间抗锯齿上采样taau">时间抗锯齿上采样（TAAU）
&lt;/h1>&lt;h1 id="快速近似抗锯齿fxaa">快速近似抗锯齿（FXAA）
&lt;/h1>&lt;h1 id="多重采样抗锯齿msaa">多重采样抗锯齿（MSAA）
&lt;/h1></description></item><item><title>色彩分级面板</title><link>https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/ue5_1-rendering-hero-banner-5-0.png" alt="Featured image of post 色彩分级面板" />&lt;p>颜色分级面板是一个专用的界面，用于在场景中操纵颜色。它使用可以执行颜色分级操作的角色，如后期处理体积和颜色校正区域。&lt;/p>
&lt;p>您可以使用此窗格直接配置颜色分级属性和设置，而不是通过任何单个Actor的详细信息面板。这将使美术人员的配置更直接。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-scene.png"
width="1999"
height="1125"
srcset="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-scene_hu_34d8d5237cf49672.png 480w, https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-scene_hu_32dc2c7aec3027e7.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;h1 id="色彩分级面板接口">色彩分级面板接口
&lt;/h1>&lt;p>您可以通过选择Window &amp;gt; Color Grading从编辑器的主菜单打开Color Grading面板。这个面板在关卡视口的底部打开。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-panelinterface.png"
width="1988"
height="440"
srcset="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-panelinterface_hu_47be657d90b6c411.png 480w, https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-panelinterface_hu_908171332a3043ad.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="451"
data-flex-basis="1084px"
>&lt;/p></description></item><item><title>时间超级分辨率</title><link>https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/ue5-hero.png" alt="Featured image of post 时间超级分辨率" />&lt;p>时间超级分辨率 （TSR）是一个与平台无关的时间分辨率修改器，它使虚幻引擎能够渲染美丽的4K图像。由于将一些开销大的渲染计算分摊到了许多帧，图像的开销只占一小部分。TSR的做法是渲染比虚幻引擎4中的时间抗锯齿上采样（TAAU）更低的内部分辨率。&lt;/p>
&lt;p>TSR提供了一种原生的高质量上采样技术，以满足次世代游戏的需求。它实现了Nanite几何体要求的保真度和细节所需的可能性，同时以低得多的分辨率渲染帧，从而为Lumen提供足够的性能。&lt;/p></description></item><item><title>虚拟纹理内存池</title><link>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E6%B1%A0/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E6%B1%A0/ue5-hero.png" alt="Featured image of post 虚拟纹理内存池" />&lt;p>虚拟纹理系统主要有两种GPU内存分配方式：页表内存（Page Table Memory）和物理内存池（Physical Memory Pool）。&lt;/p></description></item><item><title>运行时虚拟纹理快速入门</title><link>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5-hero.png" alt="Featured image of post 运行时虚拟纹理快速入门" />&lt;blockquote>
&lt;p>本指南要求使用了在Epic Games启动程序中示例选项卡下的内容示例项目中的材质。虽然不使用这些材质也可以完成以下步骤，但为了设置地形，使其正常生效，需要使用绘制好的地形材质。在继续前，打开 示例 选项卡下的内容示例项目 Landscapes 地图，以配合本指南的学习。&lt;/p>&lt;/blockquote>
&lt;p>在运行时 虚拟纹理（RVT） 快速入门中，将介绍在你的项目中针对地形和非地形组件设置和使用RVT的过程。&lt;/p>
&lt;p>在开始本指南前，出于以下原因，理解运行时虚拟纹理最适用于地形十分重要：&lt;/p>
&lt;ul>
&lt;li>复杂的地形材质缓存着色效果，可提高性能。&lt;/li>
&lt;li>使用样条型和贴花类效果可提高质量和加强变体。&lt;/li>
&lt;li>由同一RVT资产处理非地形Acor与地形的混合。&lt;/li>
&lt;/ul>
&lt;p>完成本指南后，你会更了解：&lt;/p>
&lt;ul>
&lt;li>设置运行时虚拟纹理资产以及它连接到不同组件的方式。&lt;/li>
&lt;li>为地形材质启用运行时虚拟纹理。&lt;/li>
&lt;li>在关卡中设置运行时虚拟纹理体积。&lt;/li>
&lt;li>设置更多Actor以渲染至运行时虚拟纹理。&lt;/li>
&lt;/ul>
&lt;h1 id="项目设置">项目设置
&lt;/h1>&lt;p>使用运行时虚拟纹理前，必须先为项目启用它。执行以下步骤：&lt;/p>
&lt;ol>
&lt;li>在主菜单中，选择 编辑（Edit） 菜单并选择 项目设置（Project Settings）。在 引擎（Engine） &amp;gt; 渲染（Rendering） &amp;gt; 虚拟纹理（Virtual Textures） 类目下，将 启用虚拟纹理支持（Enable Virtual texture support） 设为true。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-1-1-project-settings.png"
width="1335"
height="841"
srcset="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-1-1-project-settings_hu_1b525a045f762b43.png 480w, https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-1-1-project-settings_hu_ad61ae4b957f1e3b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
>&lt;/p>
&lt;ol start="2">
&lt;li>重启 项目。&lt;/li>
&lt;/ol>
&lt;h1 id="创建运行时虚拟纹理资产">创建运行时虚拟纹理资产
&lt;/h1>&lt;p>运行时虚拟纹理 资产包含指定给运行时虚拟纹理体积的RVT资产的配置详情。RVT资产的工作原理是链接场景中需共享数据的材质和其他Actor。&lt;/p>
&lt;ol>
&lt;li>在 内容侧滑菜单 中，利用右键点击快捷菜单或 添加（+Add） 按钮从 纹理（Textures） 类目创建 运行时虚拟纹理 资产。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-content-drawer-add-new-runtime-virtual-texturing-asset.png"
width="612"
height="906"
srcset="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-content-drawer-add-new-runtime-virtual-texturing-asset_hu_64120219a2e20565.png 480w, https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-content-drawer-add-new-runtime-virtual-texturing-asset_hu_c54ac6ca6feb8f6a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="67"
data-flex-basis="162px"
>&lt;/p>
&lt;ol start="2">
&lt;li>为 运行时虚拟纹理 资产命名。在本指南中，命名为 VT_Test。&lt;/li>
&lt;li>双击打开此 运行时虚拟纹理 资产编辑器，以配置其可用属性。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-runtime-virtual-texturing-asset-window.png"
width="960"
height="768"
srcset="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-runtime-virtual-texturing-asset-window_hu_9aa5a3f872bb81ed.png 480w, https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-runtime-virtual-texturing-asset-window_hu_57c88a2caeaa1f65.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="300px"
>&lt;/p>
&lt;p>在此窗口中，你可以定义运行时虚拟纹理（RSV）支持的大小、图块大小和材质属性类型。这些熟悉可以实时调整，并在编辑器中实时查看改动效果。&lt;/p>
&lt;blockquote>
&lt;p>欲知这些设置的详情和用途，参阅虚拟纹理设置页面。&lt;/p>&lt;/blockquote></description></item><item><title>在虚幻引擎中添加全局着色器</title><link>https://zentia.github.io/p/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E7%9D%80%E8%89%B2%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E7%9D%80%E8%89%B2%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E7%9D%80%E8%89%B2%E5%99%A8/ue5-hero.png" alt="Featured image of post 在虚幻引擎中添加全局着色器" />&lt;p>全局着色器（Global Shaders）是不通过材质编辑器创建的着色器。相反，全局着色器使用C++创建，它们在固定的几何体上运行，并且无需与材质或网格体结合。有时候，必须使用更高级的功能才能实现某些外观，为此，有必要自定义着色器通道。&lt;/p>
&lt;p>全局着色器的部分示例包括渲染后期处理效果、分配计算着色器和清空屏幕。&lt;/p>
&lt;h1 id="虚幻着色器文件">虚幻着色器文件
&lt;/h1></description></item><item><title>HLSL 交叉编译器</title><link>https://zentia.github.io/p/hlsl-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/hlsl-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/hlsl-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/ue5-hero.png" alt="Featured image of post HLSL 交叉编译器" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>引擎中的渲染器模块管理并渲染场景，而场景拥有和每个世界场景相关的可渲染信息。它包括所有绘制规则和着色器的定义。&lt;/p>
&lt;p>RHI 模块是渲染 API 的接口，是图形编程的另一个关键组件。图形编程介绍包含许多可研究的键类、设置和变量，以下子页面包含详细的渲染要点。&lt;/p></description></item><item><title>动态分辨率</title><link>https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/ue5-hero.png" alt="Featured image of post 动态分辨率" />&lt;p>动态分辨率可根据先前画面的GPU工作负载调节主要屏幕百分比。分辨率是基于启发法（按需要）调节的，例如，如果在屏幕上有太多Object，或者有成本高昂的效果突然进入画面，GPU渲染时间将会延长，此时为了维持目标珍露就会降低屏幕分辨率。&lt;/p>
&lt;h1 id="启用动态分辨率">启用动态分辨率
&lt;/h1>&lt;h2 id="在运行时启用动态分辨率">在运行时启用动态分辨率
&lt;/h2>&lt;p>动态分辨率可以通过在 Game User Settings 节点上获取一个布尔数值来启用。你可以在使用蓝图或C++时设置它。&lt;/p>
&lt;p>在 蓝图 中，你可以使用 Game User Settings 节点选择此功能来启用动态分辨率，如下图：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/dynamicresblueprint.png"
width="1405"
height="397"
srcset="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/dynamicresblueprint_hu_2999e788d01f08d0.png 480w, https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/dynamicresblueprint_hu_a22a5d9e60b063e5.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="353"
data-flex-basis="849px"
>&lt;/p>
&lt;p>在 C++ 中，你可以在 UGameUserSettings 设置如下布尔值：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">GEngine&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">GetDynamicResolutionStatus&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetEnabled&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>将 SetEnabled 设置为 false 可将其禁用。&lt;/p>
&lt;blockquote>
&lt;p>在实际启用或禁用动态分辨率时，游戏线程逻辑掌握最终程序控制权限，所以如果你是用蓝图在运行时启动它，这会优先于代码设置。要将游戏用户设置恢复到初始状态，请使用以下命令行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEngine-&amp;gt;GameUserSettings-&amp;gt;ApplyNonResolutionSettings();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/blockquote>
&lt;h2 id="使用运算模式控制动态分辨率">使用运算模式控制动态分辨率
&lt;/h2>&lt;p>你可以使用 &lt;strong>运算模式（Operation Mode）&lt;/strong> 设置如何在游戏中覆盖和使用动态分辨率，设置在游戏中覆盖它和使用它的方式。为了控制这种模式，在项目所对应平台（Xbox One、PlayStation 4等）的平台配置描述（或设备描述）中，你可以使用下列控制台命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.DynamicRes.OperationMode
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用下列数值之一来设置运算模式如何针对项目的平台工作：&lt;/p>
&lt;ul>
&lt;li>根据游戏用户设置状态（在C++或蓝图中设置）启用动态分辨率。&lt;/li>
&lt;li>无论游戏用户设置状态如何都启用动态分辨率。&lt;/li>
&lt;/ul>
&lt;p>启用动态分辨率后，下列控制台变量会设置屏幕百分比的最大值和最小值，以及在降低分辨率之前任何给定帧的最大预算。如果你不设置，这些变量都有默认值：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制台变量&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.DynamicRes.MinScreenPercentage&lt;/td>
&lt;td>50&lt;/td>
&lt;td>设置要使用的最小屏幕百分比。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.DynamicRes.MaxScreenPercentage&lt;/td>
&lt;td>100&lt;/td>
&lt;td>设置用于分配渲染目标的最大主要屏幕百分比。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.DynamicRes.FrameTimeBudget&lt;/td>
&lt;td>33.3&lt;/td>
&lt;td>设置帧预算（以毫秒为单位）。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>你可以使用Unreal Engine中的&amp;quot;设备描述（Device Profiles）&amp;ldquo;窗口设置和管理配置文件。可以通过&amp;quot;文件（File）&amp;ldquo;菜单选择 编辑（Edit）&amp;gt; Developer Tools（开发者工具）&amp;gt; Device Profiles（设备描述） 来访问此窗口。&lt;/p>&lt;/blockquote>
&lt;h2 id="暂停和恢复动态分辨率">暂停和恢复动态分辨率
&lt;/h2>&lt;p>有时你可能需要为项目启用动态分辨率，但你又不想对主大厅之类的区域启用。动态分辨率可以随运作模式暂停和恢复。下列控制台变量可用于设置动态分辨率的运算模式：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.DynamicRes.OperationMode
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>禁用（默认）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>根据GameUserSettings中使用的设置启用。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>无论GameUserSettings中的设置如何都会启用。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>下表概括了当启用或禁用特定运算模式时可用的不同状态，以及GameUserSettings所受的影响：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Game User Settings = False&lt;/th>
&lt;th>&lt;/th>
&lt;th>Game User Settings = True&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>暂停&lt;/td>
&lt;td>不暂停&lt;/td>
&lt;td>暂停&lt;/td>
&lt;td>不暂停&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OperationMode=0&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OperationMode=1&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OperationMode=2&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 C++ 中，你可以使用下列函数控制和检查动态分辨率的状态：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>操作&lt;/th>
&lt;th>C++函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>暂停&lt;/td>
&lt;td>GEngine-&amp;gt;PauseDynamicResolution();&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>恢复&lt;/td>
&lt;td>GEngine-&amp;gt;ResumeDynamicResolution();&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>检查状态（禁用/启用或暂停）&lt;/td>
&lt;td>GEngine-&amp;gt;GetDynamicResolutionStatus();&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="动态分辨率巡航">动态分辨率巡航
&lt;/h1>&lt;p>在虚幻引擎中，动态分辨率功能的实现与以前其他引擎中同类功能有所不同，因为我们允许分辨率根据需要在一个给定的范围内变化，而不是限制为单一的分辨率（1080p、900p、720p）。在这张示例图中，此模型演示了控制台变量所控制的对象。它演示了当一切都运行顺利、没有超过给定帧的预算时，动态分辨率是如何在给定范围（3）中自动调节的。可以把这个范围想象为飞机的巡航高度，飞机在这一高度范围可以自由机动，以实现到达目的地的理想速度。和飞机一样，分辨率也可以根据需要上下调节，从而在分辨率和充足的性能之间保持良好的平衡。&lt;/p>
&lt;blockquote>
&lt;p>这个模型是用于演示的，没有考虑在给定场景中发生的所有情况。例如，它没有体现GPU不与CPU同步会是什么情况，甚至也没有体现启发法正确估算出分辨率应该变化多少的情况。它的目的是清晰地演示&amp;quot;理想&amp;quot;情况，从而展现动态分辨率控制态变量的运算方式。&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/framegpugraph.png"
width="1694"
height="826"
srcset="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/framegpugraph_hu_c4adeb21008ffde8.png 480w, https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/framegpugraph_hu_248532d90ebc0f3c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="205"
data-flex-basis="492px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参考号&lt;/th>
&lt;th>控制台变量&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>r.DynamicRes.FrameTimeBudget&lt;/td>
&lt;td>以毫秒（ms）计的帧时间预算。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>r.DynamicRes.TargetedGPUHeadRoom&lt;/td>
&lt;td>在超出预算前可供GPU增加的余量（按帧预算的百分比计）。这很可能要取决于发布平台或根据启用的渲染功能而定。例如，动态模糊需要另外留出成本余量用于摄像机的快速旋转运动。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>r.DynamicRes.ChangePercentageThreshold&lt;/td>
&lt;td>为了实际调整分配大小，在屏幕百分比中需要的最小变化。如果不想经常在非常相近的分辨率大小之间变换，可以利用此变量。如果它的数值过小，分辨率最终可能还是会经常改变，而如果它过大，可能会增加超出GPU预算的风险。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>r.DynamicRes.MinResolutionChangePeriod&lt;/td>
&lt;td>在允许进行任何分辨率更改之前，必须达到的最小帧数。此命令有多种用途。这包括提高启发法在给定主要屏幕百分比下排除测量噪点模拟GPU消耗的可靠性，避免可能在逐帧偏移抖动之间发生的时序上采样的输入样本偏移干扰，以及更改可能造成抗锯齿发散的分辨率。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果你的瓶颈是在CPU而非GPU，还可以使用下列控制台变量调节用于动态分辨率的启发法历史记录和要使用的屏幕百分比：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制台变量&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.DynamicRes.HistorySize&lt;/td>
&lt;td>启发法帧历史记录中的帧数。如果历史记录过短，可能包含过多噪点，影响可靠性；而如果历史记录过长，调节延迟可能会非常严重。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.DynamicRes.CPUBoundScreenPercentage&lt;/td>
&lt;td>当你遇到CPU瓶颈时应该瞄准的主要屏幕百分比。如果平台上的CPU和GPU共享相同的内存带宽，可以用它设置较低的屏幕百分比来降低分辨率。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="超预算应急">超预算应急
&lt;/h2>&lt;p>如果你发现动态分辨率会非常迅速地超出预算，例如在镜头切换时或者成本高昂的视觉效果出现时，那就说明使用的启发法实际上无法预测这种情况何时会发生。在这类情况确实发生时，可以使用某种&amp;quot;应急&amp;quot;按钮快速降低分辨率，从而减少超出预算的帧数。如果启发法发现有N（一定数量）个连续帧的可用GPU时间超出预算，它将会立即调整分辨率来应对这些超预算时间。它还会自动执行历史记录重置，使得先前成本较低的帧时间不会影响启发法对成本较高的帧的判断。&lt;/p>
&lt;p>请使用下列控制台命令来控制在启用&amp;quot;应急&amp;quot;开关降低分辨率之前可以出现的超GPU预算的连续帧数：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.DynamicRes.MaxConsecutiveOverbudgetGPUFrameCount
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在此图中，画面中突然发生跳跃，因此有两个以上的连续帧超过了设定的33.3毫秒的预算。系统激活了应急开关来快速降低分辨率，使得后续帧不再超出预算。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/overbudgetpanicgraph.png"
width="1019"
height="879"
srcset="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/overbudgetpanicgraph_hu_88c9a253e65af047.png 480w, https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/overbudgetpanicgraph_hu_9710b4667aba4be0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="278px"
>&lt;/p>
&lt;ol>
&lt;li>超出预算的最大连续GPU帧数。&lt;/li>
&lt;li>从检测到GPU导致分辨率变化为止未与渲染线程同步的帧延迟。&lt;/li>
&lt;li>发生紧急情况检测，引发帧率下降。&lt;/li>
&lt;li>一定数量的帧发生分辨率更改。&lt;/li>
&lt;/ol>
&lt;h1 id="支持动态分辨率的平台">支持动态分辨率的平台
&lt;/h1>&lt;p>支持以下平台&lt;/p>
&lt;ul>
&lt;li>微软的Xbox One、Xbox Series S和Xbox Series X&lt;/li>
&lt;li>PlayStation 4 和 PlayStation 5 （不包括PSVR）&lt;/li>
&lt;li>Nintendo Switch&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>针对不在此白名单中的平台启用动态分辨率支持是很危险的，可能造成意外后果。这类后果包括GPU时间错误，这可能使分辨率不必要地下降，或者分辨率提高过多，发生丢帧。这最终可能毁掉Gameplay体验。默认情况下，引擎不允许你在此白名单中的平台上使用动态分辨率。&lt;/p>&lt;/blockquote></description></item><item><title>泛光</title><link>https://zentia.github.io/p/%E6%B3%9B%E5%85%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B3%9B%E5%85%89/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/randg_herobanner.png" alt="Featured image of post 泛光" />&lt;p>泛光（Bloom）是一种真实世界中的光现象，通过它能够以较为适度的渲染性能成本极大地渲染图像的真实感。用肉眼观察黑暗背景下非常明亮的物体时会看到泛光效果。亮度更高的物体还会造成其他效果（条纹、镜头光斑），但这些效果不在经典的泛光效果范畴内。我们的显示器（电视、TFT屏等）通常不支持HDR（高动态范围），因此实际上无法渲染太亮的物体。于是我们模拟了当光线射到胶片（胶片次表面散射）或摄像机（乳白色玻璃滤光片）时眼睛中出现的效果（视网膜的次表面散射）。这种效果不一定符合实际清空，但它可以帮助表现对象的相对亮度，或者给屏幕上显示的LDR（地动态范围）图像添加真实感。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom.png"
width="1174"
height="523"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_hu_a99ee83ad225010.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_hu_93b1c8b33470498.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>&lt;/p>
&lt;p>泛光可以用一个高斯模糊来实现。为了提高质量，我们将多个不同半径的高斯模糊组合起来。为了获得更好的性能，我们在大大降低的分辨率下 进行很宽范围的模糊。在UE 3中，高斯模糊的分辨率为1/4、1/8和1/16。而现在我们可以使用多种模糊，分辨率从1/2（Blur1）到1/32（Blur5）。&lt;/p>
&lt;p>通过改变模糊效果的组合方式，我们可以进行更多的控制，取得更高的质量。为了获得最佳的性能，应该使用高分辨率模糊（小值）来实现较窄的模糊，而主要使用低分辨率模糊 （大值）实现较宽的模糊。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>强度（Intensity）&lt;/td>
&lt;td>线性调节整个泛光效果的颜色。可用于：随着时间的推移淡入或淡出，变暗。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>阈值（Threshold）&lt;/td>
&lt;td>定义了单一颜色需要多少亮度单位才能产生泛光。除了阈值之外，还有一个线性部分（1个单位宽度），其中的颜色仅部分地影响泛光。如果希望场景中的所有颜色都参与泛光效果，需要使用数值-1。可用于：对某些不真实的HDR内容、梦序进行调整。详见下方示例&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>着色&lt;/td>
&lt;td>修改每个泛光的亮度和颜色。如果你使用黑色，尽管不会使得渲染速度加快，但也是可以的。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="强度">强度
&lt;/h2>&lt;p>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_0_small.png"
width="368"
height="164"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_0_small_hu_fbc3c0399d45e259.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_0_small_hu_12e802d250a67252.png 1024w"
loading="lazy"
alt="0.0"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>
&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_1_small.png"
width="368"
height="164"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_1_small_hu_f50d0a5f8df30725.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_1_small_hu_114d0fc33ab53539.png 1024w"
loading="lazy"
alt="1.0"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>
&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_5_small.png"
width="370"
height="165"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_5_small_hu_2183bfba471a2559.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_5_small_hu_3dab3d1504bd7aab.png 1024w"
loading="lazy"
alt="5.0"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_tint_1_small.png"
width="220"
height="98"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_tint_1_small_hu_2d89569f7645e8fe.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_tint_1_small_hu_2209f02f1bca9187.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>&lt;/p>
&lt;h1 id="泛光卷积">泛光卷积
&lt;/h1>&lt;p>使用泛光 卷积（Convolution） 效果可以添加自定义泛光内核形状，其纹理能够展现逼真的泛光效果。 它利用内核图像对源图像进行卷积运算，以此来模拟摄像机或人眼中光线的散射和衍射。&lt;/p>
&lt;p>内核表示光学设备对视野中间的单点源的响应。源中的每个像素按照内核图像的指示 将其部分亮度贡献给相邻像素。源像素越亮，生成的泛光越明显。究其根本而言，这种能量守恒散射可以转化为卷积运算公式， 并通过使用快速傅里叶变换（FFT）加速。&lt;/p>
&lt;blockquote>
&lt;p>泛光卷积专门用于游戏内过场动画、离线过场动画，或在高端硬件中使用，但 标准 泛光 可用于大多数游戏应用程序。 就利弊而言，标准泛光在性能方面具有明显优势，但它并不稳妥（它会导致图像整体变得更亮）， 并且无法赶上泛光卷积的视觉复杂性。&lt;/p>&lt;/blockquote>
&lt;p>要启用&amp;quot;泛光卷积（Bloom Convolution）&amp;quot;，请在&amp;quot;后期处理体积（Post Process Volume）&amp;ldquo;的 镜头（Lens） 部分中，使用 方法（Method） 旁边的选择框选择 卷积（Convolution）。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/convolution-bloom-settings.png"
width="482"
height="341"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/convolution-bloom-settings_hu_a7b88a9c59d0a6ed.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/convolution-bloom-settings_hu_626e115a966ebd4.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="339px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>卷积内核（Convolution Kernel）&lt;/td>
&lt;td>用于选择定义内核的纹理。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>卷积缩放（Convolution Scale）&lt;/td>
&lt;td>表示以视口为单位的卷积内核图像的相对大小。默认值为1。主要用于减少泛光的大小。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="内核图像最佳实践">内核图像最佳实践
&lt;/h2>&lt;p>基于图像的卷积之所以能产生额外的真实感，是因为它能够使用视觉上很有趣的非对称内核图像。当 创建内核并将其设置用于泛光卷积时，需要注意一些事项。&lt;/p></description></item><item><title>高动态范围显示输出</title><link>https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/ue5_1-rendering-hero-banner-5-0.png" alt="Featured image of post 高动态范围显示输出" />&lt;p>你可以输出到高动态范围（HDR）显示器，以充分利用更高的对比度和更宽的色域等功能！其目标是使显示的图像具有的特性更类似于&amp;quot;现实世界&amp;quot;中所经历的自然光条件。这是转向 学院色彩编码系统（ACES）标准行动的一部分，该标准是一个确保在多种格式和显示器上保持色彩一致性的管线，也是一种确保所用源材质 不会过时 且无需针对其他介质进行调整的方法&lt;/p>
&lt;p>在当前实现下，渲染场景的完整处理通过 ACES Viewing Transform 进行处理。此流程的工作原理是使用&amp;quot;参考场景的&amp;quot;和&amp;quot;参考显示的&amp;quot;图像。&lt;/p>
&lt;ul>
&lt;li>参考场景的 图像保有源材质的原始 线性光照 数值，不限制曝光范围。&lt;/li>
&lt;li>参考显示的 图像是最终的图像，将变为所用显示的色彩空间。&lt;/li>
&lt;/ul>
&lt;p>使用此流程后，初始源文件用于不同显示时便无需每次进行较色编辑。相反，输出的显示将映射到正确的色彩空间。&lt;/p>
&lt;p>ACES Viewing Transform在查看流程中将按以下顺序进行：&lt;/p>
&lt;ul>
&lt;li>Look Modification Transform (LMT) - 这部分抓取应用了创意&amp;quot;外观&amp;quot;（颜色分级和矫正）的ACES颜色编码图像，输出由ACES和Reference Rendering Transform（RRT）及Output Device Transform（ODT）渲染的图像。&lt;/li>
&lt;li>Reference Rendering Transform (RRT) - 之后，这部分抓取参考场景的颜色值，将它们转换为参考显示。 在此流程中，它使渲染图像不再依赖于特定显示器，反而能保证它输出到特定显示器时拥有正确而宽泛的色域和动态范围（尚未创建的图像同样如此）。&lt;/li>
&lt;li>Output Device Transform (ODT) - 最后，这部分抓取RRT的HDR数据输出，将其与它们能够显示的不同设备和色彩空间进行比对。 因此，每个目标需要将其自身的ODT与Rec709、Rec2020、DCI-P3等进行比对。&lt;/li>
&lt;/ul>
&lt;h1 id="启用hdr输出">启用HDR输出
&lt;/h1>&lt;p>开启控制台变量或使用蓝图中的 GameUserSettings 节点即可启用运行时的HDR输出。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/ue5_1-high-dynamic-range-display-game-user-settings.png"
width="1065"
height="267"
srcset="https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/ue5_1-high-dynamic-range-display-game-user-settings_hu_97a1851f6f77c11c.png 480w, https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/ue5_1-high-dynamic-range-display-game-user-settings_hu_6fa3a4726d26c1b1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="398"
data-flex-basis="957px"
>&lt;/p>
&lt;p>Game User Settings 控制将自动锁定当前可用的最接近输出设备，并相应设置全部标记。 另外，还可使用以下控制台变量启用并对HDR设备和色域输出所需的可用选项进行修改。&lt;/p>
&lt;h1 id="hdr-中的低动态范围ldrui支持">HDR 中的低动态范围（LDR）UI支持
&lt;/h1>&lt;p>启用HDR输出后，用户界面（UI）可能出现显示问题。 因此虚幻引擎新增了实验性的LDR UI合成支持。 它将尝试尽量匹配LDR的外观。 推荐对UI稍微进行增强，以免和鲜艳主场景相比之下显得黯淡。&lt;/p></description></item><item><title>基于物理的材质</title><link>https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/ue5-hero.png" alt="Featured image of post 基于物理的材质" />&lt;h1 id="基于物理是什么意思">基于物理是什么意思？
&lt;/h1>&lt;p>基于物理的渲染（Physically based rendering） (PBR)意味着表面接近光线在真实世界的表现方式，而不是我们直观以为的应有方式。 相较于完全依赖美术师直觉来设置参数的着色工作流程，遵守PBR原则的材质更准确，并且通常看起来更自然。&lt;/p>
&lt;p>基于物理的材质在所有光照环境中都能有同等程度的良好表现。 此外，材质值的复杂程度和相互依赖程度可以降低，这样材质创建工作流程对于用户更加友好。 这些优点甚至适用于非真实感渲染，正如Pixar [4]和Disney [3]的电影中所展现的那样。&lt;/p>
&lt;blockquote>
&lt;p>要对虚幻引擎的基于物理的材质和着色模型进行一番深入的技术考察，请参阅此SIGGRAPH演示2。&lt;/p>&lt;/blockquote>
&lt;h1 id="pbr材质属性">PBR材质属性
&lt;/h1>&lt;p>这些是与虚幻材质的基于物理的方面直接相关的材质属性。&lt;/p>
&lt;ul>
&lt;li>基础颜色&lt;/li>
&lt;li>粗糙度&lt;/li>
&lt;li>金属感&lt;/li>
&lt;li>高光度&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>所有这些输入都设计为接受0到1之间的值。对于基础颜色，这意味着RGB值在0到1之间的颜色或纹理取样。&lt;/p>&lt;/blockquote>
&lt;h2 id="基础颜色">基础颜色
&lt;/h2>&lt;p>基础颜色定义了材质的总体颜色。 &amp;ldquo;基础颜色&amp;quot;输入接受 Vector3 (RGB) 值，其中每个通道自动限制在0到1之间。&lt;/p>
&lt;h2 id="粗糙度">粗糙度
&lt;/h2>&lt;p>&amp;ldquo;粗糙度&amp;quot;输入控制了材质表面有多粗糙或光滑。 在材质中，这表现为反射在材质上看起来有多尖锐或模糊。&lt;/p>
&lt;p>粗糙材质会沿比光滑材质更多的方向反射光线，这样产生的是漫反射，有时很细微。光滑表面会更均匀地反射光线，这样产生的是清晰、集中的反射或镜面高光。&lt;/p>
&lt;ul>
&lt;li>粗糙度为0（光滑）会产生镜面反射。&lt;/li>
&lt;li>粗糙度为1（粗糙）会产生漫反射或无光泽的表面。&lt;/li>
&lt;/ul>
&lt;h3 id="映射粗糙度">映射粗糙度
&lt;/h3>&lt;p>粗糙度经常在使用灰阶纹理的对象上映射，以向表面添加物理变体。 粗糙度贴图上的深色区域在材质上看起来像镜子，而浅色区域则比较粗糙，看起来反射度较低。&lt;/p>
&lt;h3 id="粗糙度与高光度">粗糙度与高光度
&lt;/h3>&lt;p>高光度（Specularity） 指的是表面反射的&lt;a class="link" href="https://zh.wikipedia.org/wiki/%E9%8F%A1%E9%9D%A2%E5%8F%8D%E5%B0%84" target="_blank" rel="noopener"
>高光（specular light）&lt;/a>量。 此值是材质类型所固有的，通常默认值0.5是准确的。&amp;ldquo;高光度&amp;quot;输入 不用于反射/高光度贴图 或添加表面变体。 这些应该在&amp;quot;粗糙度&amp;quot;贴图中进行处理。&lt;/p>
&lt;h2 id="金属感">金属感
&lt;/h2>&lt;p>&amp;ldquo;金属感&amp;quot;输入接受0到1之间的值，并定义你的材质是作为金属还是非金属表现。&lt;/p>
&lt;p>在大多数情况下，你应该将&amp;quot;金属感&amp;quot;视为虚幻引擎中的二进制属性。 对于纯表面（例如纯金属、纯岩石、纯塑料，等等），你应该将&amp;quot;金属感&amp;quot;设置为 0或1，而不是中间值。创建被腐蚀、有灰尘或生锈的金属之类的混合表面时，你可能发现你需要0到1之间的某个值。&lt;/p>
&lt;ul>
&lt;li>非金属 的&amp;quot;金属感&amp;quot;值为0。这是默认值。&lt;/li>
&lt;li>金属 的&amp;quot;金属感&amp;quot;值为1。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/metallic.png"
width="720"
height="81"
srcset="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/metallic_hu_b62326da99e0f43e.png 480w, https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/metallic_hu_888982c8fee1cd5.png 1024w"
loading="lazy"
alt="0到1的&amp;#34;金属感&amp;#34;值"
class="gallery-image"
data-flex-grow="888"
data-flex-basis="2133px"
>&lt;/p>
&lt;blockquote>
&lt;p>你可能起初不愿意将材质设置为完全的金属感。除非你有充足理由，否则尽量不要使用小数值。&lt;/p>&lt;/blockquote>
&lt;h3 id="映射金属感">映射金属感
&lt;/h3>&lt;p>相同材质中往往金属和非金属都有。 假设一个金属面板，其中油漆涂层覆盖了部分或全部金属。&lt;/p>
&lt;p>油漆是非金属，因此在油漆覆盖的所有区域中，&amp;ldquo;金属感&amp;quot;值应该为0。 在面板中看得到金属的所有地方，&amp;ldquo;金属感&amp;quot;值应该为1。&lt;/p>
&lt;p>这应该使用传递到&amp;quot;金属感&amp;quot;输入的黑白遮罩进行处理。 油漆没有与金属混合，而是位于其上方。 你的&amp;quot;金属感&amp;quot;贴图不应包含中间灰阶值，只能包含黑色和白色。 你还可以使用材质层实现类似结果。&lt;/p>
&lt;h2 id="高光度">高光度
&lt;/h2>&lt;p>&amp;ldquo;高光度&amp;quot;输入接受0到1之间的值，并控制表面反射多少高光。&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;高光度&amp;quot;值为0表示完全不反射。&lt;/li>
&lt;li>&amp;ldquo;高光度&amp;quot;值为1表示完全反射。&lt;/li>
&lt;/ul>
&lt;p>虚幻引擎使用 默认高光度0.5 ，这表示大约4%的高光度反射。 对于绝大多数材质，此值是准确的。&lt;/p>
&lt;blockquote>
&lt;p>对于漫反射程度很高的材质，你可能倾向于将此值设置为0。别这样做！所有材质多有高光度，请参阅此帖子以了解示例[5]。制作漫反射程度很高的材质的正确方法是使用很高的&amp;quot;粗糙度&amp;quot;值。&lt;/p>&lt;/blockquote>
&lt;h2 id="空腔贴图">空腔贴图
&lt;/h2>&lt;p>修改&amp;quot;高光度&amp;quot;的一个原因是添加微型遮蔽区或小尺度阴影，比如从法线贴图中表示的裂口添加。这些有时被称为空腔。 小尺度的几何体（尤其是仅存在于高精度多边形中并烘焙到法线贴图中的细节）不会被渲染器的实时阴影选取。&lt;/p>
&lt;p>要捕获此阴影，你可以生成空腔贴图，它通常是追踪距离非常短的AO贴图。这会乘以输出之前的最终&amp;quot;基础颜色&amp;rdquo;，并乘以0.5（&amp;ldquo;高光度&amp;quot;默认值）作为&amp;quot;高光度&amp;quot;输出。&lt;/p>
&lt;p>确切地说，就是：基础颜色=空腔旧基础颜色，高光度=空腔0.5。&lt;/p>
&lt;p>在高级用途中，这一步可以用于控制折射率(IOR)。我们发现这对于99%的材质都不是必需的。下面是基于测量的IOR的&amp;quot;高光度&amp;quot;值。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/measured_materials.png"
width="720"
height="437"
srcset="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/measured_materials_hu_3bf4bbac4b7cc802.png 480w, https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/measured_materials_hu_67ab564e3017cf98.png 1024w"
loading="lazy"
alt="测量的材质示例。顶部：木炭、新混凝土、旧沥青。底部：铜、铁、金、铝、银、镍、钛"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p></description></item><item><title>可视性和遮挡剔除参考</title><link>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E5%8F%82%E8%80%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E5%8F%82%E8%80%83/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E5%8F%82%E8%80%83/ue5-hero.png" alt="Featured image of post 可视性和遮挡剔除参考" />&lt;p>本页面包含虚拟纹理系统的要求、设置、控制台命令的相关信息。&lt;/p>
&lt;h1 id="流送虚拟纹理设置">流送虚拟纹理设置
&lt;/h1>&lt;p>以下为用于设置和处理流送虚拟纹理的设置和属性。&lt;/p></description></item><item><title>时序上采样器</title><link>https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/ue5-hero.png" alt="Featured image of post 时序上采样器" />&lt;p>时序上采样器（Temporal Upscalers） 使用来自当前和之前帧的数据来产生高质量的增强结果。 无论是虚幻引擎4的Temporal Anti-Aliasing Upscaling (TAAU)、虚幻引擎5的Temporal Super Resolution，还是诸如NVIDIA的DLSS 2+ Super Resolution、AMD的FSR 2.0+和Intel的XeSS等第三方插件，时序上采样器都在虚幻引擎里以相同方式运作。它们都在同一位置插入后期处理链&amp;ndash;在景深和动态模糊之间。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/8-pipeline-tsr.png"
width="1078"
height="308"
srcset="https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/8-pipeline-tsr_hu_12ff33fc38a98b0d.png 480w, https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/8-pipeline-tsr_hu_909ab58fec84c7ed.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="350"
data-flex-basis="840px"
>&lt;/p>
&lt;p>无论使用哪种时序上采样器，渲染分辨率都是由Screen Percentage，或在支持时同时由Dynamic Resolution来控制。&lt;/p></description></item><item><title>使用查找表（LUT）进行颜色校正</title><link>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/ue5_1-rendering-hero-banner-5-0.png" alt="Featured image of post 使用查找表（LUT）进行颜色校正" />&lt;p>可以利用 查找表（LUT）来实现使用后期处理体积的颜色校正。 不要使用三个一维（1D）查找表，而应该使用一个三维（3D）查找表。 这样可以提供更精细的色彩变换，从而可用于去饱和度之类的用途。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1_hu_ab67779999497148.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1_hu_e289048aa8ff7c11.png 1024w"
loading="lazy"
alt="中性色调LUT"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_sepia.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_sepia_hu_15f4a5f79c4d41a8.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_sepia_hu_1462e5c68f13812e.png 1024w"
loading="lazy"
alt="棕褐色调LUT"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>&lt;/p>
&lt;p>虚幻引擎中使用的一种查找表是16x16x16的中性色调LUT，解压后为256x16的纹理。 这些示例显示了中性色调和棕褐色调的LUT。 如果要应用中性色调LUT，你将不会看到默认场景有任何变化，但是如果使用棕褐色调的LUT，就会看到类似于下图这样的情况：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1.png"
width="1336"
height="923"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_84ebf4216f5e03b7.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_fb114baba6d55fdb.png 1024w"
loading="lazy"
alt="中性色调LUT"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut4.png"
width="1336"
height="923"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut4_hu_36ddbb63ab9b95e3.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut4_hu_660280c302dc0877.png 1024w"
loading="lazy"
alt="棕褐色调LUT"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;h1 id="使用lut纹理">使用LUT纹理
&lt;/h1>&lt;p>要使用LUT，请使用下列属性将LUT纹理分配到要搭配它使用的后期处理体积并调整它的强度。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>颜色分级LUT强度（Color Grading LUT Intensity）&lt;/td>
&lt;td>一种控制颜色校正效果的比例因子。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>颜色分级LUT&lt;/td>
&lt;td>用作颜色校正的查找表的LUT纹理。 详见下方示例&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="颜色分级lut">颜色分级LUT
&lt;/h2>&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_none.png"
width="1311"
height="866"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_none_hu_e65d2b41ad8552a0.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_none_hu_e3f7bdb7873e7b8e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_green.png"
width="1311"
height="866"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_green_hu_12584ece67fbdec0.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_green_hu_48d2eaf1bc33ad38.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_red.png"
width="1311"
height="866"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_red_hu_ac881720ecd7af54.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_red_hu_1e825931915799c3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1_hu_ab67779999497148.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1_hu_e289048aa8ff7c11.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_greenish.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_greenish_hu_9df8746fa4e2af14.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_greenish_hu_bab230f15d2d39a8.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_reddish.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_reddish_hu_78472e19df8ffd97.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_reddish_hu_1ca2d2687a30f999.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>&lt;/p>
&lt;h1 id="创建自己的lut纹理">创建自己的LUT纹理
&lt;/h1>&lt;p>要创建你自己的LUT纹理，首先需要一个能够对捕获的图像进行颜色调整的图像编辑应用程序（例如Photoshop或GIMP）。 在这个演示中， 我们将使用在Epic Games启动程序中的 学习（Learn） 选项卡中提供的 Sun Temple 项目，并选择Photoshop作为LUT图像编辑应用程序。 在这个示例中使用的某些术语可能是 Photoshop特有的。&lt;/p>
&lt;ol>
&lt;li>首先对你也要应用颜色校正的场景截取至少一张有代表性的屏幕截图。 可以使用编辑器中提供的 截图工具来截取场景的高分辨率图像。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1.png"
width="1336"
height="923"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_84ebf4216f5e03b7.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_fb114baba6d55fdb.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;ol start="2">
&lt;li>在Photoshop中打开该屏幕截图，然后从右侧图层（Layers）面板上方的调整（Adjustments）选项卡添加你自己的 调整 图层。 在这里可以找到许多不同的图标，分别代表可以对图像执行的各种更改类型，例如亮度和对比度、色调、饱和度，等等。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut2.png"
width="1800"
height="975"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut2_hu_2ddc9bbb20d91632.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut2_hu_262f3bb5571fc7ad.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;ol start="3">
&lt;li>在 调整（Adjustments） 面板中，单击任何图标以向图层（Layers）面板添加图层。 可以使用这些图层对最终图像作特定的颜色校正。 在此示例中， 已经添加和调整了 Vibrance 和 亮度/对比度（Brightness/Contrasts）。 将这些图层添加到图层（Layers）面板之后，从列表中选择它们以公开它们的属性，如果看不到属性， 可以右键单击并选择 编辑调整（Edit Adjustment） 来公开它们。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3.png"
width="734"
height="479"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3_hu_c3ebae96aecae360.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3_hu_87569d5eaa72a3a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="153"
data-flex-basis="367px"
>&lt;/p>
&lt;ol start="4">
&lt;li>你进行的任何调整都可以显示在视口中。 请调整调整图层的属性，直到获得想要的颜色校正效果为止。 在下面的示例中，已经调整了 Vibrance和亮度/对比度（Brightness/Contrasts）的调整图层属性，使屏幕截图的颜色饱和度和清晰度更高，更有视觉吸引力。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1.png"
width="1336"
height="923"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_84ebf4216f5e03b7.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_fb114baba6d55fdb.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3.png"
width="734"
height="479"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3_hu_c3ebae96aecae360.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3_hu_87569d5eaa72a3a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="153"
data-flex-basis="367px"
>&lt;/p>
&lt;ol start="5">
&lt;li>既然你已经通过调整图层实现了所需的视觉效果，那就需要另外打开 中性色调LUT 的一个副本。 可以将为屏幕截图创建的调整图层拖动到该中性色调LUT上。打开带有调整图层的屏幕截图和中性色调LUT后，将调整图层从屏幕截图的图层（Layers）面板 拖放 到中性色调LUT图像上。 此时你应该会看到它们填充在LUT的图层（Layers）面板中。&lt;/li>
&lt;li>现在，导航到 File（文件） &amp;gt; Save As（另存为），给经过颜色校正的LUT提供一个名称。&lt;/li>
&lt;li>将经过颜色校正的LUT导入编辑器中，可以将其 拖放 到内容浏览器（Content Browser），也可以使用内容浏览器（Content Browser）中提供的 Import（导入） 按钮。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut5.png"
width="868"
height="393"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut5_hu_3f1c68d5b8335fe4.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut5_hu_2109ff0dc59f6f9a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="530px"
>&lt;/p>
&lt;ol start="8">
&lt;li>要在后期处理体积中使用LUT获得最佳效果，在纹理编辑器（Texture Editor）中打开LUT图像，设置下列属性：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut6.png"
width="461"
height="135"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut6_hu_d24a7d2be6a685fb.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut6_hu_ea4f43a92be780f0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="341"
data-flex-basis="819px"
>&lt;/p>
&lt;ol start="9">
&lt;li>接下来，在后期处理体积中，使用 细节（Details） 面板，在 颜色分级（Color Grading） &amp;gt; 全局（Global） 部分，启用 颜色分级LUT（Color Grading LUT） 并应用您的LUT。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut8.png"
width="453"
height="408"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut8_hu_42921edce6a5ae19.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut8_hu_fb8b09784e480436.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="266px"
>&lt;/p></description></item><item><title>纹理流送配置</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E9%85%8D%E7%BD%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E9%85%8D%E7%BD%AE/ue5-hero.png" alt="Featured image of post 纹理流送配置" />&lt;p>在检查构建的纹理流送的准确性之后，您可能需要调整纹理流送的行为和优先级。 下面的参数可以通过配置文件进行调整，而其中的大多数参数也可以在运行时从控制台窗口进行更新。&lt;/p>
&lt;p>|命令|说明|
|r.TextureStreaming|此命令用于启用或禁用纹理流送器。当纹理流送器被禁用后，所有纹理mip都将被完全加载到内存中，即使在纹理从来没有被用于渲染的情况下也是如此。如果需要，您可以在运行时切换此选项。|
|r.Streaming.PoolSize|引擎中纹理可用的池大小(MB)。这个池包含UI纹理、NeverStream纹理、立方体贴图和流送纹理。在某些平台上，这个池还可以保存非纹理资源，例如GPU粒子缓冲区和顶点缓冲区。设置为0时，池的大小将不受限制。|
|r.Streaming.UseFixedPoolSize|当使用非零值时，可以在运行时更改纹理池大小。|
|r.Streaming.FramesForFullUpdate|纹理流送器的每次完整更新之间的帧数。每次更新都会重新计算每个纹理所需的分辨率，并生成mip加载或卸载请求。较高的值会降低纹理流送器CPU使用率，而较低的值会提高其反应能力。|
|r.Streaming.UseNewMetrics|仅用于兼容性。当设置为假时，纹理流送器将按照4.12版本继续进行处理。|&lt;/p></description></item><item><title>移动平台景深方法</title><link>https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/randg_herobanner.png" alt="Featured image of post 移动平台景深方法" />&lt;h1 id="高斯">高斯
&lt;/h1>&lt;blockquote>
&lt;p>已移除高斯景深与 延迟渲染器（Deferred Renderer） 和 桌面前向渲染器（Desktop Forward Renderer） 的配合使用，该景深仅支持移动平台。如需在桌面计算机上在编辑器内工作时使用此高斯景深，请使用移动预览器启用其中一个移动平台预览器。&lt;/p>&lt;/blockquote>
&lt;p>高斯 景深方法使用标准的&lt;a class="link" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A" target="_blank" rel="noopener"
>高斯模糊&lt;/a>（也叫高斯平滑）函数对场景进行模糊处理。高斯DOF使用固定大小的高斯模糊核对前景和背景进行模糊处理，在移动设备等低端硬件上它的速度非常快。在非常注重性能的场合，它可以在降低开销的情况下保持高性能。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_0.png"
width="1415"
height="796"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_0_hu_4fecfe220d92d046.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_0_hu_e1f7c743d28f242f.png 1024w"
loading="lazy"
alt="无景深"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>
&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_1.png"
width="1415"
height="796"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_1_hu_5f95c64f3d699239.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_1_hu_1aec8e03adb98eef.png 1024w"
loading="lazy"
alt="高斯景深"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;h1 id="查看景深">查看景深
&lt;/h1>&lt;p>可以使用关卡视口中的 景深图层（Depth of Field layers） 显示标志来使包括过渡区在内的图层可视化，该显示标志位于 显示（Show） &amp;gt; 可视化（Visualize） 下。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_2.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_2_hu_7dd9e637e0c3bf70.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_2_hu_65d4db5bdb216334.png 1024w"
loading="lazy"
alt="最终场景"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>
&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_3.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_3_hu_2ed0772d4a7b30bb.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_3_hu_30a6a8862b3a15a6.png 1024w"
loading="lazy"
alt="景深查看"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;h1 id="对焦距离focal-distance">对焦距离（Focal Distance）
&lt;/h1>&lt;p>对焦距离（Focal Distance） 表示对焦区域和捕捉的视角。焦距越长，景深越浅，对焦区域外的对象越模糊；焦距越短，景深越大，聚焦越准确而且失焦的对象越少。光圈数值可以保持不变，更改透镜尺寸将调整景深效果的深浅。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_5.png"
width="2500"
height="1946"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_5_hu_dc9299fc1fcae59d.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_5_hu_64bc36050e0c1c0d.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="128"
data-flex-basis="308px"
>&lt;/p>
&lt;p>设置好 对焦距离（Focal Distance） 和 对焦区域（Focal Region） 之后，就可以使用 近过渡（Near Transition） 和 远过渡（Far Transition） 来调整对焦区域和完全模糊的场景之间的距离。另外，你甚至还可以调整 近景模糊尺寸（Near Blur Size） 和 远景模糊尺寸（Far Blur Size） 来进一步对高斯景深的外观进行微调。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_6.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_6_hu_4abb0c0ce2ea3f61.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_6_hu_b0749e0bddcf6ff.png 1024w"
loading="lazy"
alt="为得到良好的景深效果，对近/远过渡和模糊尺寸的数值进行了调整之后的高斯景深。"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;p>在本示例中，为了实现近景和远景区域的柔和景深效果，我们设置了以下数值。&lt;/p>
&lt;ul>
&lt;li>对焦距离（Focal Distance）： 215&lt;/li>
&lt;li>影调范围（Scale）： 2500&lt;/li>
&lt;li>近过渡（Near Transition）： 500&lt;/li>
&lt;li>远过渡（Far Transition）： 400&lt;/li>
&lt;li>近景模糊尺寸（Near Blur Size）： 2.0&lt;/li>
&lt;li>远景模糊尺寸（Far Blur Size）： 2.5&lt;/li>
&lt;/ul>
&lt;h1 id="可用设置">可用设置
&lt;/h1>&lt;p>高斯景深的设置和属性可以在后期处理体积的 细节 面板中找到，位于 移动景深（Mobile Depth of Field） 的 镜头（Lens） 分类中。&lt;/p></description></item><item><title>预计算可视性体积</title><link>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ue5-hero.png" alt="Featured image of post 预计算可视性体积" />&lt;p>像其他剔除方法一样，预计算可视性体积用于实现中小型场景的性能优化，通常用于因为硬件问题而使动态遮挡剔除受到限制的移动平台。预计算可视性体积根据玩家或摄像机的位置，将Actor位置的可视性状态存储在场景中。因此，预计算可视性对于主要为静态点亮的环境项目、玩家运动受限和某些2D游戏区域最有用。&lt;/p>
&lt;p>在照明构建期间，会在阴影投射几何体上方生成可视性单元格。Actor可视性从每个单元格位置存储。由于预计算可视性是在线下生成的，因此你省去的是通常用于硬件遮挡查询的渲染线程时间，但代价是会增加运行时内存和照明构建时间。基于这一点，建议仅在玩家或摄像机可访问区域放置体积来保持可视性剔除。&lt;/p>
&lt;h1 id="设置和用法">设置和用法
&lt;/h1>&lt;p>首先，需要为关卡启用预计算可视性。方法是打开世界场景设置（World Settings）并找到预计算可视性（Precomputed Visibility）部分。找到后，启用预计算可视性（Precomputed Visibility）旁边的复选框。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis.png"
width="501"
height="243"
srcset="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_ff7454136b0cf587.png 480w, https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_fd5ffa0c6d38ac85.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="494px"
>&lt;/p>
&lt;p>从模式（Modes）面板中，将预计算可视性&lt;/p></description></item><item><title>预计算可视性体积</title><link>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ue5-hero.png" alt="Featured image of post 预计算可视性体积" />&lt;p>像其他剔除方法一样，预计算可视性体积用于实现中小型场景的性能优化，通常用于因为硬件问题而使动态遮挡剔除受到限制的移动平台。预计算可视性体积根据玩家或摄像机的位置，将Actor位置的可视性状态存储在场景中。因此，预计算可视性对于主要为静态点亮的环境项目、玩家运动受限和某些2D游戏区域最有用。&lt;/p>
&lt;p>在照明构建期间，会在阴影投射几何体上方生成可视性单元格。Actor可视性从每个单元格位置存储。由于预计算可视性是在线下生成的，因此你省去的是通常用于硬件遮挡查询的渲染线程时间，但代价是会增加运行时内存和照明构建时间。基于这一点，建议仅在玩家或摄像机可访问区域放置体积来保持可视性剔除。&lt;/p>
&lt;h1 id="设置和用法">设置和用法
&lt;/h1>&lt;p>首先，需要为关卡启用预计算可视性。方法是打开世界场景设置（World Settings）并找到预计算可视性（Precomputed Visibility）部分。找到后，启用预计算可视性（Precomputed Visibility）旁边的复选框。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis.png"
width="501"
height="243"
srcset="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_ff7454136b0cf587.png 480w, https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_fd5ffa0c6d38ac85.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="494px"
>&lt;/p>
&lt;p>从模式（Modes）面板中，将预计算可视性&lt;/p></description></item><item><title>支持的纹理格式和设置</title><link>https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/ue5-hero.png" alt="Featured image of post 支持的纹理格式和设置" />&lt;p>在任何数字项目内存占用比例中，最大的一个内存占用来源是所用的纹理大小和数量。幸运的是，虚幻引擎 拥有非常可靠的系统，能够以非破坏性方式减小所有项目纹理的纹理大小。在以下页面中，我们将介绍这些系统，以及如何使用它们来降低项目纹理内存要求。&lt;/p>
&lt;h1 id="纹理分辨率">纹理分辨率
&lt;/h1>&lt;p>虚幻引擎支持1x1到8192x8192的纹理分辨率，只需要对.INI文件进行少许修改。最新的DirectX视频适配器和游戏主机支持1x1到2048x2048的各种纹理分辨率，最高可达8192x8192。特定硬件设备支持的最高纹理分辨率因制造商、型号和可用纹理内存而异。虚幻引擎4中有一些功能和设置，用于管理针对各种区域渲染的纹理分辨率，如场景几何结构或用户界面。&lt;/p>
&lt;h1 id="引擎纹理分辨率限制">引擎纹理分辨率限制
&lt;/h1>&lt;p>虚幻引擎4默认将最大纹理mip数量限制为14，这样有效地将最大渲染纹理限制为8192（1x1到8192x8192为14个mip）。&lt;/p>
&lt;p>这有一种副作用，即导入的8192纹理将仅渲染4096中的mip1。恒定值MAX_TEXTURE_MIP_COUNT在引擎源文件中默认为13，可以修改为值14以支持8192纹理渲染。该恒定值在以下源文件中定义（截至QAMar09，确保在其他QA版本上验证）。&lt;/p>
&lt;p>从发布UE 4.8开始，您现在可以修改项目以使用高达8192的大小，而不必修改C++代码，只需在项目的 BaseDeviceProfiles.ini 文件中添加以下文本并将 MaxLODsize 设置为 8192 即可&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[/Script/Engine.TextureLODSettings]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">TextureLODGroup_World=(MinLODSize=1,MaxLODSize=8192,LODBias=0,MinMagFilter=aniso,MipFilter=point)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>添加了想要增加其大小的分段后，保存文件并重新启动编辑器。编辑器重新启动后，以8192大小导入的任何纹理现在应该在LOD 1显示大小8192，而不是限制在最大值4096以内。在以下示例图像中，我们修改了UE 4.8项目中的BaseDeviceProfiles.ini文件，以允许使用大小高达8192的纹理。在UE4中加载纹理Texture_8k_Test时，我们可以看到导入和显示的纹理大小均为8192。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/texturelod_8k.png"
width="1391"
height="604"
srcset="https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/texturelod_8k_hu_f226750a3f6518e9.png 480w, https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/texturelod_8k_hu_87bed8015e6dc264.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="230"
data-flex-basis="552px"
>&lt;/p>
&lt;h1 id="压缩的纹理内存要求">压缩的纹理内存要求
&lt;/h1>&lt;p>DXT使用有损压缩，通过调色板颜色和插值颜色将像素压缩在4x4的块中。这样会产生8:1 DXT1和4:1 DXT5恒定压缩文件大小。由于特定平台和硬件的视频内存和纹理池资源是固定的，因此纹理分辨率和资源使用必须达到平衡。下表列出了各种常见分辨率和完全mip下，DXT1和DXT5的纹理内存要求（1x1到完全原生mip0）。请注意，内存要求几乎是纹理分辨率比例的倍数不变，DXT5纹理对内存的占用几乎是DXT1的两倍。&lt;/p>
&lt;p>由于分辨率与压缩的比值是常量，为了计算本文未列出的纹理的内存要求，只需乘以分辨率比例即可。例如，1024x512纹理的内存要求是1024x1024纹理的一半。&lt;/p>
&lt;p>下表数据是根据使用箱式过滤器mip生成和DirectX纹理压缩，由ATI的Compressonator创建的纹理编译的。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>分辨率&lt;/th>
&lt;th>来自1x1的总Mip&lt;/th>
&lt;th>DXT1&lt;/th>
&lt;th>DXT5&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>16x16&lt;/td>
&lt;td>5个mip&lt;/td>
&lt;td>312字节&lt;/td>
&lt;td>496字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8192x8192&lt;/td>
&lt;td>14个mip&lt;/td>
&lt;td>42.6MB（44,739,384字节）&lt;/td>
&lt;td>85.3MB（89,478,640字节）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="引擎配置texturegroup属性">引擎配置TextureGroup属性
&lt;/h1>&lt;p>特定游戏的TextureGroup支持的最低和最高LOD（mip）在多个引擎配置文件中定义。
源配置设置文件组位于&lt;code>[虚幻引擎4安装位置]\Engine\Config\BaseDeviceProfiles.ini&lt;/code> 文件的[/Scripts/Engine.TextureLODSettings]分段中。&lt;/p>
&lt;p>为开发游戏，[your_game]\Config\DefaultDeviceProfiles.ini 文件还在 Engine\Config\ 文件夹中包含一组镜像基础文件，这应当是通常根据游戏特定设置进行修改的副本。&lt;/p>
&lt;p>需要注意的是，虚幻编辑器和游戏中拥有一组独立的TextureGroup条目。这两组分别位于配置文件的[SystemSettingsEditor]和[SystemSettings]分段中。&lt;/p>
&lt;p>DefaultDeviceProfiles.ini 文件中的TextureLODGroup设置条目类与此类似。请注意，较早QA版本可能不包含各个设置的MinMagFilter和MipFilter属性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[/Script/Engine.TextureLODSettings]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; 请注意，该分段中的任何项目会影响所有平台！！！
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@TextureLODGroups=Group
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">TextureLODGroups=(Group=TEXTUREGROUP_World,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_WorldNormalMap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_WorldSpecular,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Character,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_CharacterNormalMap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_CharacterSpecular,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Weapon,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_WeaponNormalMap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_WeaponSpecular,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Vehicle,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_VehicleNormalMap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_VehicleSpecular,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Cinematic,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Effects,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=linear,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_EffectsNotFiltered,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Skybox,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_UI,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Lightmap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Shadowmap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,NumStreamedMips=3,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_RenderTarget,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_MobileFlattened,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Terrain_Heightmap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Terrain_Weightmap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Bokeh,MinLODSize=1,MaxLODSize=256,LODBias=0,MinMagFilter=linear,MipFilter=linear,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Pixels2D,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=point,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="pc-appcompat桶">PC AppCompat桶
&lt;/h1>&lt;p>AppCompat用于根据目标和启动时收集的经验证据来覆盖各种SystemSettings。启用应用兼容性（仅限PC）时，系统衡量机器能力，然后使用五个&amp;quot;桶&amp;quot;中的其中一个桶的预设值来覆盖Engine.ini值。请参阅Engine\Config\文件夹中的BaseCompat.ini以了解相关用法示例。&lt;/p>
&lt;p>AppCompat应该仅在首次运行游戏（而不是编辑器）时检查一次。它通过在[game]Engine.ini中检查是否存在[AppCompat]分段来进行检测，这个分段包含机器先前计算的分数。如果AppCompat已经应用过一次，则不会再次更改以允许用户每次在不进行覆盖的情况下进行自定义更改。&lt;/p>
&lt;p>AppCompat专门针对编辑器禁用，这样机器规格不会影响开发期间在各种机器上查看资源的方式。因此，SystemSettings和SystemSettingsEditor才需要区分开来。&lt;/p>
&lt;p>您可以有效地禁用AppCompat，方法是为游戏提供空的DefaultCompat.ini，使其从Engine.ini中的[SystemSettings]初始化所有桶。在此情况下，系统完全按照引入AppCompat之前的状态运行。&lt;/p>
&lt;h1 id="texturegroup属性">TEXTUREGROUP属性
&lt;/h1>&lt;p>每个TextureGroup条目为游戏渲染中使用的特定纹理集定义纹理属性。通过将纹理分组为常用集，可以更好地控制各种游戏纹理资源的纹理内存池使用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MinLODSize&lt;/td>
&lt;td>将渲染的最小mip大小，以像素为单位指定，范围1到8192中的2的幂值，必须小于MaxLODSize。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MaxLODSize&lt;/td>
&lt;td>将渲染的最大mip大小，以像素为单位指定，范围1到8192中的2的幂值，必须大于MinLODSize。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="过滤">过滤
&lt;/h1>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>MinMagFilter&lt;/th>
&lt;th>MipFilter&lt;/th>
&lt;th>过滤类型&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>点&lt;/td>
&lt;td>&lt;/td>
&lt;td>点&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>各向异性&lt;/td>
&lt;td>&lt;/td>
&lt;td>各向异性线性&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="texturegrouplodgroup和lodbias">TextureGroup、LODGroup和LODBias
&lt;/h1>&lt;p>配置ini文件中指定的TextureGroup和LODBias设置以及纹理属性中指定的LODGroup和LODBias设置确定了用于单个纹理的最终纹理mip集。&lt;/p>
&lt;p>[your_game]Engine.ini中的示例TextureGroup条目可能类似于：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Group=TEXTUREGROUP_World,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="纹理属性">纹理属性
&lt;/h1>&lt;p>关于各种纹理属性的含义说明，请参阅纹理属性页面。&lt;/p></description></item><item><title>Nanite虚拟几何体</title><link>https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/</guid><description>&lt;img src="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/ue5-hero.png" alt="Featured image of post Nanite虚拟几何体" />&lt;p>Nanite是虚幻引擎5的虚拟化几何体系统，它采用全新的内部网格体格式和渲染技术来渲染像素级别的细节以及海量对象。它可以智能的仅处理你能感受到的细节。另外，Nanite采用高度压缩的数据格式，并且支持具有自动细节级别的颗粒度流送。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/nanite-in-unreal-engine.png"
width="3840"
height="3174"
srcset="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/nanite-in-unreal-engine_hu_86c148fb16e944c0.png 480w, https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/nanite-in-unreal-engine_hu_f35cbd38f3710ec.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;h1 id="nanite的优势">Nanite的优势
&lt;/h1>&lt;ul>
&lt;li>几何体形状的复杂度提高了数个数量级，三角形和对象的实时渲染数量达到了前所未有的高度&lt;/li>
&lt;li>帧预算不再会因为多边形数量、绘制调用和网格体内存使用情况而受限&lt;/li>
&lt;li>现在可以直接导入电影级品质的美术资源，例如ZBrush雕刻模型和摄影测量扫描数据&lt;/li>
&lt;li>通过高模实现细节，而非将细节烘培到法线贴图纹理&lt;/li>
&lt;li>自动处理细节级别（LOD），不再需要手动设置单个网格体的LOD&lt;/li>
&lt;li>品质损失极少或没有损失，特别是在LOD发生过渡时&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>尽管Nanite带来了前所未有的变革，但在实际使用上，仍会存在一些限制。 例如，在考虑实例总数、单个网格体的三角形数量、材质复杂度、输出分辨率、项目性能等方面时，还是需要根据实际项目内容和硬件水平来仔细衡量。 与此同时，在虚幻引擎未来的版本中，Nanite将不断扩展功能并提升性能。&lt;/p>&lt;/blockquote>
&lt;h1 id="nanite网格体和传统静态网格体的不同之处">Nanite网格体和传统静态网格体的不同之处
&lt;/h1>&lt;p>Nanite网格体是一种启用了Nanite的特殊静态网格体。 Nanite网格体本质上仍是三角形网格体，但对其数据进行了大量细节和压缩处理。 此外，Nanite使用了一种全新系统，能以极高效的方式来渲染这种数据格式。&lt;/p>
&lt;p>要让静态网格体利用Nanite，只需一个标记来启用它即可。 编辑Nanite网格体的内容和传统网格体没太大不同，区别就在于相比使用传统方法渲染的几何体，Nanite能够渲染的三角形和实例要多出数个数量级。 将摄像机移到足够近的位置后，Nanite就会绘制出导入的原始源三角形。&lt;/p>
&lt;p>Nanite网格体支持多重UV和顶点颜色。 材质可以被分配给网格体的不同分段，并且这些材质可以使用不同的着色模型和动态效果（在着色器中完成）。 材质指定可以动态切换，就像其他静态网格体一样。Nanite也无需任何烘焙材质的过程。&lt;/p>
&lt;p>&lt;a class="link" href="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/" target="_blank" rel="noopener"
>虚拟纹理&lt;/a>并非必须与Nanite一起使用，但强烈建议使用虚拟纹理。 虚拟纹理是正交虚幻引擎功能，它与纹理数据的关系类似于Nanite与网格体数据的关系。&lt;/p>
&lt;h1 id="nanite如何工作">Nanite如何工作？
&lt;/h1>&lt;p>Nanite可最大限度地与现有的引擎工作流程无缝集成，可使用前所未有的方法来存储和渲染网格体数据。&lt;/p>
&lt;ul>
&lt;li>导入期间 — 分析网格体，并将其拆分成由三角形组构成的分层群集。&lt;/li>
&lt;li>渲染期间 — 根据摄像机视图以不同LOD随时切换群集，并且可以在不破坏同一对象中相邻群集的情况下完美连接。 数据会根据需求流送，因此只有可见细节才会保存在内存中。 Nanite在自己的渲染通道中运行，该通道完全绕过了传统的绘制调用。 你可以使用可视化模式来检视Nanite管线。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于Nanite需要从磁盘快速流送网格体数据。 建议使用固态硬盘（即SSD）来存储运行时数据。&lt;/p>&lt;/blockquote>
&lt;h1 id="应该将nanite用于哪些类型的网格体">应该将Nanite用于哪些类型的网格体？
&lt;/h1>&lt;p>一般来说，能启用时应该尽量启用Nanite。 启用了Nanite的静态网格体通常可以更快地渲染，占用的内存和磁盘空间会更少。&lt;/p>
&lt;p>具体来说，如果网格体满足以下条件，则尤其适合使用Nanite：&lt;/p>
&lt;ul>
&lt;li>包含很多三角形，或屏幕上的三角形非常小&lt;/li>
&lt;li>场景中有很多实例&lt;/li>
&lt;li>是其他Nanite几何体的主要遮挡物&lt;/li>
&lt;li>使用虚拟阴影贴图投射阴影&lt;/li>
&lt;/ul></description></item><item><title>调试着色器编译过程</title><link>https://zentia.github.io/p/%E8%B0%83%E8%AF%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%B0%83%E8%AF%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%B0%83%E8%AF%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/ue5-hero.png" alt="Featured image of post 调试着色器编译过程" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>引擎中的渲染器模块管理并渲染场景，而场景拥有和每个世界场景相关的可渲染信息。它包括所有绘制规则和着色器的定义。&lt;/p>
&lt;p>RHI 模块是渲染 API 的接口，是图形编程的另一个关键组件。图形编程介绍包含许多可研究的键类、设置和变量，以下子页面包含详细的渲染要点。&lt;/p></description></item><item><title>后期处理效果</title><link>https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/ue5-hero.png" alt="Featured image of post 后期处理效果" />&lt;p>后期处理效果（Post-processing effect）使美术师和设计师能够对影响颜色、色调映射、光照的属性和功能进行组合选择，从而定义场景的整体外观。要访问这些功能，可以将一种称为 后期处理体积（Post Process Volume） 的特殊类型的体积添加到关卡。可以放置多个体积来定义特定区域的外观，也可以将其设置为影响整个场景。&lt;/p>
&lt;h1 id="使用后期处理体积">使用后期处理体积
&lt;/h1>&lt;p>可以使用 放置Actor（Place Actors） 面板将一个 后期处理体积 添加到关卡。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/placing-post-process-volume.png"
width="1410"
height="753"
srcset="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/placing-post-process-volume_hu_708b21c73bcb0dd7.png 480w, https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/placing-post-process-volume_hu_420d14bdcf39a55f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="449px"
>&lt;/p>
&lt;p>放置到关卡中后，可以使用 细节（Details） 面板访问所有可用的属性和功能。你会发现后期处理体积根据它们的功能类型和它们的影响分为多个类目。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/post-process-details-panel.png"
width="1725"
height="944"
srcset="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/post-process-details-panel_hu_ed825485efe8c4e4.png 480w, https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/post-process-details-panel_hu_a47a0532e3f69eb5.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="182"
data-flex-basis="438px"
>&lt;/p>
&lt;p>后期处理体积设置（Post Process Volume Settings） 是这个已放置的体积的特定设置，以及该体积如何与场景以及可能与之重叠的任何其他后期处理体积进行交互。例如，可以选中 无限范围（Infinite Extent） 属性以使此后期处理体积影响场景中的所有位置，或者不选中该属性以仅影响特定区域。当多个体积发生重叠时，你可以控制这些体积如何相互交互以从一个体积混合到另一个体积，这在它们之间具有完全不同的外观时会很有用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>优先级（Priority）&lt;/td>
&lt;td>指定此体积的优先级。在体积重叠的情况下，具有最高优先级的体积会覆盖较低优先级的体积。如果两个或多个重叠的体积具有相同的优先级，则顺序是不明确的。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>混合半径（Blend Radius）&lt;/td>
&lt;td>设置用于混合的体积周围半径（采用世界单位）。例如，当步入一个体积时，体积内的外观可能与体积外的不同。混合半径会在体积周围创建一个过渡区域。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>混合权重（Blend Weight）&lt;/td>
&lt;td>体积属性的影响程度。值为1具有全部效果，而值为0则没有效果。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>已启用（Enabled）&lt;/td>
&lt;td>此体积是否影响后期处理。如果启用，体积的设置将用于混合。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>无限范围（无边界）（Infinite Extent (Unbound)）&lt;/td>
&lt;td>是否考虑体积的边界。如果启用，体积会影响整个场景，而不考虑其体积的边界。未启用时，体积仅在其边界范围内有效。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="后期处理功能和属性">后期处理功能和属性
&lt;/h1>&lt;p>通过选择放置在关卡中的一个后期处理体积来访问该体积的属性和设置。细节（Details） 面板将列出可用类目及其可用属性。&lt;/p>
&lt;blockquote>
&lt;p>即使关卡中没有放置后期处理体积，虚幻引擎也会使用一些默认的后期处理设置。可以在 项目设置（Project Settings） 的 渲染（Rendering）&amp;gt; 默认设置（Default Settings） 分段中找到和配置这些默认的后期处理设置。&lt;/p>
&lt;p>在开始定义场景外观之前，配置这些选项有助于进行关卡编辑以稳定自动曝光或泛光。&lt;/p>&lt;/blockquote>
&lt;h2 id="镜头">镜头
&lt;/h2>&lt;p>镜头（Lens） 类目包含的属性和设置用于模拟摄像机镜头产生的常见真实世界效果。&lt;/p>
&lt;h3 id="景深">景深
&lt;/h3>&lt;p>与真实的摄像机类似，景深（Depth of Field） 根据焦点前后的距离为场景应用模糊效果。该效果用于根据深度将观看者的注意力吸引到镜头中的特定主体上。它还可以增加一种美感，使渲染的图像看起来更像照片或胶片。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_disabled.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_disabled_hu_3989771e759a9fa6.png 480w, https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_disabled_hu_216ec5c823000df5.png 1024w"
loading="lazy"
alt="已禁用景深"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>
&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_enabled.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_enabled_hu_75955f69df7591d6.png 480w, https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_enabled_hu_38507762aa83299c.png 1024w"
loading="lazy"
alt="已启用景深"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;p>有两个可用的景深选项：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/" target="_blank" rel="noopener"
>过场动画景深（Cinematic Depth of Field）&lt;/a>用于桌面平台和游戏主机平台。它可以提供一种胶片视觉效果，其属性与真实摄像机上的属性一致。后期处理体积提供了一些设置，但主要应该使用过场动画摄像机Actor上的摄像机属性来控制景深。&lt;/li>
&lt;/ul></description></item><item><title>纹理流送概述</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/ue5-hero.png" alt="Featured image of post 纹理流送概述" />&lt;p>纹理流送系统或流送器是引擎的一部分，负责增大和减小每个纹理的分辨率。该系统使您可以拥有良好的视觉质量， 同时有效地管理可用内存。这在一定程度上是通过Mip或Mipmap实现的，Mip或Mipmap是为您的纹理分辨率预先计算的图像序列。您可以将它们视为纹理的LOD。 有关Mip的更多信息，您可以在我们的纹理支持和设置页面上加以了解。&lt;/p>
&lt;p>流送器有自己的场景视图，它的更新周期包括&lt;/p>
&lt;ol>
&lt;li>更新场景视图&lt;/li>
&lt;li>计算每个纹理的理想分辨率&lt;/li>
&lt;li>根据流送池大小选择哪个分辨率实际上是可行的&lt;/li>
&lt;li>选择要更新的纹理&lt;/li>
&lt;li>生成加载/卸载请求&lt;/li>
&lt;/ol>
&lt;p>为完成这些任务，流送器使用异步工作线程来降低游戏线程上的工作负载，这样上述只有第一个和最后一个任务需要在游戏更新循环中完成。 场景视图包含每个Primitive组件使用的所有纹理列表以及每个纹理的场景边界和纹素场景大小。根据该信息和给定视点，可以计算出 获得良好的逐像素比率纹素所必需的分辨率。然后还会考虑一些额外的信息，例如该组件实际上是否可以在屏幕上看到。 这最终会定义每个纹理的理想分辨率。然后流送器会计算流送内存池是不是足够大，能容纳这些分辨率。如果不够，流送器会降低所选纹理的计划质量， 一次降低一个mip，直到计划的分辨率降低到预算之下。&lt;/p>
&lt;p>降低mip时处理纹理的顺序由保留时间优先级来定义，请按以下顺序遵循这些规则：&lt;/p>
&lt;ol>
&lt;li>保留地形纹理、强制加载纹理和已经缺失分辨率的纹理&lt;/li>
&lt;li>保留在屏幕上可见的mip&lt;/li>
&lt;li>保留角色纹理和不占用过多内存的纹理&lt;/li>
&lt;li>删掉不可见的mip，先删掉最新看到的mip&lt;/li>
&lt;/ol>
&lt;p>流送器确定针对每个纹理加载的分辨率后，就会根据加载顺序优先级计算先更新哪个纹理。优先级根据按照以下顺序评估的多个条件定义：&lt;/p>
&lt;ol>
&lt;li>先加载可见mip&lt;/li>
&lt;li>先加载强制加载纹理、地形纹理和角色纹理&lt;/li>
&lt;li>先加载远离目标分辨率的纹理&lt;/li>
&lt;li>对于不可见的纹理，先加载最新看到的&lt;/li>
&lt;/ol>
&lt;p>最后一步是为了生成一批更新请求，每个请求增大或降低当前纹理分辨率。针对一批更新的内存量 受到内存池大小的限制，以便保持较低的动态请求数量。&lt;/p></description></item><item><title>颜色分级和胶片色调映射器</title><link>https://zentia.github.io/p/%E9%A2%9C%E8%89%B2%E5%88%86%E7%BA%A7%E5%92%8C%E8%83%B6%E7%89%87%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%A2%9C%E8%89%B2%E5%88%86%E7%BA%A7%E5%92%8C%E8%83%B6%E7%89%87%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%A2%9C%E8%89%B2%E5%88%86%E7%BA%A7%E5%92%8C%E8%83%B6%E7%89%87%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84%E5%99%A8/randg_herobanner.png" alt="Featured image of post 颜色分级和胶片色调映射器" />&lt;p>在虚幻引擎中，颜色分级 一词涵盖了高动态范围（HDR）显示输出使用的色调映射功能（HDR到LDR转换），并改进了图像的颜色校正（用于筛选颜色变换的LDR颜色）处理。&lt;/p></description></item><item><title>运行时虚拟纹理</title><link>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 运行时虚拟纹理" />&lt;p>运行时虚拟纹理 (RVT)在运行时使用GPU按需创建其纹素数据，工作方式与传统纹理映射类似。较大区域上的RVT缓存着色数据非常适用于使用贴花类材质的地形和适配地形的样条。&lt;/p>
&lt;h1 id="工作流程">工作流程
&lt;/h1>&lt;p>使用以下高级步骤在项目中设置和使用运行时虚拟纹理：&lt;/p>
&lt;ol>
&lt;li>在内容浏览器中创建 运行时虚拟纹理 资产。用于将所有组件（包括RVT体积Actor和RVT材质）链接在一起，渲染运行时虚拟纹理。&lt;/li>
&lt;li>在 模式（Modes） 面板中将 运行时虚拟纹理体积（Runtime Virtual Texture Volume） 添加到场景。此操作用于将RVT资产放置到场景中。&lt;/li>
&lt;li>配置材质以 写入 到RVT资产。&lt;/li>
&lt;li>配置材质以从RVT资产 采样。&lt;/li>
&lt;li>设置一个或多个图元组件或地形Actor，以渲染至RVT资产。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>欲了解设置RVT的详细步骤指南，参见运行时虚拟纹理快速入门。本指南将设置地形材质和其他场景组件，以使用运行时虚拟纹理。&lt;/p>&lt;/blockquote></description></item><item><title>景深</title><link>https://zentia.github.io/p/%E6%99%AF%E6%B7%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%99%AF%E6%B7%B1/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%99%AF%E6%B7%B1/randg_herobanner.png" alt="Featured image of post 景深" />&lt;p>与真实世界的摄像机类似，景深（DOF）基于距离对焦点前后的场景应用模糊处理。 这种效果可以用来基于景深将观者的注意力吸引到特定的拍摄物体上，同时增加美学观感，使渲染看起来更像照片或影片。&lt;/p>
&lt;h1 id="景深类型">景深类型
&lt;/h1>&lt;p>在虚幻引擎中，您可以使用几种方法来执行景深效果。 这些方法被分为两大类：&lt;/p>
&lt;ul>
&lt;li>影片： 此方法向景深效果提供了一种影视的观感。 对此方法进行调整可以与摄影和影片摄影中常见的摄像机选项更加一致。 该选项对于个人电脑和主机平台来说非常适合。&lt;/li>
&lt;li>移动： 该方法提供了移动平台可以接受的最优化、低开销的DOF选项。&lt;/li>
&lt;/ul>
&lt;p>从以下方法中选择，了解它们的更多功能：&lt;/p></description></item><item><title>流送虚拟纹理</title><link>https://zentia.github.io/p/%E6%B5%81%E9%80%81%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B5%81%E9%80%81%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B5%81%E9%80%81%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 流送虚拟纹理" />&lt;p>流送虚拟纹理 (SVT)是一种在项目中从硬盘流送纹理的替代方法，与虚幻引擎4（UE4）中现有基于mip的纹理流送相比，其既有优点也有缺点。&lt;/p></description></item><item><title>纹理流送指标</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/ue5-hero.png" alt="Featured image of post 纹理流送指标" />&lt;p>可使用 STAT STREAMING 控制台命令分析纹理流送状态。此分析报告性能、内存使用，以及纹理流送器使用的其他指标。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">STAT STREAMING sortby=name maxhistoryframes=1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/statstreaming.png"
width="1136"
height="626"
srcset="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/statstreaming_hu_7d663e3bd6568f81.png 480w, https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/statstreaming_hu_53f6b5ad6d3d0ecc.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>读取内存数据时，术语&amp;quot;pool&amp;quot;代表概念（保留）内存，与实际使用的内存无关。 术语&amp;quot;mips&amp;quot;代表纹理当前使用的内存，而非未发生或未来的使用。内存指标分为三种主要的池：&lt;/p>
&lt;ul>
&lt;li>Texture&lt;/li>
&lt;li>Streaming&lt;/li>
&lt;li>Wanted&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这些池的大小显示在 Memory Counters 类目中每行的右方。&lt;/p>&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数据&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Game Thread Update Time&lt;/td>
&lt;td>流送器更新函数所占用的时间。这负责大多数的纹理流送工作。只有少数任务在纹理流送器外处理，如移除对纹理、组件或关卡的引用。在一个游戏线程更新中，流送器向完整更新执行一步。完成更新将持续数帧，并与 r.Streaming.FramesForFullUpdate 相关。如数据的 Counter 部分所定义，更新步骤各有不同。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Texture Pool&lt;/td>
&lt;td>纹理资源可用的总内存。这包含各种非流送资源，如渲染目标、GPU 粒子缓存、立方体贴图、UI 纹理和不可流送纹理。在部分平台上，此内存可用于保存静态网格体之类的非纹理资源。Texture Pool 约等于 Safety Pool + Temporary Pool + Streaming Pool + NonStreaming Mips（如有，仅限波动的量，上至安全池的大小）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Safety Pool&lt;/td>
&lt;td>此值在 Engine 配置文件中设置（在 [TextureStreaming] 下，作为 MemoryMargin）。这是为意外（非流送）分配预留的内存。如可用的内存因低于此值的量形成周期波动，纹理流送器将在此波动下最大程度地稳定其流送池如正常（预计）的波动超过安全池大小，纹理流送器将不断应用其预算，可能会创建流入和流出纹理的无限循环。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Temporary Pool&lt;/td>
&lt;td>此值由 r.Streaming.MaxTempMemoryAllowed 控制，并指定调整纹理大小时流送器可用的额外内存量。变更纹理的 mip 数量时，引擎需要新建一个纹理（无论大小），用于保存之后的 mip 数据。这能间接控制进行中请求的数量，因为流送器将向 IO 系统发送临时池允许的请求数量。注意：临时池最小尺寸必须与需要流送的最大资源相同，但设为过大会浪费内存（因其正是为此目的而预留）。从另一方面而言，设为过小会减缓流送速度（无法为 IO 系统生成足够的工作，使其进入待机状态）。此外还需注意：流送器无法对进行中请求内的处理顺序进行较大程度的控制。这意味着使用相对较小的临时池可更大程度地控制加载顺序。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Streaming Pool&lt;/td>
&lt;td>纹理流送器可用的内存量。流送器通常会将所有可用内存用于流送新 mip，或将之前流送的 mip 尽可能久地保存在内存中。流送池（Streaming Pool）包含可见 Mip（Visible Mip）、隐藏 Mip（Hidden Mip）、强制 Mip（Force Mip）和缓存 Mip（Cached Mip）。Streaming Pool 约等于 Visible Mips* + Hidden Mips + Forced Mips + Cached Mips（完全使用时为 *:，否则未使用的空间必须被占用）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NonStreaming Mips&lt;/td>
&lt;td>非流送分配使用的内存量。如这些分配因超过安全池的值而出现定期波动，这将影响流送池的预算，应避免出现此状况（减少分配次数或增加安全池）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Required Pool&lt;/td>
&lt;td>纹理流送器需要根据其指标加载的 mip 数据量。这可超过纹理流送池的 100%，但同时也会进行一些妥协，部分纹理将不会以其所要求的分辨率加载。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Visible Mips&lt;/td>
&lt;td>可见纹理 mip 当前占用的所需内存。这并不包含强制 mip。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hidden Mips&lt;/td>
&lt;td>非可见纹理 mip 当前占用的所需内存。这并不包含强制 mip。为防止首次显示纹理时出现低精度纹理，流送器会提前预流送纹理，但通常会比所需要的少一个 mip（详见 r.Streaming.HiddenPrimitiveScale）。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>着色器调试工作流程</title><link>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/ue5-hero.png" alt="Featured image of post 着色器调试工作流程" />&lt;h1 id="渲染线程">渲染线程
&lt;/h1>&lt;p>在虚幻引擎中，整个渲染器在其自身的线程中执行操作，该线程位于游戏线程的一两帧后。&lt;/p>
&lt;p>执行渲染操作时，必须仔细地考虑内存读写，确保线程安全，以及行为的确定性。功能行为取决于两个线程之间的执行速度差，这种情况被称作竞争条件。需要尽量避免竞争条件的出现，因为它们难以重现；且因为速度差的缘故，它们可能依赖于机器、平台、调试器或配置。这类 bug 很难进行调试，所花费的修复时间约为可重现的普通 bug 的 10 倍。&lt;/p></description></item><item><title>自动曝光</title><link>https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/rendering-herobanner-5-0.png" alt="Featured image of post 自动曝光" />&lt;p>后期处理体积（Post Process Volume） 提供 自动曝光（Automatic Exposure） （通常称为眼部适应）控制选项，可自动调整当前场景视图的明暗。此效果可再现人眼适应不同光照条件的体验，例如从昏暗的室内走到明亮的室外，或从室外走到室内。&lt;/p>
&lt;h1 id="曝光测光模式">曝光测光模式
&lt;/h1>&lt;p>在场景中设置自动曝光时，引擎提供几种测光模式选项。此类不同测光模式提供可精确模拟实际摄像机的设置，可在后期处理过程中控制场景中的曝光。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/exposuremeteringmodes.png"
width="473"
height="169"
srcset="https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/exposuremeteringmodes_hu_e38fe788089f76f5.png 480w, https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/exposuremeteringmodes_hu_1b5084dde9f1ae7.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="279"
data-flex-basis="671px"
>&lt;/p>
&lt;ul>
&lt;li>自动曝光直方图（Auto Exposure Histogram） 模式通过由64bin直方图构成的高级设置更好地控制自动曝光。这是虚幻引擎中的默认曝光测光模式。&lt;/li>
&lt;li>基本自动曝光（Auto Exposure Basic） 模式提供的设置较少，但这是通过下采样曝光计算单个值的更快速方法。&lt;/li>
&lt;li>手动（Manual） 模式支持使用后期处理和摄像机设置中的 摄像机（Camera） 设置控制曝光，而非仅使用 曝光（Exposure） 类别中的设置。&lt;/li>
&lt;/ul>
&lt;h2 id="直方图和基本算法">直方图和基本算法
&lt;/h2></description></item><item><title>异步计算</title><link>https://zentia.github.io/p/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/ue5-hero.png" alt="Featured image of post 异步计算" />&lt;p>渲染硬件接口（RHI）现支持 Xbox One 的异步计算（AsyncCompute）。此法可运行与渲染异步的 dispatch() 调用，有效利用未使用的 GPU 资源（计算单元（CU）、寄存器和带宽）。异步计算使用单独的上下文，我们通过 RHI 函数同步渲染和计算上下文。Dr PIX 可用于识别从异步计算获益的区域。例如，特定渲染通道中半数 CU 均未使用，这些 CU 则可能被异步计算任务所利用。异步计算存在一些限制：&lt;/p></description></item><item><title>可延展性设置</title><link>https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/ue5-hero.png" alt="Featured image of post 可延展性设置" />&lt;h1 id="可延展性设置">可延展性设置
&lt;/h1>&lt;p>要在编辑器中访问可延展性设置，可使用工具栏中的设置（Settings）菜单。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_viewqual.png"
width="870"
height="648"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_viewqual_hu_660a2bbe38fd2601.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_viewqual_hu_eb94a814a012fbd6.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="322px"
>&lt;/p>
&lt;h1 id="分辨率缩放">分辨率缩放
&lt;/h1>&lt;p>UE可以较低分辨率渲染场景，然后将图像延展到目标分辨率。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00007.png"
width="939"
height="353"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00007_hu_8b00d92bde1ea5f.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00007_hu_b363202e6dacd546.png 1024w"
loading="lazy"
alt="左：50%无AA，中间：50%有AA，右：100%（无分辨率缩放）有AA"
class="gallery-image"
data-flex-grow="266"
data-flex-basis="638px"
>&lt;/p>
&lt;h1 id="视图距离">视图距离
&lt;/h1>&lt;p>对象可以根据与查看者的距离而剔除。默认情况下，所有对象都不会随距离而剔除（所需最大绘制距离为0）。除了设计者指定的值之外，还有一个全局可延展性设置，其作用类似于乘数（r.ViewDistanceScale）。下图您可以看到一些草对象（所需最大绘制距离为1000）：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00006.png"
width="1431"
height="314"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00006_hu_d40726dcea105a47.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00006_hu_9697e1379c2915c4.png 1024w"
loading="lazy"
alt="左： r.ViewDistanceScale 0.4，中间：r.ViewDistanceScale 0.7，右：r.ViewDistanceScale 1.0（默认值）"
class="gallery-image"
data-flex-grow="455"
data-flex-basis="1093px"
>&lt;/p>
&lt;h1 id="抗锯齿">抗锯齿
&lt;/h1>&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_aa_small.png"
width="920"
height="216"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_aa_small_hu_298278cc3782843.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_aa_small_hu_548e393c642400f7.png 1024w"
loading="lazy"
alt="从左开始：r.PostProcessAAQuality 0到6。前3个等于 视图（View）-&amp;gt;可延展性选项（Scalability Options）-&amp;gt;AA 设置中的 低（Low）、中（Medium）、高（High）、Epic 设置。"
class="gallery-image"
data-flex-grow="425"
data-flex-basis="1022px"
>&lt;/p>
&lt;h1 id="后期处理sgpostprocessquality">后期处理——sg.PostProcessQuality
&lt;/h1>&lt;h1 id="阴影sgshadowquality">阴影——sg.ShadowQuality
&lt;/h1>&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_shadowquallevels.png"
width="4065"
height="665"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_shadowquallevels_hu_83ca908e3725a514.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_shadowquallevels_hu_a2c094256dc9599c.png 1024w"
loading="lazy"
alt="sg.ShadowQuality左侧设置为0，依次向右递增到3。"
class="gallery-image"
data-flex-grow="611"
data-flex-basis="1467px"
>&lt;/p>
&lt;p>视图（View）-&amp;gt;引擎可延展性设置（Engine Scalability Settings）-&amp;gt;阴影（Shadows） 选项根据[UE_InstallPath]/Engine/Config文件夹中 BaseScalability.ini 文件中的设置，调节动态阴影的质量。低（Low） 设置等于 sg.ShadowQuality 0，Epic 等于 sg.ShadowQuality 3。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>sg.ShadowQuality 0&lt;/th>
&lt;th>sg.ShadowQuality 1&lt;/th>
&lt;th>sg.ShadowQuality 2&lt;/th>
&lt;th>sg.ShadowQuality 3&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.LightFunctionQuality=0&lt;/td>
&lt;td>r.LightFunctionQuality=1&lt;/td>
&lt;td>r.LightFunctionQuality=1&lt;/td>
&lt;td>r.LightFunctionQuality=1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.ShadowQuality=0&lt;/td>
&lt;td>r.ShadowQuality=2&lt;/td>
&lt;td>r.ShadowQuality=5&lt;/td>
&lt;td>r.ShadowQuality=5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.CSM.MaxCascades=1&lt;/td>
&lt;td>r.Shadow.CSM.MaxCascades=1&lt;/td>
&lt;td>r.Shadow.CSM.MaxCascades=2&lt;/td>
&lt;td>r.Shadow.CSM.MaxCascades=4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.MaxResolution=512&lt;/td>
&lt;td>r.Shadow.MaxResolution=1024&lt;/td>
&lt;td>r.Shadow.MaxResolution=1024&lt;/td>
&lt;td>r.Shadow.MaxResolution=1024&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.RadiusThreshold=0.06&lt;/td>
&lt;td>r.Shadow.RadiusThreshold=0.05&lt;/td>
&lt;td>r.Shadow.RadiusThreshold=0.03&lt;/td>
&lt;td>r.Shadow.RadiusThreshold=0.03&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.DistanceScale=0.6&lt;/td>
&lt;td>r.Shadow.DistanceScale=0.7&lt;/td>
&lt;td>r.Shadow.DistanceScale=0.85&lt;/td>
&lt;td>r.Shadow.DistanceScale=1.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.CSM.TransitionScale=0&lt;/td>
&lt;td>r.Shadow.CSM.TransitionScale=0.25&lt;/td>
&lt;td>r.Shadow.CSM.TransitionScale=0.8&lt;/td>
&lt;td>r.Shadow.CSM.TransitionScale=1.0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="纹理sgtexturequality">纹理——sg.TextureQuality
&lt;/h1>&lt;p>主流渲染引擎需要更多GPU内存（纹理、网格体、GBuffer、深度缓冲、阴影贴图）。其中一些根据屏幕分辨率缩放（例如GBuffer），另一些有特定的质量设置（例如，阴影贴图）。使用大量GPU内存的另一个因素是所用的纹理（通常压缩并流送）。您可以指示流送系统在管理上更主动一些（缩小池大小、剔除不用的纹理），或者在mip等级计算中拥有更少或更多细节。这样会影响图像质量、您能够注意到的纹理流送瑕疵数量以及游戏的运行流畅度（更新需要高成本内存传输）。结果不尽相同，具体取决于介质（例如，更快/更慢的硬盘/SSD）。从DVD/蓝光流送会大幅增加延迟，因此应当尽量避免。&lt;/p></description></item><item><title>图形编程</title><link>https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/ue5-hero.png" alt="Featured image of post 图形编程" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>引擎中的渲染器模块管理并渲染场景，而场景拥有和每个世界场景相关的可渲染信息。它包括所有绘制规则和着色器的定义。&lt;/p>
&lt;p>RHI 模块是渲染 API 的接口，是图形编程的另一个关键组件。图形编程介绍包含许多可研究的键类、设置和变量，以下子页面包含详细的渲染要点。&lt;/p></description></item><item><title>线程渲染</title><link>https://zentia.github.io/p/%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/ue5-hero.png" alt="Featured image of post 线程渲染" />&lt;h1 id="渲染线程">渲染线程
&lt;/h1>&lt;p>在虚幻引擎中，整个渲染器在其自身的线程中执行操作，该线程位于游戏线程的一两帧后。&lt;/p>
&lt;p>执行渲染操作时，必须仔细地考虑内存读写，确保线程安全，以及行为的确定性。功能行为取决于两个线程之间的执行速度差，这种情况被称作竞争条件。需要尽量避免竞争条件的出现，因为它们难以重现；且因为速度差的缘故，它们可能依赖于机器、平台、调试器或配置。这类 bug 很难进行调试，所花费的修复时间约为可重现的普通 bug 的 10 倍。&lt;/p></description></item><item><title>屏幕百分比与时序上采样</title><link>https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/ue5-hero.png" alt="Featured image of post 屏幕百分比与时序上采样" />&lt;p>屏幕百分比 是一种分辨率调节技术，用于渲染分辨率低于或高于实际显示图像的图像。通过调节屏幕百分比，你的游戏可以在性能和图像分辨率之间保持平衡。&lt;/p>
&lt;p>在虚幻引擎4（UE4）4.19版之前，你只需要更改屏幕百分比，但现在它分成了渲染管道中的两类缩放：主要和次要空间放大。&lt;/p>
&lt;ul>
&lt;li>主要空间放大（Primary Spatial Upscaling） 就是以前使用的屏幕百分比功能。它的基本理念是以较低的分辨率渲染画面，然后先放大，再绘制用户界面（UI）。&lt;/li>
&lt;li>次要空间放大（Secondary Spatial Upscaling） 执行第二次也是最终的空间放大传递，与主要放大传递无关。&lt;/li>
&lt;/ul>
&lt;h1 id="主要屏幕百分比">主要屏幕百分比
&lt;/h1>&lt;p>主要空间放大（即主要屏幕百分比）的工作方式是按屏幕百分比渲染屏幕分辨率，然后进行缩放以适应你的当前屏幕分辨率。如果使用较低的屏幕百分比（或较低的分辨率），然后放大，就称为上采样。或者，在屏幕百分比增大之后（按较高的分辨率渲染），会缩小到当前屏幕的分辨率，这称为 超级取样。这一切都发生在绘制用户界面（UI）之前，可能对性能产生影响。&lt;/p>
&lt;p>关于屏幕分辨率如何对组成屏幕上所渲染图像的所有缓冲区渲染目标起作用并使其组成一个GPU帧的概念，可以作如下说明：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/noupscaling.png"
width="3438"
height="756"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/noupscaling_hu_a56b0b94ff49f685.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/noupscaling_hu_68d8d1e071c3ada9.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="454"
data-flex-basis="1091px"
>&lt;/p>
&lt;p>对于每个GPU帧，所有渲染目标在管道中自始至终使用其全分辨率。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialupscale.png"
width="3846"
height="894"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialupscale_hu_fd607ba54dfd06c.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialupscale_hu_d615b3a5f061052b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="430"
data-flex-basis="1032px"
>&lt;/p>
&lt;p>在使用空间放大的情况下，在UI之前绘制的一切都根据所用的屏幕百分比使用或高或低的分辨率。屏幕百分比已经降低（从UI之前变窄的渲染目标可以看出），为渲染目标产生了降低分辨率的图像。空间缩放发生在UI之前，将图像缩放至将要输出的屏幕分辨率。例如，如果当前分辨率设置为1920x1080，并且使用83%的屏幕分辨率，那么渲染目标的大小将调整为近似的1600x900分辨率，然后重新放大到1920x1080。&lt;/p>
&lt;h2 id="空间放大质量">空间放大质量
&lt;/h2>&lt;p>在放大渲染目标时，可以使用以下控制台变量定义放大质量：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.Upscale.Quality
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它控制屏幕百分比和全屏窗口模式缩放3D渲染的质量&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>上采样质量数值&lt;/th>
&lt;th>上采样结果&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>最接近的过滤&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>简单双线&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>定向模糊，带有非锐化遮罩上采样&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>5-tap Catmull-Rom双立方插值，近似Lanczos 2（默认）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>13-tap Lanczos 3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>36-tap高斯过滤非锐化遮罩（成本非常高，但很适合极端上采样）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>或者，你可以使用下列控制台变量来控制如何处理色调映射器传递：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.Tonemapper.MergeWithUpscale.Mode
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>色调映射器集成了一个简单的颜色空间空间放大，可以因为性能原因而使用值 1 来启用它。但是，如果材质后期处理在色调映射器之后插入，那么色调映射器就不会执行放大。它将重新使用主要空间放大，就像被禁用了一样。&lt;/p>
&lt;h1 id="时序抗锯齿上采样">时序抗锯齿上采样
&lt;/h1>&lt;p>除了主要空间放大外，主要屏幕分辨率还支持第二种放大技术：时序上采样。在时序抗锯齿上采样（TAAU）中，不是先使用时序抗锯齿（TAA）执行临时集成，然后再执行主要空间放大，实际上这两者是同时发生的。它们也可以收敛为比仅使用空间放大时更锐利的图像，不过这样做的成本也会比较高，因为要在较高的分辨率下运行更多后期处理。动态分辨率还可以隐藏主要屏幕百分比更改，从而更频繁地进行更改，尽可能接近地匹配GPU预算。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialandtemporalupsample.png"
width="3438"
height="900"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialandtemporalupsample_hu_c8f09a40596542b4.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialandtemporalupsample_hu_ddb8b500a85c5109.png 1024w"
loading="lazy"
alt="TAAU在管道中发生得比较早，这导致在其后的传递会以较高的分辨率渲染，因此以较高的成本产生更为锐利的图像。"
class="gallery-image"
data-flex-grow="382"
data-flex-basis="916px"
>&lt;/p>
&lt;p>应该注意的是，在使用时序上采样时，不同的后期处理顺序不会因为增加TAAU而改变，因为它只是取代了TAA。真正的差别是，在TAAU之前进行的所有处理都将先使用较低的分辨率，然后上采样到TAAU传递之后的分辨率。在4.19版之前，是假定后期处理中的分辨率始终不变。&lt;/p>
&lt;blockquote>
&lt;p>在主要屏幕百分比降低后，到干净的全分辨率输出的收敛会改变。因此，一些原有的TAA瑕疵会变得更明显。例如在非常细的几何体上，锯齿可能成为问题，增加在降低主要屏幕百分比时丢失此几何体细节的概率。&lt;/p>&lt;/blockquote>
&lt;h2 id="启用时序上采样">启用时序上采样
&lt;/h2>&lt;p>要使用时序抗锯齿上采样，你需要进入&amp;quot;项目设置（Project Setting）&amp;ldquo;中找到 时序上采样（Temporal Upsampling），更简单的办法是使用下列控制台变量：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.TemporalAA.Upsampling 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果使用空间放大的主要屏幕百分比较低，在降低分辨率时，可能丢失重要细节。例如，对于铁链栅栏或者车头的格栅，当使用时序抗锯齿时，可能在较远的距离比较难以看清细节。如果启用TAAU，就可以在仍然使用降低的屏幕百分比的情况下减少这一问题。&lt;/p>
&lt;h2 id="automatic-view-texture-mip-bias">Automatic View Texture Mip Bias
&lt;/h2>&lt;p>因为屏幕百分比会导致几何体以较低的像素密度渲染，所以时序上采样需要更多来自 表面 和 延迟贴花 材质域的纹理信息才能保持输出锐利度不变。为此，在默认情况下可以使用纹理取样表达式 Automatic View Mip Bias。&lt;/p>
&lt;p>纹理取样表达式可使用 Automatic View Mip Bias 来切换是否应该通过逐视图的Mip偏差对纹理进行取样，从而使时序抗锯齿具有更锐利的输出。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbias.png"
width="738"
height="341"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbias_hu_1bd7afd8befa9033.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbias_hu_b711cde2c84d739e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;p>对于高频纹理（例如下面的示例），自动Mip偏差在较低的屏幕百分比下可能问题较多。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/hftexture.png"
width="512"
height="512"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/hftexture_hu_58bc6f70ef516626.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/hftexture_hu_72b2ecfa6ec94149.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>&lt;/p>
&lt;p>在这种情况下，可以使用Mip偏差输入来补偿，或者选择不使用 Automatic View Mip Bias。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbiasunchecked.png"
width="738"
height="341"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbiasunchecked_hu_2d727bab8ab3de8d.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbiasunchecked_hu_dc4107ed014c88b3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;blockquote>
&lt;p>Automatic View Mip Bias 仅发生在启用TAAU的情况下。常规抗锯齿方法（TAA、MSAA和FXAA）将无法使用此选项。&lt;/p>&lt;/blockquote>
&lt;h2 id="实现抗锯齿质量的着色器性能permutation">实现抗锯齿质量的着色器性能Permutation
&lt;/h2>&lt;p>和TAA一样，临时放大采样附带用于实现后期处理质量3和4的更快着色器Permutation。着色器Permutation换来的是一定的质量，能够在主机平台上发布60Hz运行的作品。质量设置与设置后期处理质量时已经使用的设置相似。此外还应牢记，TAAU需要比TAA更多的工作，因为它是在较高的分辨率下运行，并且在TAAU传递之后还有后期处理。&lt;/p>
&lt;p>可以使用下列控制台变量调节后期处理质量：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.PostProcessAAQuality
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>值得注意的是，时序上采样之后的后期处理是在全分辨率下运行的，所以禁用TAA将使它们在较低的分辨率下运行，这是因为它们将在最后进行空间放大，从而加快后期处理的速度。请使用命令profileGPU来调查每次传递中GPU性能的明细，使用的是什么传递，以及大部分预算用在哪里。&lt;/p>
&lt;p>下表说明了使用这些范围中的主要屏幕百分比值设置时你可以期待的结果：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>屏幕范围&lt;/th>
&lt;th>百分比&lt;/th>
&lt;th>备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>50%&lt;/td>
&lt;td>71%&lt;/td>
&lt;td>这是提高性能的最快方法，因为它在内存中使用较小的本地数据存储（LDS）块。如果目标是在台式机和游戏机上时序上采样到4K，这是理想的选择。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>71%&lt;/td>
&lt;td>100%&lt;/td>
&lt;td>对于台式机和游戏机上的普通DPI（每英寸点数）渲染是理想选择。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>100%&lt;/td>
&lt;td>200%&lt;/td>
&lt;td>如果要使动态分辨率在不被用于渲染目标的GPU内存限制的前提下具有超过100%的理论可能，那么这是理想选择。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>纹理流送</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81/ue5-hero.png" alt="Featured image of post 纹理流送" />&lt;p>纹理流送系统，又称纹理流送器，是引擎中负责提高和降低每个纹理分辨率的部分。这能让你有用出色的视觉效果的同时，可以有效管理内存。&lt;/p>
&lt;h1 id="入门">入门
&lt;/h1></description></item><item><title>虚拟纹理</title><link>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 虚拟纹理" />&lt;p>利用项目对虚拟纹理的这次hi，可在运行时以更低内存占用率和更高一致性创建和使用大尺寸纹理。&lt;/p>
&lt;h1 id="虚拟纹理方法">虚拟纹理方法
&lt;/h1>&lt;p>虚幻引擎4(UE4)支持两种虚拟纹理方法：运行时虚拟纹理 (RVT) 和 流送虚拟纹理 (SVT)。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运行时虚拟纹理&lt;/th>
&lt;th>流送虚拟纹理&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>支持超高纹理分辨率。&lt;/td>
&lt;td>支持超高纹理分辨率。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>按需将纹素数据缓存于内存中。&lt;/td>
&lt;td>按需将纹素数据缓存于内存中。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>运行时由GPU生成的纹素数据。&lt;/td>
&lt;td>在硬盘中烘焙和加载纹素数据。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>非常适用于可按需渲染的纹理数据，如过程纹理或合成分层材质。&lt;/td>
&lt;td>非常适用于生成时间较长的纹理数据，如光照贴图或美术师创建的大型细节纹理。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="运行时虚拟纹理">运行时虚拟纹理
&lt;/h2>&lt;p>利用 运行时虚拟纹理 可有效渲染过程生成或分层的复杂材质，使运行时虚拟纹理适用于渲染复杂的地形材质。其能改善地形样条、网格体和材质贴花，及一般地形与对象混合的渲染性能和工作流程。&lt;/p>
&lt;blockquote>
&lt;p>欲了解更多详情，参见运行时虚拟纹理。&lt;/p>&lt;/blockquote></description></item><item><title>剔除距离体积</title><link>https://zentia.github.io/p/%E5%89%94%E9%99%A4%E8%B7%9D%E7%A6%BB%E4%BD%93%E7%A7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%89%94%E9%99%A4%E8%B7%9D%E7%A6%BB%E4%BD%93%E7%A7%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%89%94%E9%99%A4%E8%B7%9D%E7%A6%BB%E4%BD%93%E7%A7%AF/randg_herobanner.png" alt="Featured image of post 剔除距离体积" />&lt;p>剔除距离体积（Cull Distance Volume） 是非常有用的优化工具，它定义绘制（显现）该体积中的Actor的距离。这些体积可存储任意数量的&amp;quot;大小&amp;quot;和&amp;quot;距离&amp;quot;组合（称为 剔除距离对）。这些剔除距离对会被映射到Actor（沿其最长有效维度）的边界，然后指定给关卡中的该Actor实例。剔除距离体积（Cull Distance Volume）对于优化包含精细内部空间的大型室外关卡非常有用。当室内空间小到可被视为不重要时，可以剔除它们。&lt;/p></description></item></channel></rss>