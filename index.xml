<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>zentia</title><link>https://zentia.github.io/</link><description>Recent content on zentia</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://zentia.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Actors</title><link>https://zentia.github.io/p/actors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/actors/</guid><description>&lt;img src="https://zentia.github.io/p/actors/ue5-hero.png" alt="Featured image of post Actors" />&lt;p>所有可以放入关卡的对象都是 Actor，比如摄像机、静态网格体、玩家起始位置。Actor支持三维变换，例如平移、旋转和缩放。你可以通过游戏逻辑代码（C++或蓝图）创建（生成）或销毁Actor。&lt;/p>
&lt;p>在C++中，AActor是所有Actor的基类。&lt;/p>
&lt;p>注意：Actor不直接保存变换（位置、旋转和缩放）数据；如Actor的根组件存在，则使用它的变换数据。&lt;/p>
&lt;h1 id="创建actor">创建Actor
&lt;/h1>&lt;p>创建 AActor 类的新实例被称为 生成。可使用泛型 SpawnActor() 函数或它的一个特殊模板化版本进行操作。&lt;/p>
&lt;p>在 生成和销毁Actor 中可查阅gameplay AActor 类实例诸多创建方法的详细信息。&lt;/p>
&lt;h1 id="组件">组件
&lt;/h1>&lt;p>在某种意义上，Actor 可被视为包含特殊类型 对象（称作组件）的容器。 不同类型的组件可用于控制Actor移动的方式及其被渲染的方式，等等。Actor的其他主要功能是在游戏进程中在网络上进行属性复制 和函数调用。&lt;/p>
&lt;p>组件被创建时与其包含的Actor相关联。&lt;/p>
&lt;p>组件的主要类型有：&lt;/p>
&lt;ul>
&lt;li>UActorComponent：这是基础组件。其可作为Actor的一部分被包含。如果需要，其可进行Tick。ActorComponents与特定的Actor相关联，但不存在于场景中的任意特定位置。它们通常用于概念上的功能，如AI或解译玩家输入。&lt;/li>
&lt;li>USceneComponent：SceneComponents是拥有变换的ActorComponents。变换是场景中的位置，由位置、旋转和缩放定义。SceneComponents能以层级的方式相互附加。Actor的位置、旋转和缩放取自位于层级根部的SceneComponent。&lt;/li>
&lt;li>UPrimitiveComponent：PrimitiveComponent是拥有一类图像表达（如网格体或粒子系统）的SceneComponent。诸多有趣的物理和碰撞设置均在此处。&lt;/li>
&lt;/ul>
&lt;p>Actor支持拥有一个SceneComponent的层级。每个Actor也拥有一个 RootComponent 属性，将指定作为Actor根的组件。Actor自身不含变换，因此不带位置、旋转，或缩放。 它们依赖于其组件的变换，具体来说是其根组件的变换。如果此组件是一个 SceneComponent，其将提供Actor的变换信息。 否则Actor将不带变换。其他附加的组件拥有相对于其附加到的组件的变换。&lt;/p>
&lt;h1 id="ticking">Ticking
&lt;/h1>&lt;p>Ticking代表Actor在虚幻引擎中的更新方式。所有Actor均能每帧tick，或以用户定义的最小间隔进行tick，以便执行必要的更新计算或操作。&lt;/p>
&lt;p>所有Actor均可通过 Tick() 函数默认被tick。&lt;/p>
&lt;p>ActorComponents 能够默认被更新，但其使用的是 TickComponent() 函数进行操作。 参见组件页面的更新部分了解详情。&lt;/p>
&lt;h1 id="生命周期">生命周期
&lt;/h1>&lt;p>查看Actor生命周期文档，了解如何在游戏中创建和移除Actor的更多信息。&lt;/p></description></item><item><title>FShaderCache</title><link>https://zentia.github.io/p/fshadercache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/fshadercache/</guid><description>&lt;img src="https://zentia.github.io/p/fshadercache/ue5-hero.png" alt="Featured image of post FShaderCache" />&lt;h1 id="总览">总览
&lt;/h1>&lt;p>FShaderCache提供的机制可减少游戏中着色器的卡顿。它支持OpenGLDrv和MetalRHI RHIs，可在Mac、Linux和windows平台上使用。&lt;/p>
&lt;p>可通过多个控制台命令启用或禁用FShaderCache功能。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制台命令&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.UseShaderCaching [0/1]&lt;/td>
&lt;td>着色器反序列化中早提交，不为请求式。追踪束缚着色器态，使它们在早提交中被预束缚。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="使用">使用
&lt;/h1>&lt;p>应在开发机上启用&lt;code>r.UseShaderCaching&lt;/code>和&lt;code>r.UseShaderDrawLog&lt;/code>填充缓存。用户/玩家启用&lt;code>r.UseShaderCaching&lt;/code>和&lt;code>r.UseShaderPredraw&lt;/code>消耗缓存。&lt;/p></description></item><item><title>Lumens性能指南</title><link>https://zentia.github.io/p/lumens%E6%80%A7%E8%83%BD%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/lumens%E6%80%A7%E8%83%BD%E6%8C%87%E5%8D%97/</guid><description>&lt;img src="https://zentia.github.io/p/lumens%E6%80%A7%E8%83%BD%E6%8C%87%E5%8D%97/ue5-hero.png" alt="Featured image of post Lumens性能指南" />&lt;p>Lumen的目标是，能够在主机上分别以8毫秒和4毫秒的帧预算实现30和60FPS，并为不透明和半透明材质以及体积雾实现全局光照和反射效果。引擎采用了一系列预先配置好的&amp;quot;可扩展/弹性（Scalability）&amp;ldquo;设置让Lumen应对不同的目标帧率需求。超高（Epic） 级别对应的帧率为30FPS。高（High） 级别对应的目标帧率为60FPS。&lt;/p>
&lt;p>Lumen依赖&lt;a class="link" href="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/" target="_blank" rel="noopener"
>时间上采样&lt;/a>和虚幻引擎5的&lt;a class="link" href="https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/" target="_blank" rel="noopener"
>时间超级分辨率&lt;/a>（TSR）功能来提供4k输出。Lumen和一些其他功能本身只使用较低的内部分辨率（1080p），这样能赋予TSR最佳的最终图像质量。否则，如果直接以4K原生分辨率渲染这些功能，则需要降低质量设置，这样才能实现30或60 FPS的帧率。&lt;/p>
&lt;h1 id="可扩展性设置">可扩展性设置
&lt;/h1>&lt;p>你可以在关卡编辑器中的 设置（Settings）&amp;gt; 引擎可扩展性设置（Engine Scalability Settings） 视口下找到可扩展性设置。在游戏中，请使用GameUserSettings和图形设置菜单来控制可扩展性设置（相关示例请参阅Lyra项目）。Lumen的品质可以通过 全局光照（Global Illumination） 和 反射（Reflections） 质量组进行设置：&lt;/p>
&lt;ul>
&lt;li>电影级（Cinematic） 可扩展性级别适合用于影片渲染队列。&lt;/li>
&lt;li>超高（Epic） 可扩展性级别的性能目标是在主机上实现30 FPS。&lt;/li>
&lt;li>高（High） 可扩展性级别的性能目标是在主机上实现60 FPS。&lt;/li>
&lt;li>低（Low） 和 中（Medium） 可扩展性级别下，Lumen功能会被禁用。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://zentia.github.io/p/lumens%E6%80%A7%E8%83%BD%E6%8C%87%E5%8D%97/engine-scalability-settings.png"
width="848"
height="654"
srcset="https://zentia.github.io/p/lumens%E6%80%A7%E8%83%BD%E6%8C%87%E5%8D%97/engine-scalability-settings_hu_220907a2d89a6b20.png 480w, https://zentia.github.io/p/lumens%E6%80%A7%E8%83%BD%E6%8C%87%E5%8D%97/engine-scalability-settings_hu_39ca8212dc519f8a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="311px"
>&lt;/p>
&lt;p>默认情况下，虚幻引擎在主机上的性能目标是30 FPS。如需以60 FPS为目标，将 全局光照（Global Illumination） 和 反射（Reflections） 质量组设置为 高（High） 。相关配置描述位于 [你的项目名称]\Platforms[主机]\Config\ 文件夹。例如，[你的项目名称]\Platforms\PS5\Config\PS5DeviceProfiles.ini 。&lt;/p>
&lt;p>例如，以60 FPS为目标的PlayStation 5的设备描述如下所示：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="n">PS5&lt;/span> &lt;span class="n">DeviceProfile&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">;&lt;/span>&lt;span class="err">将&lt;/span>&lt;span class="n">Lumen&lt;/span> &lt;span class="n">GI和反射质量设置为&lt;/span>&lt;span class="s">&amp;#34;高&amp;#34;&lt;/span>&lt;span class="err">，目标为&lt;/span>&lt;span class="mi">60&lt;/span> &lt;span class="n">fps&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">+&lt;/span>&lt;span class="n">CVars&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">sg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GlobalIlluminationQuality&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">+&lt;/span>&lt;span class="n">CVars&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">sg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ReflectionQuality&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="其他质量级别不启用lumen">其他质量级别(不启用Lumen)
&lt;/h1>&lt;p>全局光照（Global Illumination） 和 反射（Reflections） 的默认质量设置位于 \Engine\Config\BaseScalability.ini 中。这些设置会试图让间接光照的品质在不同质量级别下保持相似。这么做的额外好处是，你无需在不同平台上重新设置你的光照参数，同时还能缩减Lumen的开销。&lt;/p>
&lt;p>中质量级别&lt;/p>
&lt;ul>
&lt;li>对于大规模的环境光遮蔽， 距离场环境光遮蔽（Distance Field Ambient Occlusion） 会取代 Lumen全局光照（Lumen Global Illumination） 。&lt;/li>
&lt;li>对于小规模的环境光遮蔽，会启用 屏幕空间环境光遮蔽（Screen Space Ambient Occlusion） 。&lt;/li>
&lt;/ul>
&lt;p>低质量级别&lt;/p>
&lt;ul>
&lt;li>仅使用无阴影的天空光照。&lt;/li>
&lt;li>降低天空光照强度（r.SkylightIntensityMultiplier=0.7），以近似模拟 中（Medium） 质量级别中的效果，因为此时没有天空光照阴影。&lt;/li>
&lt;/ul>
&lt;h2 id="软件光线追踪">软件光线追踪
&lt;/h2></description></item><item><title>材质基本概念</title><link>https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ue5-hero.png" alt="Featured image of post 材质基本概念" />&lt;p>虚幻引擎中的材质（Materials）定义了场景中对象的表现属性。从广义上来讲，你可以将材质理解为涂在网格体上用来控制其视觉外观的“涂料”。&lt;/p>
&lt;p>更具体地说，材质能准确地告诉引擎某个表现应该如何与场景中地光源交互。材质定义了表现地各种特性，包括颜色、反射率、粗糙度、透明度等。&lt;/p>
&lt;h1 id="着色管线概述">着色管线概述
&lt;/h1>&lt;p>在渲染管线中，着色器是定义每个顶点或像素应该如何渲染的程序。虚幻引擎中的着色器用高级着色语言（HLSL）编写。然后，将着色器代码转化为GPU硬件可以执行的一系列汇编语言指令。最终像素颜色就这样输出到了你的显示器。&lt;/p>
&lt;p>在虚幻编辑器中，你无需编写HLSL代码即可为你的项目创建着色器。你在名为材质编辑器（Material Editor）的可视化脚本界面中创建名为材质（Material）的资产。&lt;/p></description></item><item><title>插件中的 Shader</title><link>https://zentia.github.io/p/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84-shader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84-shader/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84-shader/ue5-hero.png" alt="Featured image of post 插件中的 Shader" />&lt;p>全局着色器（Global Shaders）是不通过材质编辑器创建的着色器。相反，全局着色器使用C++创建，它们在固定的几何体上运行，并且无需与材质或网格体结合。有时候，必须使用更高级的功能才能实现某些外观，为此，有必要自定义着色器通道。&lt;/p>
&lt;p>全局着色器的部分示例包括渲染后期处理效果、分配计算着色器和清空屏幕。&lt;/p>
&lt;h1 id="虚幻着色器文件">虚幻着色器文件
&lt;/h1></description></item><item><title>构建纹理流送数据</title><link>https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%95%B0%E6%8D%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%95%B0%E6%8D%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%95%B0%E6%8D%AE/ue5-hero.png" alt="Featured image of post 构建纹理流送数据" />&lt;p>每次修改和重新保存材质或材质实例时，会重新计算与使用的每个纹理有关的纹理流送数据。 每个纹理数据包含UV通道索引和缩放，UV通道索引用于对纹理采样， 缩放是应用于被采样通道的乘法因数。&lt;/p>
&lt;p>但是，这不涵盖所有情况，因为采样可能基于场景位置、网格体顶点颜色或任何UV通道组合。这可能会导致无法通过分析 找到相关数据，引擎会假设依赖于UV通道0和缩放1。&lt;/p>
&lt;p>分析在多个不同的步骤运行，具体取决于所编辑的内容：&lt;/p>
&lt;ol>
&lt;li>材质：当用户应用或保存修改时运行。&lt;/li>
&lt;li>材质实例：材质实例编辑器关闭或者保存包含材质实例的包时运行。&lt;/li>
&lt;li>关卡：用户运行&amp;quot;构建纹理流送&amp;quot;时针对每个所用材质运行。用于确保每个材质都是最新的。材质不是最新的原因包括：
&lt;ul>
&lt;li>4.15之前的材质没有任何数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>关卡流送概述</title><link>https://zentia.github.io/p/%E5%85%B3%E5%8D%A1%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%85%B3%E5%8D%A1%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%85%B3%E5%8D%A1%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/ue5-hero.png" alt="Featured image of post 关卡流送概述" />&lt;p>关卡流送功能可以将地图文件加载到内存中，或者从内存中卸载，并在游戏过程中切换地图的可视性。这样一来，场景便能拆分为较小的地图块，并且只有相关部分才会占用资源并被渲染。正确设置后，开发者便能创建大型世界、无缝衔接的游戏场景，让玩家彷佛置身于“大世界”之中。&lt;/p>
&lt;h1 id="持久关卡">持久关卡
&lt;/h1>&lt;p>实现关卡无缝衔接第一步是创建持久关卡（Persistent Level）。你可以把它看作是一个主关卡，用来管理加载或卸载哪些关卡。&lt;/p>
&lt;h1 id="流送关卡">流送关卡
&lt;/h1>&lt;p>流送关卡通过 Levels 窗口 进行管理。它可与持久关卡重叠，或偏移创建更大的世界场景。 使用流送关卡的流送类型可设为 Always Loaded 或 Blueprint。右键单击关卡分段即可在 Levels 窗口中开启此设置。&lt;/p></description></item><item><title>过场动画景深</title><link>https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/randg_herobanner.png" alt="Featured image of post 过场动画景深" />&lt;p>以下景深方法具有影视级视觉效果，十分接近使用延迟着色渲染器和群集前向渲染器的桌面及主机平台上照片和电影的效果。&lt;/p>
&lt;p>类似于圆圈景深和散景景深，&amp;ldquo;影视级&amp;quot;景深的效果跟真实摄像机不相上下，你可以在锐化&lt;a class="link" href="" >高动态范围 (HDR)&lt;/a>内容中看到圆形散景（离焦区域）。此方法使用程序化散景模拟技术，具有动态分辨率稳定性和阿尔法通道支持，在台式机和主机上开发的项目还具有更快速、可扩展和性能优化等特性。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_disabled.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_disabled_hu_3989771e759a9fa6.png 480w, https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_disabled_hu_216ec5c823000df5.png 1024w"
loading="lazy"
alt="Depth of Field Disabled"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>
&lt;img src="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_enabled.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_enabled_hu_75955f69df7591d6.png 480w, https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/dof_cine_enabled_hu_38507762aa83299c.png 1024w"
loading="lazy"
alt="Cinematic Depth of Field"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;h1 id="对焦拍摄对象">对焦拍摄对象
&lt;/h1>&lt;p>实现美学意义上宜人景深效果的关键在于对焦拍摄对象。对于特定拍摄情形，影响景深设置的核心因素有三个：&lt;/p>
&lt;ul>
&lt;li>确定镜头要使用的 焦距（Focal Length）。&lt;/li>
&lt;li>选择合适的 孔径（Aperture）（F值）。&lt;/li>
&lt;li>选择拍摄对象与摄像机之间的 对象距离（Distance to your Subject）。&lt;/li>
&lt;/ul>
&lt;p>为了理解调整这些设置时会产生怎样的效果，我们来分析一下构成摄像机和拍摄场景的各个要素：&lt;/p></description></item><item><title>过场动画摄像机Actor</title><link>https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%91%84%E5%83%8F%E6%9C%BAactor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%91%84%E5%83%8F%E6%9C%BAactor/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%91%84%E5%83%8F%E6%9C%BAactor/ue5-hero.png" alt="Featured image of post 过场动画摄像机Actor" />&lt;p>过场动画摄影机Actor（Cine Camera Actor）是一种特殊的 摄像机Actor ，它拥有一些额外的设置，可以复制出真实相机的效果。你可以调整 胶片背板（Filmback） 、 镜头（Lens） 和 对焦（Focus） 参数，利用它们拍摄出逼真的场景画面，同时遵守行业标准。&lt;/p></description></item><item><title>结婚两周年纪念日</title><link>https://zentia.github.io/p/%E7%BB%93%E5%A9%9A%E4%B8%A4%E5%91%A8%E5%B9%B4%E7%BA%AA%E5%BF%B5%E6%97%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BB%93%E5%A9%9A%E4%B8%A4%E5%91%A8%E5%B9%B4%E7%BA%AA%E5%BF%B5%E6%97%A5/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BB%93%E5%A9%9A%E4%B8%A4%E5%91%A8%E5%B9%B4%E7%BA%AA%E5%BF%B5%E6%97%A5/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250525200348.jpg" alt="Featured image of post 结婚两周年纪念日" />
&lt;div class="video-wrapper">
&lt;iframe src="https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1Y5jGzJE97"
scrolling="no"
frameborder="no"
framespacing="0"
allowfullscreen="true"
>
&lt;/iframe>
&lt;/div>
&lt;p>亲爱的刘小姐：&lt;/p>
&lt;p>首先，庆祝我们的婚姻迎来了第二个年头，我感到无比幸福。回想我们一起走过的日子，心中充满了温暖和感激。&lt;/p>
&lt;p>不知不觉，我们结婚两年了，在这期间，我们有争吵，有失望，有抱怨，但这些终究过去了，也不再成为我们的回忆，那将成为我们生活的总结和教训，最终给我们的是幸福、快乐、希望、进取和美好的生活。&lt;/p>
&lt;p>一个幸福的家庭需要的是理解与支持，一个男人更需要是一个女人对他的支持，而我应该是那个最幸福、最快乐的男人，因为我有最爱、最可爱的老婆在不断努力的支持我、鼓励我、激励我，使我日渐成熟、稳重。&lt;/p>
&lt;p>我们的生活，算是慢慢趋于平静，两个人也在慢慢的相互磨合，我也在慢慢成长，改变心性。整体上是向好的方向发展，希望我们彼此继续努力，不要打破这来之不易的平静。&lt;/p>
&lt;p>谢谢你一直以来的包容和理解，让我在生活中感到如此幸福。&lt;/p>
&lt;p>我期待着和你一起走过更多的岁月，创造更多美好的回忆。无论未来的路有多么曲折，我都希望与你携手共度。&lt;/p>
&lt;p>我爱你，永远与你同在。祝我们结婚纪念日快乐！&lt;/p>
&lt;p>最后，我写了一首诗，如下：&lt;/p>
&lt;pre>&lt;code>我希望我像一股暖流进入你的心房，而不是像暴风雨那样猛烈汹涌波涛。
我希望我们生活平安喜乐，而不是跌宕起伏。
我希望我们彼此珍惜尊重体谅，少一点争吵。
生命带给彼此的意义，我想是陪伴吧。
如春风吹过你的脸颊，夕阳照进你的窗台，温暖而不炙热。
&lt;/code>&lt;/pre>
&lt;p>上面的那首歌也是根据这首诗生成的。&lt;/p>
&lt;p>我爱你亲爱的刘诗诗，我会永永远远地爱你，努力用行动向你证明我地爱！&lt;/p>
&lt;p>每一年的今天，我都写一封信给你，自从结婚以后，很少对你说过这么多的清华，是我不对，看着这封信，就当是我给你的情书吧。&lt;/p>
&lt;p>爱你的李先生。&lt;/p></description></item><item><title>抗锯齿和上采样</title><link>https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/ue5-hero.png" alt="Featured image of post 抗锯齿和上采样" />&lt;p>抗锯齿（Anti-Aliasing）是指在原本应该平滑的边缘和对象上删除锯齿状或阶梯状线条。抗锯齿的方法有很多种，可以减少这些类型的视觉瑕疵。有些方法用于特定渲染器和平台，而有些则非常适合提高性能和保真度。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-no-aa.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-no-aa_hu_26e4af9b79899ccf.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-no-aa_hu_7fc73724bfe86beb.png 1024w"
loading="lazy"
alt="NO AA"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>抗锯齿方法&lt;/th>
&lt;th>台式机/主机：延迟渲染器&lt;/th>
&lt;th>台式机/主机：正向渲染器&lt;/th>
&lt;th>移动：延迟渲染器&lt;/th>
&lt;th>移动：正向渲染器&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-tsr.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-tsr_hu_9f95e8c4d0f0ccc5.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-tsr_hu_86c08a3921b17e34.png 1024w"
loading="lazy"
alt="时间超级分辨率（TSR）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-taau.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-taau_hu_4667a9742d312003.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-taau_hu_bf41b082c629e164.png 1024w"
loading="lazy"
alt="时间抗锯齿上采样（TAAU）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-fxaa.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-fxaa_hu_5949c8321a4962c8.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-fxaa_hu_6838d61c29aed8cd.png 1024w"
loading="lazy"
alt="快速近似抗锯齿（FXAA）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-msaa.png"
width="1600"
height="867"
srcset="https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-msaa_hu_e9220de2f264c372.png 480w, https://zentia.github.io/p/%E6%8A%97%E9%94%AF%E9%BD%BF%E5%92%8C%E4%B8%8A%E9%87%87%E6%A0%B7/3-msaa_hu_6e389f3672691dd3.png 1024w"
loading="lazy"
alt="多重采样抗锯齿（MSAA）"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/td>
&lt;td>N&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="时间超级分辨率tsr">时间超级分辨率（TSR）
&lt;/h1>&lt;h1 id="时间抗锯齿上采样taau">时间抗锯齿上采样（TAAU）
&lt;/h1>&lt;h1 id="快速近似抗锯齿fxaa">快速近似抗锯齿（FXAA）
&lt;/h1>&lt;h1 id="多重采样抗锯齿msaa">多重采样抗锯齿（MSAA）
&lt;/h1></description></item><item><title>可混合物</title><link>https://zentia.github.io/p/%E5%8F%AF%E6%B7%B7%E5%90%88%E7%89%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8F%AF%E6%B7%B7%E5%90%88%E7%89%A9/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E6%B7%B7%E5%90%88%E7%89%A9/ue5-hero.png" alt="Featured image of post 可混合物" />&lt;p>利用项目对虚拟纹理的这次hi，可在运行时以更低内存占用率和更高一致性创建和使用大尺寸纹理。&lt;/p></description></item><item><title>理解基础知识</title><link>https://zentia.github.io/p/%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ue5-hero.png" alt="Featured image of post 理解基础知识" />&lt;h1 id="基础知识">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/foundational-knowledge-in--unreal-engine" target="_blank" rel="noopener"
>基础知识&lt;/a>
&lt;/h1>&lt;h1 id="项目设置">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/project-settings-in-unreal-engine" target="_blank" rel="noopener"
>项目设置&lt;/a>
&lt;/h1>&lt;h1 id="关卡">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/levels-in-unreal-engine" target="_blank" rel="noopener"
>关卡&lt;/a>
&lt;/h1>&lt;h1 id="actor和几何体">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/actors-and-geometry-in-unreal-engine" target="_blank" rel="noopener"
>Actor和几何体&lt;/a>
&lt;/h1></description></item><item><title>色彩分级面板</title><link>https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/ue5_1-rendering-hero-banner-5-0.png" alt="Featured image of post 色彩分级面板" />&lt;p>颜色分级面板是一个专用的界面，用于在场景中操纵颜色。它使用可以执行颜色分级操作的角色，如后期处理体积和颜色校正区域。&lt;/p>
&lt;p>您可以使用此窗格直接配置颜色分级属性和设置，而不是通过任何单个Actor的详细信息面板。这将使美术人员的配置更直接。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-scene.png"
width="1999"
height="1125"
srcset="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-scene_hu_34d8d5237cf49672.png 480w, https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-scene_hu_32dc2c7aec3027e7.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;h1 id="色彩分级面板接口">色彩分级面板接口
&lt;/h1>&lt;p>您可以通过选择Window &amp;gt; Color Grading从编辑器的主菜单打开Color Grading面板。这个面板在关卡视口的底部打开。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-panelinterface.png"
width="1988"
height="440"
srcset="https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-panelinterface_hu_47be657d90b6c411.png 480w, https://zentia.github.io/p/%E8%89%B2%E5%BD%A9%E5%88%86%E7%BA%A7%E9%9D%A2%E6%9D%BF/cg-panelinterface_hu_908171332a3043ad.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="451"
data-flex-basis="1084px"
>&lt;/p></description></item><item><title>摄像机Actor</title><link>https://zentia.github.io/p/%E6%91%84%E5%83%8F%E6%9C%BAactor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%91%84%E5%83%8F%E6%9C%BAactor/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%91%84%E5%83%8F%E6%9C%BAactor/ue5-hero.png" alt="Featured image of post 摄像机Actor" />&lt;p>过场动画摄影机Actor（Cine Camera Actor）是一种特殊的 摄像机Actor ，它拥有一些额外的设置，可以复制出真实相机的效果。你可以调整 胶片背板（Filmback） 、 镜头（Lens） 和 对焦（Focus） 参数，利用它们拍摄出逼真的场景画面，同时遵守行业标准。&lt;/p></description></item><item><title>时间超级分辨率</title><link>https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/ue5-hero.png" alt="Featured image of post 时间超级分辨率" />&lt;p>时间超级分辨率 （TSR）是一个与平台无关的时间分辨率修改器，它使虚幻引擎能够渲染美丽的4K图像。由于将一些开销大的渲染计算分摊到了许多帧，图像的开销只占一小部分。TSR的做法是渲染比虚幻引擎4中的时间抗锯齿上采样（TAAU）更低的内部分辨率。&lt;/p>
&lt;p>TSR提供了一种原生的高质量上采样技术，以满足次世代游戏的需求。它实现了Nanite几何体要求的保真度和细节所需的可能性，同时以低得多的分辨率渲染帧，从而为Lumen提供足够的性能。&lt;/p></description></item><item><title>虚拟纹理内存池</title><link>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E6%B1%A0/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E6%B1%A0/ue5-hero.png" alt="Featured image of post 虚拟纹理内存池" />&lt;p>虚拟纹理系统主要有两种GPU内存分配方式：页表内存（Page Table Memory）和物理内存池（Physical Memory Pool）。&lt;/p></description></item><item><title>预计算光照情景</title><link>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%85%89%E7%85%A7%E6%83%85%E6%99%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%85%89%E7%85%A7%E6%83%85%E6%99%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%85%89%E7%85%A7%E6%83%85%E6%99%AF/ue5-hero.png" alt="Featured image of post 预计算光照情景" />&lt;p>虚幻引擎支持在关卡中使用不同的预计算光照情景（Precomputed Lighting Scenarios）。这使得单个关卡可以保存并显示多种光照设置，使玩家即获得灵活的动态光照，又能以固定开销预计算光照。对用高性能方式进行高精度渲染的虚拟显示（VR）或建筑可视化而言，在不同预计算光照情景之间切换更显重要。通读此文后，你便能了解如何在项目中使用预计算光照。&lt;/p>
&lt;h1 id="功能限制">功能限制
&lt;/h1>&lt;p>虽然预计算光照情景拥有诸多优点，但使用时也需要注意其缺陷和限制。在下文中，我们将介绍其中的一些限制，并告诉你如何回避（或解决）它们。&lt;/p>
&lt;ul>
&lt;li>在游戏中只限制一个可见光照情景关卡。&lt;/li>
&lt;li>光照情景关卡出现后，来自所有子关卡的光照图数据均会放置在其中，因此白天时只加载Day Scenario光照图。因此光照图将不再由子关卡进行流送。&lt;/li>
&lt;li>子关卡光照贴图数据保存在光照情景的BuildData包中。注册来自其他子关卡的反射捕获会修改当前光照情景的BuiltData。假如加载子关卡两次，并且只加载光照情景BulidData一次，就会产生如下错误：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">错误： 反射捕获 /Game/Environments/Levels/Your_Level_Name.level_name:PersistentLevel.SphereReflectionCapture_1.NewReflectionComponent 上传了两次，且未重新加载其光照情景关卡。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>运行时虚拟纹理快速入门</title><link>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5-hero.png" alt="Featured image of post 运行时虚拟纹理快速入门" />&lt;blockquote>
&lt;p>本指南要求使用了在Epic Games启动程序中示例选项卡下的内容示例项目中的材质。虽然不使用这些材质也可以完成以下步骤，但为了设置地形，使其正常生效，需要使用绘制好的地形材质。在继续前，打开 示例 选项卡下的内容示例项目 Landscapes 地图，以配合本指南的学习。&lt;/p>&lt;/blockquote>
&lt;p>在运行时 虚拟纹理（RVT） 快速入门中，将介绍在你的项目中针对地形和非地形组件设置和使用RVT的过程。&lt;/p>
&lt;p>在开始本指南前，出于以下原因，理解运行时虚拟纹理最适用于地形十分重要：&lt;/p>
&lt;ul>
&lt;li>复杂的地形材质缓存着色效果，可提高性能。&lt;/li>
&lt;li>使用样条型和贴花类效果可提高质量和加强变体。&lt;/li>
&lt;li>由同一RVT资产处理非地形Acor与地形的混合。&lt;/li>
&lt;/ul>
&lt;p>完成本指南后，你会更了解：&lt;/p>
&lt;ul>
&lt;li>设置运行时虚拟纹理资产以及它连接到不同组件的方式。&lt;/li>
&lt;li>为地形材质启用运行时虚拟纹理。&lt;/li>
&lt;li>在关卡中设置运行时虚拟纹理体积。&lt;/li>
&lt;li>设置更多Actor以渲染至运行时虚拟纹理。&lt;/li>
&lt;/ul>
&lt;h1 id="项目设置">项目设置
&lt;/h1>&lt;p>使用运行时虚拟纹理前，必须先为项目启用它。执行以下步骤：&lt;/p>
&lt;ol>
&lt;li>在主菜单中，选择 编辑（Edit） 菜单并选择 项目设置（Project Settings）。在 引擎（Engine） &amp;gt; 渲染（Rendering） &amp;gt; 虚拟纹理（Virtual Textures） 类目下，将 启用虚拟纹理支持（Enable Virtual texture support） 设为true。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-1-1-project-settings.png"
width="1335"
height="841"
srcset="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-1-1-project-settings_hu_1b525a045f762b43.png 480w, https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-1-1-project-settings_hu_ad61ae4b957f1e3b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
>&lt;/p>
&lt;ol start="2">
&lt;li>重启 项目。&lt;/li>
&lt;/ol>
&lt;h1 id="创建运行时虚拟纹理资产">创建运行时虚拟纹理资产
&lt;/h1>&lt;p>运行时虚拟纹理 资产包含指定给运行时虚拟纹理体积的RVT资产的配置详情。RVT资产的工作原理是链接场景中需共享数据的材质和其他Actor。&lt;/p>
&lt;ol>
&lt;li>在 内容侧滑菜单 中，利用右键点击快捷菜单或 添加（+Add） 按钮从 纹理（Textures） 类目创建 运行时虚拟纹理 资产。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-content-drawer-add-new-runtime-virtual-texturing-asset.png"
width="612"
height="906"
srcset="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-content-drawer-add-new-runtime-virtual-texturing-asset_hu_64120219a2e20565.png 480w, https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-content-drawer-add-new-runtime-virtual-texturing-asset_hu_c54ac6ca6feb8f6a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="67"
data-flex-basis="162px"
>&lt;/p>
&lt;ol start="2">
&lt;li>为 运行时虚拟纹理 资产命名。在本指南中，命名为 VT_Test。&lt;/li>
&lt;li>双击打开此 运行时虚拟纹理 资产编辑器，以配置其可用属性。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-runtime-virtual-texturing-asset-window.png"
width="960"
height="768"
srcset="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-runtime-virtual-texturing-asset-window_hu_9aa5a3f872bb81ed.png 480w, https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ue5_1-2-1-runtime-virtual-texturing-asset-window_hu_57c88a2caeaa1f65.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="300px"
>&lt;/p>
&lt;p>在此窗口中，你可以定义运行时虚拟纹理（RSV）支持的大小、图块大小和材质属性类型。这些熟悉可以实时调整，并在编辑器中实时查看改动效果。&lt;/p>
&lt;blockquote>
&lt;p>欲知这些设置的详情和用途，参阅虚拟纹理设置页面。&lt;/p>&lt;/blockquote></description></item><item><title>在虚幻引擎中添加全局着色器</title><link>https://zentia.github.io/p/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E7%9D%80%E8%89%B2%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E7%9D%80%E8%89%B2%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E7%9D%80%E8%89%B2%E5%99%A8/ue5-hero.png" alt="Featured image of post 在虚幻引擎中添加全局着色器" />&lt;p>全局着色器（Global Shaders）是不通过材质编辑器创建的着色器。相反，全局着色器使用C++创建，它们在固定的几何体上运行，并且无需与材质或网格体结合。有时候，必须使用更高级的功能才能实现某些外观，为此，有必要自定义着色器通道。&lt;/p>
&lt;p>全局着色器的部分示例包括渲染后期处理效果、分配计算着色器和清空屏幕。&lt;/p>
&lt;h1 id="虚幻着色器文件">虚幻着色器文件
&lt;/h1></description></item><item><title>Actor生命周期</title><link>https://zentia.github.io/p/actor%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/actor%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>&lt;img src="https://zentia.github.io/p/actor%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/ue5-hero.png" alt="Featured image of post Actor生命周期" />&lt;p>本文档大致介绍了Actor的生命周期，其中包括：&lt;/p>
&lt;ul>
&lt;li>如何在关卡中实例化或生成Actor，包括如何初始化Actor。&lt;/li>
&lt;li>如何将Actor标识为PendingKill，然后通过垃圾回收移除或销毁。&lt;/li>
&lt;li>下方流程图展示了如何实例化Actor的主要路径。无论Actor是如何创建的，它们的销毁路径均相同。&lt;/li>
&lt;/ul>
&lt;h1 id="生命周期详解">生命周期详解
&lt;/h1>&lt;p>&lt;img src="https://zentia.github.io/p/actor%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/actorlifecycle1.png"
width="923"
height="1912"
srcset="https://zentia.github.io/p/actor%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/actorlifecycle1_hu_4ed41f252bf8bad9.png 480w, https://zentia.github.io/p/actor%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/actorlifecycle1_hu_b2359199f1e34b31.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="48"
data-flex-basis="115px"
>&lt;/p>
&lt;h1 id="从磁盘加载">从磁盘加载
&lt;/h1>&lt;p>从磁盘加载（Load From Disk）路径适用于已经在关卡中的Actor，如当 UEngine::LoadMap 发生时，或当关卡流送调用 UWorld::AddToWorld 时。&lt;/p></description></item><item><title>CPU Lightmass全局光照</title><link>https://zentia.github.io/p/cpu-lightmass%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/cpu-lightmass%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</guid><description>&lt;img src="https://zentia.github.io/p/cpu-lightmass%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/ue5-hero.png" alt="Featured image of post CPU Lightmass全局光照" />&lt;p>全局光照（Lightmass）创建具有复杂光交互作用的光照图，例如区域阴影和漫反射。它用于预计算具有固定和静态运动型的光源的光照共享部分。&lt;/p>
&lt;p>编辑器和全局光照之间的通信由Swarm Agent处理，它管理本地的光照构建，也可以将光照构建分发到远程机器。默认情况下以最小化方式打开的Swarm Agent还会跟踪光照构建进度，并让你了解哪些机器为你工作，它们在做什么，以及每个机器使用了多少线程。&lt;/p>
&lt;h1 id="静态和固定光源的特性">静态和固定光源的特性
&lt;/h1>&lt;h2 id="漫反射">漫反射
&lt;/h2>&lt;p>漫反射（Diffuse Interreflection）是目前为止视觉上最重要的全局光照效果。在默认情况下，光源以全局光照反射，而材质的基本颜色（BaseColor）项控制有多少光（和什么颜色）向各个方向反射。这种效果有时称为渗色。漫反射是入射光在各个方向上均匀反射，即不受观测方向或位置的影响。&lt;/p>
&lt;p>这里是一个由全局光照创建的场景，只有一个方向的光，且仅显示直接光照。光源无法直接照射的区域是黑色的。这是没有全局光照的结果。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/cpu-lightmass%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/02-lightmass-global-illum-direct-light-only.png"
width="1240"
height="798"
srcset="https://zentia.github.io/p/cpu-lightmass%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/02-lightmass-global-illum-direct-light-only_hu_d6e5eeef116b0c8.png 480w, https://zentia.github.io/p/cpu-lightmass%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/02-lightmass-global-illum-direct-light-only_hu_ac6e2e65a8a2228d.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p></description></item><item><title>HLSL 交叉编译器</title><link>https://zentia.github.io/p/hlsl-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/hlsl-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/hlsl-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/ue5-hero.png" alt="Featured image of post HLSL 交叉编译器" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>引擎中的渲染器模块管理并渲染场景，而场景拥有和每个世界场景相关的可渲染信息。它包括所有绘制规则和着色器的定义。&lt;/p>
&lt;p>RHI 模块是渲染 API 的接口，是图形编程的另一个关键组件。图形编程介绍包含许多可研究的键类、设置和变量，以下子页面包含详细的渲染要点。&lt;/p></description></item><item><title>Lumens技术细节</title><link>https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/</guid><description>&lt;img src="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/ue5-hero.png" alt="Featured image of post Lumens技术细节" />&lt;p>Lumen使用多种光线追踪方法来解决全局光照和反射。首先执行屏幕追踪，然后使用更加可靠的方法。在默认情况下，Lumen通过有向距离场使用 软件光线追踪（Software Ray Tracing） ，同时在启用 硬件光线追踪（Hardware Ray Tracing） 时，在支持的视频显卡上达到更高品质。&lt;/p>
&lt;blockquote>
&lt;p>Lumen的全局光照和反射最初的主要目标是支持在下一代主机上以每秒60帧（FPS）运行的大型开放世界。引擎的 高（High） 可扩展性级别中就包括以60FPS为目标的Lumen设置。&lt;/p>
&lt;p>Lumen的次要关注点就是在下一代主机上以30FPS实现通透的室内光照。引擎的 超高（Epic） 可扩展性级别在下一代主机上能够在8毫秒内以1080p内部分辨率实现全局光照和反射，这个目标依赖&lt;a class="link" href="https://zentia.github.io/p/%E6%97%B6%E9%97%B4%E8%B6%85%E7%BA%A7%E5%88%86%E8%BE%A8%E7%8E%87/" target="_blank" rel="noopener"
>时序超分辨率（TSR）&lt;/a>来输出接近原生4K的画质。&lt;/p>
&lt;p>更多关于Lumen性能的信息，请参阅&lt;a class="link" href="https://zentia.github.io/p/lumens%E6%80%A7%E8%83%BD%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener"
>Lumens性能指南&lt;/a>.&lt;/p>&lt;/blockquote>
&lt;h1 id="表面缓存">表面缓存
&lt;/h1>&lt;p>Lumen生成附近场景表面的自动参数化，这种方法称为 表面缓存（Surface Cache） 。使用这种方法可以快速查找场景中光线接触点的光照。Lumen会从多个角度捕获每个网格体的材质属性。这些捕获位置（即 卡片（Cards） ）是针对每个网格体脱机生成的。&lt;/p>
&lt;p>可以使用控制台命令 &lt;code>r.Lumen.Visualize.CardPlacement 1&lt;/code> 来可视化卡片。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/mesh-card-placement-visualization-alt.png"
width="1340"
height="862"
srcset="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/mesh-card-placement-visualization-alt_hu_ca45ee53b0a17502.png 480w, https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/mesh-card-placement-visualization-alt_hu_690649c6b4c5328f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="373px"
>&lt;/p>
&lt;p>默认情况下，Lumen在一个网格体上放置12个卡，但可以通过在静态网格体编辑器的 构建设置（Build Settings） 中设置 最大Lumen网格体卡片数量（Max Lumen Mesh Cards） 来增加该数量。调整卡的数量对于更复杂的内部或具有不规则形状的单个网格体非常有用。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/static-mesh-editor-max-lumen-mesh-cards-setting.png"
width="541"
height="816"
srcset="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/static-mesh-editor-max-lumen-mesh-cards-setting_hu_93edbb7ce9fed6fe.png 480w, https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/static-mesh-editor-max-lumen-mesh-cards-setting_hu_7cb52ab3768f8d9a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="66"
data-flex-basis="159px"
>&lt;/p>
&lt;p>没有表面缓存覆盖的区域将在关卡编辑器的 表面缓存(Surface Cache) 视图模式中变成粉色。&lt;/p>
&lt;blockquote>
&lt;p>这些区域不会反射光线，在反射过程中显示为黑色。此类问题可以通过增加最大Lumen网格体卡片数量中的卡片数来解决，但可能无法解决所有问题。或者，将网格体分解成不太复杂的几部分也可以解决这类问题。&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/viewmode-lumen-surface-cache.png"
width="605"
height="612"
srcset="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/viewmode-lumen-surface-cache_hu_e417fd8c254ee87b.png 480w, https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/viewmode-lumen-surface-cache_hu_88ba30688906d1ee.png 1024w"
loading="lazy"
alt="视图模式（View Mode） &amp;gt; Lumen &amp;gt; 表面缓存（Surface Cache）"
class="gallery-image"
data-flex-grow="98"
data-flex-basis="237px"
>
&lt;img src="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/lumen-surface-cache-visualization.png"
width="1199"
height="926"
srcset="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/lumen-surface-cache-visualization_hu_885c3c020704d7f2.png 480w, https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/lumen-surface-cache-visualization_hu_6d4fe9f5e54076f8.png 1024w"
loading="lazy"
alt="复杂网格体的Lumen表面缓存可视化（Lumen Surface Cache Visualization of Complex Mesh）"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="310px"
>&lt;/p>
&lt;p>具有视图相关逻辑的材质，例如像素深度、摄像机位置或摄像机矢量，在Lumen表面缓存视图模式下看起来可能不正确。使用这些节点的材质可能使用 光线追踪质量切换（Ray Tracing Quality Switch） 节点来提供采用Lumen表面缓存的材质版本，或为复杂材质而优化表面缓存捕获。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/ray-tracing-quality-switch-node.png"
width="355"
height="125"
srcset="https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/ray-tracing-quality-switch-node_hu_278909caa898f28d.png 480w, https://zentia.github.io/p/lumens%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/ray-tracing-quality-switch-node_hu_c0f656a9a732a6fe.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="284"
data-flex-basis="681px"
>&lt;/p>
&lt;blockquote>
&lt;p>如需详细了解如何使用光线追踪质量切换节点，请参阅光线追踪性能指南。&lt;/p>&lt;/blockquote>
&lt;p>Nanite可以加速用于使表面缓存与三角形场景保持同步的网格体捕获。尤其是多边形网格体，需要使用&lt;a class="link" href="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/" target="_blank" rel="noopener"
>Nanite&lt;/a>进行有效捕获。只有网格体使用了Nanite，才支持植被和实例化的静态网格体组件。&lt;/p></description></item><item><title>动画蓝图</title><link>https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE/ue5-hero.png" alt="Featured image of post 动画蓝图" />&lt;p>动画蓝图 是一种特殊的 蓝图，它用于在游戏中控制 骨骼网格体 的动画效果。动画蓝图编辑器（Animation Blueprint Editor） 中的 图表（Graphs） 可以效果动画，允许你直接控制骨架的骨骼，或设置骨骼网格体逐帧逻辑，以便创建最终动画姿势。&lt;/p></description></item><item><title>动态分辨率</title><link>https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/ue5-hero.png" alt="Featured image of post 动态分辨率" />&lt;p>动态分辨率可根据先前画面的GPU工作负载调节主要屏幕百分比。分辨率是基于启发法（按需要）调节的，例如，如果在屏幕上有太多Object，或者有成本高昂的效果突然进入画面，GPU渲染时间将会延长，此时为了维持目标珍露就会降低屏幕分辨率。&lt;/p>
&lt;h1 id="启用动态分辨率">启用动态分辨率
&lt;/h1>&lt;h2 id="在运行时启用动态分辨率">在运行时启用动态分辨率
&lt;/h2>&lt;p>动态分辨率可以通过在 Game User Settings 节点上获取一个布尔数值来启用。你可以在使用蓝图或C++时设置它。&lt;/p>
&lt;p>在 蓝图 中，你可以使用 Game User Settings 节点选择此功能来启用动态分辨率，如下图：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/dynamicresblueprint.png"
width="1405"
height="397"
srcset="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/dynamicresblueprint_hu_2999e788d01f08d0.png 480w, https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/dynamicresblueprint_hu_a22a5d9e60b063e5.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="353"
data-flex-basis="849px"
>&lt;/p>
&lt;p>在 C++ 中，你可以在 UGameUserSettings 设置如下布尔值：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">GEngine&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">GetDynamicResolutionStatus&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetEnabled&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>将 SetEnabled 设置为 false 可将其禁用。&lt;/p>
&lt;blockquote>
&lt;p>在实际启用或禁用动态分辨率时，游戏线程逻辑掌握最终程序控制权限，所以如果你是用蓝图在运行时启动它，这会优先于代码设置。要将游戏用户设置恢复到初始状态，请使用以下命令行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GEngine-&amp;gt;GameUserSettings-&amp;gt;ApplyNonResolutionSettings();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/blockquote>
&lt;h2 id="使用运算模式控制动态分辨率">使用运算模式控制动态分辨率
&lt;/h2>&lt;p>你可以使用 &lt;strong>运算模式（Operation Mode）&lt;/strong> 设置如何在游戏中覆盖和使用动态分辨率，设置在游戏中覆盖它和使用它的方式。为了控制这种模式，在项目所对应平台（Xbox One、PlayStation 4等）的平台配置描述（或设备描述）中，你可以使用下列控制台命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.DynamicRes.OperationMode
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用下列数值之一来设置运算模式如何针对项目的平台工作：&lt;/p>
&lt;ul>
&lt;li>根据游戏用户设置状态（在C++或蓝图中设置）启用动态分辨率。&lt;/li>
&lt;li>无论游戏用户设置状态如何都启用动态分辨率。&lt;/li>
&lt;/ul>
&lt;p>启用动态分辨率后，下列控制台变量会设置屏幕百分比的最大值和最小值，以及在降低分辨率之前任何给定帧的最大预算。如果你不设置，这些变量都有默认值：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制台变量&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.DynamicRes.MinScreenPercentage&lt;/td>
&lt;td>50&lt;/td>
&lt;td>设置要使用的最小屏幕百分比。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.DynamicRes.MaxScreenPercentage&lt;/td>
&lt;td>100&lt;/td>
&lt;td>设置用于分配渲染目标的最大主要屏幕百分比。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.DynamicRes.FrameTimeBudget&lt;/td>
&lt;td>33.3&lt;/td>
&lt;td>设置帧预算（以毫秒为单位）。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>你可以使用Unreal Engine中的&amp;quot;设备描述（Device Profiles）&amp;ldquo;窗口设置和管理配置文件。可以通过&amp;quot;文件（File）&amp;ldquo;菜单选择 编辑（Edit）&amp;gt; Developer Tools（开发者工具）&amp;gt; Device Profiles（设备描述） 来访问此窗口。&lt;/p>&lt;/blockquote>
&lt;h2 id="暂停和恢复动态分辨率">暂停和恢复动态分辨率
&lt;/h2>&lt;p>有时你可能需要为项目启用动态分辨率，但你又不想对主大厅之类的区域启用。动态分辨率可以随运作模式暂停和恢复。下列控制台变量可用于设置动态分辨率的运算模式：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.DynamicRes.OperationMode
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>禁用（默认）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>根据GameUserSettings中使用的设置启用。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>无论GameUserSettings中的设置如何都会启用。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>下表概括了当启用或禁用特定运算模式时可用的不同状态，以及GameUserSettings所受的影响：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Game User Settings = False&lt;/th>
&lt;th>&lt;/th>
&lt;th>Game User Settings = True&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>暂停&lt;/td>
&lt;td>不暂停&lt;/td>
&lt;td>暂停&lt;/td>
&lt;td>不暂停&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OperationMode=0&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OperationMode=1&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OperationMode=2&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 C++ 中，你可以使用下列函数控制和检查动态分辨率的状态：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>操作&lt;/th>
&lt;th>C++函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>暂停&lt;/td>
&lt;td>GEngine-&amp;gt;PauseDynamicResolution();&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>恢复&lt;/td>
&lt;td>GEngine-&amp;gt;ResumeDynamicResolution();&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>检查状态（禁用/启用或暂停）&lt;/td>
&lt;td>GEngine-&amp;gt;GetDynamicResolutionStatus();&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="动态分辨率巡航">动态分辨率巡航
&lt;/h1>&lt;p>在虚幻引擎中，动态分辨率功能的实现与以前其他引擎中同类功能有所不同，因为我们允许分辨率根据需要在一个给定的范围内变化，而不是限制为单一的分辨率（1080p、900p、720p）。在这张示例图中，此模型演示了控制台变量所控制的对象。它演示了当一切都运行顺利、没有超过给定帧的预算时，动态分辨率是如何在给定范围（3）中自动调节的。可以把这个范围想象为飞机的巡航高度，飞机在这一高度范围可以自由机动，以实现到达目的地的理想速度。和飞机一样，分辨率也可以根据需要上下调节，从而在分辨率和充足的性能之间保持良好的平衡。&lt;/p>
&lt;blockquote>
&lt;p>这个模型是用于演示的，没有考虑在给定场景中发生的所有情况。例如，它没有体现GPU不与CPU同步会是什么情况，甚至也没有体现启发法正确估算出分辨率应该变化多少的情况。它的目的是清晰地演示&amp;quot;理想&amp;quot;情况，从而展现动态分辨率控制态变量的运算方式。&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/framegpugraph.png"
width="1694"
height="826"
srcset="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/framegpugraph_hu_c4adeb21008ffde8.png 480w, https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/framegpugraph_hu_248532d90ebc0f3c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="205"
data-flex-basis="492px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参考号&lt;/th>
&lt;th>控制台变量&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>r.DynamicRes.FrameTimeBudget&lt;/td>
&lt;td>以毫秒（ms）计的帧时间预算。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>r.DynamicRes.TargetedGPUHeadRoom&lt;/td>
&lt;td>在超出预算前可供GPU增加的余量（按帧预算的百分比计）。这很可能要取决于发布平台或根据启用的渲染功能而定。例如，动态模糊需要另外留出成本余量用于摄像机的快速旋转运动。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>r.DynamicRes.ChangePercentageThreshold&lt;/td>
&lt;td>为了实际调整分配大小，在屏幕百分比中需要的最小变化。如果不想经常在非常相近的分辨率大小之间变换，可以利用此变量。如果它的数值过小，分辨率最终可能还是会经常改变，而如果它过大，可能会增加超出GPU预算的风险。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>r.DynamicRes.MinResolutionChangePeriod&lt;/td>
&lt;td>在允许进行任何分辨率更改之前，必须达到的最小帧数。此命令有多种用途。这包括提高启发法在给定主要屏幕百分比下排除测量噪点模拟GPU消耗的可靠性，避免可能在逐帧偏移抖动之间发生的时序上采样的输入样本偏移干扰，以及更改可能造成抗锯齿发散的分辨率。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果你的瓶颈是在CPU而非GPU，还可以使用下列控制台变量调节用于动态分辨率的启发法历史记录和要使用的屏幕百分比：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制台变量&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.DynamicRes.HistorySize&lt;/td>
&lt;td>启发法帧历史记录中的帧数。如果历史记录过短，可能包含过多噪点，影响可靠性；而如果历史记录过长，调节延迟可能会非常严重。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.DynamicRes.CPUBoundScreenPercentage&lt;/td>
&lt;td>当你遇到CPU瓶颈时应该瞄准的主要屏幕百分比。如果平台上的CPU和GPU共享相同的内存带宽，可以用它设置较低的屏幕百分比来降低分辨率。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="超预算应急">超预算应急
&lt;/h2>&lt;p>如果你发现动态分辨率会非常迅速地超出预算，例如在镜头切换时或者成本高昂的视觉效果出现时，那就说明使用的启发法实际上无法预测这种情况何时会发生。在这类情况确实发生时，可以使用某种&amp;quot;应急&amp;quot;按钮快速降低分辨率，从而减少超出预算的帧数。如果启发法发现有N（一定数量）个连续帧的可用GPU时间超出预算，它将会立即调整分辨率来应对这些超预算时间。它还会自动执行历史记录重置，使得先前成本较低的帧时间不会影响启发法对成本较高的帧的判断。&lt;/p>
&lt;p>请使用下列控制台命令来控制在启用&amp;quot;应急&amp;quot;开关降低分辨率之前可以出现的超GPU预算的连续帧数：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.DynamicRes.MaxConsecutiveOverbudgetGPUFrameCount
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在此图中，画面中突然发生跳跃，因此有两个以上的连续帧超过了设定的33.3毫秒的预算。系统激活了应急开关来快速降低分辨率，使得后续帧不再超出预算。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/overbudgetpanicgraph.png"
width="1019"
height="879"
srcset="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/overbudgetpanicgraph_hu_88c9a253e65af047.png 480w, https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E5%88%86%E8%BE%A8%E7%8E%87/overbudgetpanicgraph_hu_9710b4667aba4be0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="278px"
>&lt;/p>
&lt;ol>
&lt;li>超出预算的最大连续GPU帧数。&lt;/li>
&lt;li>从检测到GPU导致分辨率变化为止未与渲染线程同步的帧延迟。&lt;/li>
&lt;li>发生紧急情况检测，引发帧率下降。&lt;/li>
&lt;li>一定数量的帧发生分辨率更改。&lt;/li>
&lt;/ol>
&lt;h1 id="支持动态分辨率的平台">支持动态分辨率的平台
&lt;/h1>&lt;p>支持以下平台&lt;/p>
&lt;ul>
&lt;li>微软的Xbox One、Xbox Series S和Xbox Series X&lt;/li>
&lt;li>PlayStation 4 和 PlayStation 5 （不包括PSVR）&lt;/li>
&lt;li>Nintendo Switch&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>针对不在此白名单中的平台启用动态分辨率支持是很危险的，可能造成意外后果。这类后果包括GPU时间错误，这可能使分辨率不必要地下降，或者分辨率提高过多，发生丢帧。这最终可能毁掉Gameplay体验。默认情况下，引擎不允许你在此白名单中的平台上使用动态分辨率。&lt;/p>&lt;/blockquote></description></item><item><title>泛光</title><link>https://zentia.github.io/p/%E6%B3%9B%E5%85%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B3%9B%E5%85%89/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/randg_herobanner.png" alt="Featured image of post 泛光" />&lt;p>泛光（Bloom）是一种真实世界中的光现象，通过它能够以较为适度的渲染性能成本极大地渲染图像的真实感。用肉眼观察黑暗背景下非常明亮的物体时会看到泛光效果。亮度更高的物体还会造成其他效果（条纹、镜头光斑），但这些效果不在经典的泛光效果范畴内。我们的显示器（电视、TFT屏等）通常不支持HDR（高动态范围），因此实际上无法渲染太亮的物体。于是我们模拟了当光线射到胶片（胶片次表面散射）或摄像机（乳白色玻璃滤光片）时眼睛中出现的效果（视网膜的次表面散射）。这种效果不一定符合实际清空，但它可以帮助表现对象的相对亮度，或者给屏幕上显示的LDR（地动态范围）图像添加真实感。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom.png"
width="1174"
height="523"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_hu_a99ee83ad225010.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_hu_93b1c8b33470498.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>&lt;/p>
&lt;p>泛光可以用一个高斯模糊来实现。为了提高质量，我们将多个不同半径的高斯模糊组合起来。为了获得更好的性能，我们在大大降低的分辨率下 进行很宽范围的模糊。在UE 3中，高斯模糊的分辨率为1/4、1/8和1/16。而现在我们可以使用多种模糊，分辨率从1/2（Blur1）到1/32（Blur5）。&lt;/p>
&lt;p>通过改变模糊效果的组合方式，我们可以进行更多的控制，取得更高的质量。为了获得最佳的性能，应该使用高分辨率模糊（小值）来实现较窄的模糊，而主要使用低分辨率模糊 （大值）实现较宽的模糊。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>强度（Intensity）&lt;/td>
&lt;td>线性调节整个泛光效果的颜色。可用于：随着时间的推移淡入或淡出，变暗。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>阈值（Threshold）&lt;/td>
&lt;td>定义了单一颜色需要多少亮度单位才能产生泛光。除了阈值之外，还有一个线性部分（1个单位宽度），其中的颜色仅部分地影响泛光。如果希望场景中的所有颜色都参与泛光效果，需要使用数值-1。可用于：对某些不真实的HDR内容、梦序进行调整。详见下方示例&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>着色&lt;/td>
&lt;td>修改每个泛光的亮度和颜色。如果你使用黑色，尽管不会使得渲染速度加快，但也是可以的。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="强度">强度
&lt;/h2>&lt;p>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_0_small.png"
width="368"
height="164"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_0_small_hu_fbc3c0399d45e259.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_0_small_hu_12e802d250a67252.png 1024w"
loading="lazy"
alt="0.0"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>
&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_1_small.png"
width="368"
height="164"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_1_small_hu_f50d0a5f8df30725.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_1_small_hu_114d0fc33ab53539.png 1024w"
loading="lazy"
alt="1.0"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>
&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_5_small.png"
width="370"
height="165"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_5_small_hu_2183bfba471a2559.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_intensity_5_small_hu_3dab3d1504bd7aab.png 1024w"
loading="lazy"
alt="5.0"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_tint_1_small.png"
width="220"
height="98"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_tint_1_small_hu_2d89569f7645e8fe.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/bloom_tint_1_small_hu_2209f02f1bca9187.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="538px"
>&lt;/p>
&lt;h1 id="泛光卷积">泛光卷积
&lt;/h1>&lt;p>使用泛光 卷积（Convolution） 效果可以添加自定义泛光内核形状，其纹理能够展现逼真的泛光效果。 它利用内核图像对源图像进行卷积运算，以此来模拟摄像机或人眼中光线的散射和衍射。&lt;/p>
&lt;p>内核表示光学设备对视野中间的单点源的响应。源中的每个像素按照内核图像的指示 将其部分亮度贡献给相邻像素。源像素越亮，生成的泛光越明显。究其根本而言，这种能量守恒散射可以转化为卷积运算公式， 并通过使用快速傅里叶变换（FFT）加速。&lt;/p>
&lt;blockquote>
&lt;p>泛光卷积专门用于游戏内过场动画、离线过场动画，或在高端硬件中使用，但 标准 泛光 可用于大多数游戏应用程序。 就利弊而言，标准泛光在性能方面具有明显优势，但它并不稳妥（它会导致图像整体变得更亮）， 并且无法赶上泛光卷积的视觉复杂性。&lt;/p>&lt;/blockquote>
&lt;p>要启用&amp;quot;泛光卷积（Bloom Convolution）&amp;quot;，请在&amp;quot;后期处理体积（Post Process Volume）&amp;ldquo;的 镜头（Lens） 部分中，使用 方法（Method） 旁边的选择框选择 卷积（Convolution）。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/convolution-bloom-settings.png"
width="482"
height="341"
srcset="https://zentia.github.io/p/%E6%B3%9B%E5%85%89/convolution-bloom-settings_hu_a7b88a9c59d0a6ed.png 480w, https://zentia.github.io/p/%E6%B3%9B%E5%85%89/convolution-bloom-settings_hu_626e115a966ebd4.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="339px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>卷积内核（Convolution Kernel）&lt;/td>
&lt;td>用于选择定义内核的纹理。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>卷积缩放（Convolution Scale）&lt;/td>
&lt;td>表示以视口为单位的卷积内核图像的相对大小。默认值为1。主要用于减少泛光的大小。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="内核图像最佳实践">内核图像最佳实践
&lt;/h2>&lt;p>基于图像的卷积之所以能产生额外的真实感，是因为它能够使用视觉上很有趣的非对称内核图像。当 创建内核并将其设置用于泛光卷积时，需要注意一些事项。&lt;/p></description></item><item><title>高动态范围显示输出</title><link>https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/ue5_1-rendering-hero-banner-5-0.png" alt="Featured image of post 高动态范围显示输出" />&lt;p>你可以输出到高动态范围（HDR）显示器，以充分利用更高的对比度和更宽的色域等功能！其目标是使显示的图像具有的特性更类似于&amp;quot;现实世界&amp;quot;中所经历的自然光条件。这是转向 学院色彩编码系统（ACES）标准行动的一部分，该标准是一个确保在多种格式和显示器上保持色彩一致性的管线，也是一种确保所用源材质 不会过时 且无需针对其他介质进行调整的方法&lt;/p>
&lt;p>在当前实现下，渲染场景的完整处理通过 ACES Viewing Transform 进行处理。此流程的工作原理是使用&amp;quot;参考场景的&amp;quot;和&amp;quot;参考显示的&amp;quot;图像。&lt;/p>
&lt;ul>
&lt;li>参考场景的 图像保有源材质的原始 线性光照 数值，不限制曝光范围。&lt;/li>
&lt;li>参考显示的 图像是最终的图像，将变为所用显示的色彩空间。&lt;/li>
&lt;/ul>
&lt;p>使用此流程后，初始源文件用于不同显示时便无需每次进行较色编辑。相反，输出的显示将映射到正确的色彩空间。&lt;/p>
&lt;p>ACES Viewing Transform在查看流程中将按以下顺序进行：&lt;/p>
&lt;ul>
&lt;li>Look Modification Transform (LMT) - 这部分抓取应用了创意&amp;quot;外观&amp;quot;（颜色分级和矫正）的ACES颜色编码图像，输出由ACES和Reference Rendering Transform（RRT）及Output Device Transform（ODT）渲染的图像。&lt;/li>
&lt;li>Reference Rendering Transform (RRT) - 之后，这部分抓取参考场景的颜色值，将它们转换为参考显示。 在此流程中，它使渲染图像不再依赖于特定显示器，反而能保证它输出到特定显示器时拥有正确而宽泛的色域和动态范围（尚未创建的图像同样如此）。&lt;/li>
&lt;li>Output Device Transform (ODT) - 最后，这部分抓取RRT的HDR数据输出，将其与它们能够显示的不同设备和色彩空间进行比对。 因此，每个目标需要将其自身的ODT与Rec709、Rec2020、DCI-P3等进行比对。&lt;/li>
&lt;/ul>
&lt;h1 id="启用hdr输出">启用HDR输出
&lt;/h1>&lt;p>开启控制台变量或使用蓝图中的 GameUserSettings 节点即可启用运行时的HDR输出。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/ue5_1-high-dynamic-range-display-game-user-settings.png"
width="1065"
height="267"
srcset="https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/ue5_1-high-dynamic-range-display-game-user-settings_hu_97a1851f6f77c11c.png 480w, https://zentia.github.io/p/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/ue5_1-high-dynamic-range-display-game-user-settings_hu_6fa3a4726d26c1b1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="398"
data-flex-basis="957px"
>&lt;/p>
&lt;p>Game User Settings 控制将自动锁定当前可用的最接近输出设备，并相应设置全部标记。 另外，还可使用以下控制台变量启用并对HDR设备和色域输出所需的可用选项进行修改。&lt;/p>
&lt;h1 id="hdr-中的低动态范围ldrui支持">HDR 中的低动态范围（LDR）UI支持
&lt;/h1>&lt;p>启用HDR输出后，用户界面（UI）可能出现显示问题。 因此虚幻引擎新增了实验性的LDR UI合成支持。 它将尝试尽量匹配LDR的外观。 推荐对UI稍微进行增强，以免和鲜艳主场景相比之下显得黯淡。&lt;/p></description></item><item><title>骨骼网格体Actor</title><link>https://zentia.github.io/p/%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93actor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93actor/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93actor/ue5-hero.png" alt="Featured image of post 骨骼网格体Actor" />&lt;p>骨骼网格体Actor（Skeletal Mesh Actor） 显示动画网格体，其几何体可以变形，通常是通过使用动画序列期间的控制点来变形。这些Actor可以从外部3D动画应用程序创建和导出，也可以直接在虚幻引擎中编程来实现。&lt;/p></description></item><item><title>管理多个关卡</title><link>https://zentia.github.io/p/%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%E5%85%B3%E5%8D%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%E5%85%B3%E5%8D%A1/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%E5%85%B3%E5%8D%A1/ue5-hero.png" alt="Featured image of post 管理多个关卡" />&lt;p>在 虚幻引擎（Unreal Engine） 4旧版项目或非游戏项目（例如建筑可视化）上工作时，你可以使用 关卡（Levels） 窗口进行关卡管理。对于虚幻引擎5.0及更高版本中的游戏开发， 关卡（Levels） 窗口被世界分区废弃。本页面涵盖了如何通过 关卡（Levels） 窗口管理多个关卡。&lt;/p></description></item><item><title>管理内容</title><link>https://zentia.github.io/p/%E7%AE%A1%E7%90%86%E5%86%85%E5%AE%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%AE%A1%E7%90%86%E5%86%85%E5%AE%B9/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%AE%A1%E7%90%86%E5%86%85%E5%AE%B9/content_topic.png" alt="Featured image of post 管理内容" />&lt;h1 id="本地化">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/localizing-content-in-unreal-engine" target="_blank" rel="noopener"
>本地化&lt;/a>
&lt;/h1></description></item><item><title>基于物理的材质</title><link>https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/ue5-hero.png" alt="Featured image of post 基于物理的材质" />&lt;h1 id="基于物理是什么意思">基于物理是什么意思？
&lt;/h1>&lt;p>基于物理的渲染（Physically based rendering） (PBR)意味着表面接近光线在真实世界的表现方式，而不是我们直观以为的应有方式。 相较于完全依赖美术师直觉来设置参数的着色工作流程，遵守PBR原则的材质更准确，并且通常看起来更自然。&lt;/p>
&lt;p>基于物理的材质在所有光照环境中都能有同等程度的良好表现。 此外，材质值的复杂程度和相互依赖程度可以降低，这样材质创建工作流程对于用户更加友好。 这些优点甚至适用于非真实感渲染，正如Pixar [4]和Disney [3]的电影中所展现的那样。&lt;/p>
&lt;blockquote>
&lt;p>要对虚幻引擎的基于物理的材质和着色模型进行一番深入的技术考察，请参阅此SIGGRAPH演示2。&lt;/p>&lt;/blockquote>
&lt;h1 id="pbr材质属性">PBR材质属性
&lt;/h1>&lt;p>这些是与虚幻材质的基于物理的方面直接相关的材质属性。&lt;/p>
&lt;ul>
&lt;li>基础颜色&lt;/li>
&lt;li>粗糙度&lt;/li>
&lt;li>金属感&lt;/li>
&lt;li>高光度&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>所有这些输入都设计为接受0到1之间的值。对于基础颜色，这意味着RGB值在0到1之间的颜色或纹理取样。&lt;/p>&lt;/blockquote>
&lt;h2 id="基础颜色">基础颜色
&lt;/h2>&lt;p>基础颜色定义了材质的总体颜色。 &amp;ldquo;基础颜色&amp;quot;输入接受 Vector3 (RGB) 值，其中每个通道自动限制在0到1之间。&lt;/p>
&lt;h2 id="粗糙度">粗糙度
&lt;/h2>&lt;p>&amp;ldquo;粗糙度&amp;quot;输入控制了材质表面有多粗糙或光滑。 在材质中，这表现为反射在材质上看起来有多尖锐或模糊。&lt;/p>
&lt;p>粗糙材质会沿比光滑材质更多的方向反射光线，这样产生的是漫反射，有时很细微。光滑表面会更均匀地反射光线，这样产生的是清晰、集中的反射或镜面高光。&lt;/p>
&lt;ul>
&lt;li>粗糙度为0（光滑）会产生镜面反射。&lt;/li>
&lt;li>粗糙度为1（粗糙）会产生漫反射或无光泽的表面。&lt;/li>
&lt;/ul>
&lt;h3 id="映射粗糙度">映射粗糙度
&lt;/h3>&lt;p>粗糙度经常在使用灰阶纹理的对象上映射，以向表面添加物理变体。 粗糙度贴图上的深色区域在材质上看起来像镜子，而浅色区域则比较粗糙，看起来反射度较低。&lt;/p>
&lt;h3 id="粗糙度与高光度">粗糙度与高光度
&lt;/h3>&lt;p>高光度（Specularity） 指的是表面反射的&lt;a class="link" href="https://zh.wikipedia.org/wiki/%E9%8F%A1%E9%9D%A2%E5%8F%8D%E5%B0%84" target="_blank" rel="noopener"
>高光（specular light）&lt;/a>量。 此值是材质类型所固有的，通常默认值0.5是准确的。&amp;ldquo;高光度&amp;quot;输入 不用于反射/高光度贴图 或添加表面变体。 这些应该在&amp;quot;粗糙度&amp;quot;贴图中进行处理。&lt;/p>
&lt;h2 id="金属感">金属感
&lt;/h2>&lt;p>&amp;ldquo;金属感&amp;quot;输入接受0到1之间的值，并定义你的材质是作为金属还是非金属表现。&lt;/p>
&lt;p>在大多数情况下，你应该将&amp;quot;金属感&amp;quot;视为虚幻引擎中的二进制属性。 对于纯表面（例如纯金属、纯岩石、纯塑料，等等），你应该将&amp;quot;金属感&amp;quot;设置为 0或1，而不是中间值。创建被腐蚀、有灰尘或生锈的金属之类的混合表面时，你可能发现你需要0到1之间的某个值。&lt;/p>
&lt;ul>
&lt;li>非金属 的&amp;quot;金属感&amp;quot;值为0。这是默认值。&lt;/li>
&lt;li>金属 的&amp;quot;金属感&amp;quot;值为1。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/metallic.png"
width="720"
height="81"
srcset="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/metallic_hu_b62326da99e0f43e.png 480w, https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/metallic_hu_888982c8fee1cd5.png 1024w"
loading="lazy"
alt="0到1的&amp;#34;金属感&amp;#34;值"
class="gallery-image"
data-flex-grow="888"
data-flex-basis="2133px"
>&lt;/p>
&lt;blockquote>
&lt;p>你可能起初不愿意将材质设置为完全的金属感。除非你有充足理由，否则尽量不要使用小数值。&lt;/p>&lt;/blockquote>
&lt;h3 id="映射金属感">映射金属感
&lt;/h3>&lt;p>相同材质中往往金属和非金属都有。 假设一个金属面板，其中油漆涂层覆盖了部分或全部金属。&lt;/p>
&lt;p>油漆是非金属，因此在油漆覆盖的所有区域中，&amp;ldquo;金属感&amp;quot;值应该为0。 在面板中看得到金属的所有地方，&amp;ldquo;金属感&amp;quot;值应该为1。&lt;/p>
&lt;p>这应该使用传递到&amp;quot;金属感&amp;quot;输入的黑白遮罩进行处理。 油漆没有与金属混合，而是位于其上方。 你的&amp;quot;金属感&amp;quot;贴图不应包含中间灰阶值，只能包含黑色和白色。 你还可以使用材质层实现类似结果。&lt;/p>
&lt;h2 id="高光度">高光度
&lt;/h2>&lt;p>&amp;ldquo;高光度&amp;quot;输入接受0到1之间的值，并控制表面反射多少高光。&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;高光度&amp;quot;值为0表示完全不反射。&lt;/li>
&lt;li>&amp;ldquo;高光度&amp;quot;值为1表示完全反射。&lt;/li>
&lt;/ul>
&lt;p>虚幻引擎使用 默认高光度0.5 ，这表示大约4%的高光度反射。 对于绝大多数材质，此值是准确的。&lt;/p>
&lt;blockquote>
&lt;p>对于漫反射程度很高的材质，你可能倾向于将此值设置为0。别这样做！所有材质多有高光度，请参阅此帖子以了解示例[5]。制作漫反射程度很高的材质的正确方法是使用很高的&amp;quot;粗糙度&amp;quot;值。&lt;/p>&lt;/blockquote>
&lt;h2 id="空腔贴图">空腔贴图
&lt;/h2>&lt;p>修改&amp;quot;高光度&amp;quot;的一个原因是添加微型遮蔽区或小尺度阴影，比如从法线贴图中表示的裂口添加。这些有时被称为空腔。 小尺度的几何体（尤其是仅存在于高精度多边形中并烘焙到法线贴图中的细节）不会被渲染器的实时阴影选取。&lt;/p>
&lt;p>要捕获此阴影，你可以生成空腔贴图，它通常是追踪距离非常短的AO贴图。这会乘以输出之前的最终&amp;quot;基础颜色&amp;rdquo;，并乘以0.5（&amp;ldquo;高光度&amp;quot;默认值）作为&amp;quot;高光度&amp;quot;输出。&lt;/p>
&lt;p>确切地说，就是：基础颜色=空腔旧基础颜色，高光度=空腔0.5。&lt;/p>
&lt;p>在高级用途中，这一步可以用于控制折射率(IOR)。我们发现这对于99%的材质都不是必需的。下面是基于测量的IOR的&amp;quot;高光度&amp;quot;值。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/measured_materials.png"
width="720"
height="437"
srcset="https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/measured_materials_hu_3bf4bbac4b7cc802.png 480w, https://zentia.github.io/p/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%9D%90%E8%B4%A8/measured_materials_hu_67ab564e3017cf98.png 1024w"
loading="lazy"
alt="测量的材质示例。顶部：木炭、新混凝土、旧沥青。底部：铜、铁、金、铝、银、镍、钛"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p></description></item><item><title>可视性和遮挡剔除参考</title><link>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E5%8F%82%E8%80%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E5%8F%82%E8%80%83/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E5%8F%82%E8%80%83/ue5-hero.png" alt="Featured image of post 可视性和遮挡剔除参考" />&lt;p>本页面包含虚拟纹理系统的要求、设置、控制台命令的相关信息。&lt;/p>
&lt;h1 id="流送虚拟纹理设置">流送虚拟纹理设置
&lt;/h1>&lt;p>以下为用于设置和处理流送虚拟纹理的设置和属性。&lt;/p></description></item><item><title>时序上采样器</title><link>https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/ue5-hero.png" alt="Featured image of post 时序上采样器" />&lt;p>时序上采样器（Temporal Upscalers） 使用来自当前和之前帧的数据来产生高质量的增强结果。 无论是虚幻引擎4的Temporal Anti-Aliasing Upscaling (TAAU)、虚幻引擎5的Temporal Super Resolution，还是诸如NVIDIA的DLSS 2+ Super Resolution、AMD的FSR 2.0+和Intel的XeSS等第三方插件，时序上采样器都在虚幻引擎里以相同方式运作。它们都在同一位置插入后期处理链&amp;ndash;在景深和动态模糊之间。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/8-pipeline-tsr.png"
width="1078"
height="308"
srcset="https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/8-pipeline-tsr_hu_12ff33fc38a98b0d.png 480w, https://zentia.github.io/p/%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7%E5%99%A8/8-pipeline-tsr_hu_909ab58fec84c7ed.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="350"
data-flex-basis="840px"
>&lt;/p>
&lt;p>无论使用哪种时序上采样器，渲染分辨率都是由Screen Percentage，或在支持时同时由Dynamic Resolution来控制。&lt;/p></description></item><item><title>使用查找表（LUT）进行颜色校正</title><link>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/ue5_1-rendering-hero-banner-5-0.png" alt="Featured image of post 使用查找表（LUT）进行颜色校正" />&lt;p>可以利用 查找表（LUT）来实现使用后期处理体积的颜色校正。 不要使用三个一维（1D）查找表，而应该使用一个三维（3D）查找表。 这样可以提供更精细的色彩变换，从而可用于去饱和度之类的用途。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1_hu_ab67779999497148.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1_hu_e289048aa8ff7c11.png 1024w"
loading="lazy"
alt="中性色调LUT"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_sepia.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_sepia_hu_15f4a5f79c4d41a8.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_sepia_hu_1462e5c68f13812e.png 1024w"
loading="lazy"
alt="棕褐色调LUT"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>&lt;/p>
&lt;p>虚幻引擎中使用的一种查找表是16x16x16的中性色调LUT，解压后为256x16的纹理。 这些示例显示了中性色调和棕褐色调的LUT。 如果要应用中性色调LUT，你将不会看到默认场景有任何变化，但是如果使用棕褐色调的LUT，就会看到类似于下图这样的情况：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1.png"
width="1336"
height="923"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_84ebf4216f5e03b7.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_fb114baba6d55fdb.png 1024w"
loading="lazy"
alt="中性色调LUT"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut4.png"
width="1336"
height="923"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut4_hu_36ddbb63ab9b95e3.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut4_hu_660280c302dc0877.png 1024w"
loading="lazy"
alt="棕褐色调LUT"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;h1 id="使用lut纹理">使用LUT纹理
&lt;/h1>&lt;p>要使用LUT，请使用下列属性将LUT纹理分配到要搭配它使用的后期处理体积并调整它的强度。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>颜色分级LUT强度（Color Grading LUT Intensity）&lt;/td>
&lt;td>一种控制颜色校正效果的比例因子。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>颜色分级LUT&lt;/td>
&lt;td>用作颜色校正的查找表的LUT纹理。 详见下方示例&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="颜色分级lut">颜色分级LUT
&lt;/h2>&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_none.png"
width="1311"
height="866"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_none_hu_e65d2b41ad8552a0.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_none_hu_e3f7bdb7873e7b8e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_green.png"
width="1311"
height="866"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_green_hu_12584ece67fbdec0.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_green_hu_48d2eaf1bc33ad38.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_red.png"
width="1311"
height="866"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_red_hu_ac881720ecd7af54.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_red_hu_1e825931915799c3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1_hu_ab67779999497148.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/rgbtable16x1_hu_e289048aa8ff7c11.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_greenish.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_greenish_hu_9df8746fa4e2af14.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_greenish_hu_bab230f15d2d39a8.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_reddish.png"
width="256"
height="16"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_reddish_hu_78472e19df8ffd97.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut_reddish_hu_1ca2d2687a30f999.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1600"
data-flex-basis="3840px"
>&lt;/p>
&lt;h1 id="创建自己的lut纹理">创建自己的LUT纹理
&lt;/h1>&lt;p>要创建你自己的LUT纹理，首先需要一个能够对捕获的图像进行颜色调整的图像编辑应用程序（例如Photoshop或GIMP）。 在这个演示中， 我们将使用在Epic Games启动程序中的 学习（Learn） 选项卡中提供的 Sun Temple 项目，并选择Photoshop作为LUT图像编辑应用程序。 在这个示例中使用的某些术语可能是 Photoshop特有的。&lt;/p>
&lt;ol>
&lt;li>首先对你也要应用颜色校正的场景截取至少一张有代表性的屏幕截图。 可以使用编辑器中提供的 截图工具来截取场景的高分辨率图像。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1.png"
width="1336"
height="923"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_84ebf4216f5e03b7.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_fb114baba6d55fdb.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;ol start="2">
&lt;li>在Photoshop中打开该屏幕截图，然后从右侧图层（Layers）面板上方的调整（Adjustments）选项卡添加你自己的 调整 图层。 在这里可以找到许多不同的图标，分别代表可以对图像执行的各种更改类型，例如亮度和对比度、色调、饱和度，等等。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut2.png"
width="1800"
height="975"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut2_hu_2ddc9bbb20d91632.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut2_hu_262f3bb5571fc7ad.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;ol start="3">
&lt;li>在 调整（Adjustments） 面板中，单击任何图标以向图层（Layers）面板添加图层。 可以使用这些图层对最终图像作特定的颜色校正。 在此示例中， 已经添加和调整了 Vibrance 和 亮度/对比度（Brightness/Contrasts）。 将这些图层添加到图层（Layers）面板之后，从列表中选择它们以公开它们的属性，如果看不到属性， 可以右键单击并选择 编辑调整（Edit Adjustment） 来公开它们。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3.png"
width="734"
height="479"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3_hu_c3ebae96aecae360.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3_hu_87569d5eaa72a3a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="153"
data-flex-basis="367px"
>&lt;/p>
&lt;ol start="4">
&lt;li>你进行的任何调整都可以显示在视口中。 请调整调整图层的属性，直到获得想要的颜色校正效果为止。 在下面的示例中，已经调整了 Vibrance和亮度/对比度（Brightness/Contrasts）的调整图层属性，使屏幕截图的颜色饱和度和清晰度更高，更有视觉吸引力。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1.png"
width="1336"
height="923"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_84ebf4216f5e03b7.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut1_hu_fb114baba6d55fdb.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>
&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3.png"
width="734"
height="479"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3_hu_c3ebae96aecae360.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut3_hu_87569d5eaa72a3a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="153"
data-flex-basis="367px"
>&lt;/p>
&lt;ol start="5">
&lt;li>既然你已经通过调整图层实现了所需的视觉效果，那就需要另外打开 中性色调LUT 的一个副本。 可以将为屏幕截图创建的调整图层拖动到该中性色调LUT上。打开带有调整图层的屏幕截图和中性色调LUT后，将调整图层从屏幕截图的图层（Layers）面板 拖放 到中性色调LUT图像上。 此时你应该会看到它们填充在LUT的图层（Layers）面板中。&lt;/li>
&lt;li>现在，导航到 File（文件） &amp;gt; Save As（另存为），给经过颜色校正的LUT提供一个名称。&lt;/li>
&lt;li>将经过颜色校正的LUT导入编辑器中，可以将其 拖放 到内容浏览器（Content Browser），也可以使用内容浏览器（Content Browser）中提供的 Import（导入） 按钮。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut5.png"
width="868"
height="393"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut5_hu_3f1c68d5b8335fe4.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut5_hu_2109ff0dc59f6f9a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="530px"
>&lt;/p>
&lt;ol start="8">
&lt;li>要在后期处理体积中使用LUT获得最佳效果，在纹理编辑器（Texture Editor）中打开LUT图像，设置下列属性：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut6.png"
width="461"
height="135"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut6_hu_d24a7d2be6a685fb.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut6_hu_ea4f43a92be780f0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="341"
data-flex-basis="819px"
>&lt;/p>
&lt;ol start="9">
&lt;li>接下来，在后期处理体积中，使用 细节（Details） 面板，在 颜色分级（Color Grading） &amp;gt; 全局（Global） 部分，启用 颜色分级LUT（Color Grading LUT） 并应用您的LUT。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut8.png"
width="453"
height="408"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut8_hu_42921edce6a5ae19.png 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%9F%A5%E6%89%BE%E8%A1%A8lut%E8%BF%9B%E8%A1%8C%E9%A2%9C%E8%89%B2%E6%A0%A1%E6%AD%A3/lut8_hu_fb8b09784e480436.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="266px"
>&lt;/p></description></item><item><title>网格体绘制管道</title><link>https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/ue5-hero.png" alt="Featured image of post 网格体绘制管道" />&lt;p>本页包含的信息适用于那些想要添加自定义网格体通道，或者想要理解虚幻引擎网格绘制性能特征的程序员。&lt;/p>
&lt;p>网格体绘制管道基于保留模式的概念，其中所有场景绘制都是预先准备好的，而不是每帧都构建它们。它还具有积极缓存和绘制调用合并功能，以便利用静态网格体的属性，这些属性很少变化，可能跨帧重用。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/meshpipelineoverview_1.png"
width="1440"
height="818"
srcset="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/meshpipelineoverview_1_hu_fc257fa650f13a0f.png 480w, https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E7%BB%98%E5%88%B6%E7%AE%A1%E9%81%93/meshpipelineoverview_1_hu_1157196d3358ca6c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="422px"
>&lt;/p>
&lt;p>网格体渲染从&lt;code>FPrimitiveSceneProxy&lt;/code>开始，这是游戏线程的&lt;code>UPrimitiveComponent&lt;/code>渲染线程表示。&lt;/p></description></item><item><title>纹理流送配置</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E9%85%8D%E7%BD%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E9%85%8D%E7%BD%AE/ue5-hero.png" alt="Featured image of post 纹理流送配置" />&lt;p>在检查构建的纹理流送的准确性之后，您可能需要调整纹理流送的行为和优先级。 下面的参数可以通过配置文件进行调整，而其中的大多数参数也可以在运行时从控制台窗口进行更新。&lt;/p>
&lt;p>|命令|说明|
|r.TextureStreaming|此命令用于启用或禁用纹理流送器。当纹理流送器被禁用后，所有纹理mip都将被完全加载到内存中，即使在纹理从来没有被用于渲染的情况下也是如此。如果需要，您可以在运行时切换此选项。|
|r.Streaming.PoolSize|引擎中纹理可用的池大小(MB)。这个池包含UI纹理、NeverStream纹理、立方体贴图和流送纹理。在某些平台上，这个池还可以保存非纹理资源，例如GPU粒子缓冲区和顶点缓冲区。设置为0时，池的大小将不受限制。|
|r.Streaming.UseFixedPoolSize|当使用非零值时，可以在运行时更改纹理池大小。|
|r.Streaming.FramesForFullUpdate|纹理流送器的每次完整更新之间的帧数。每次更新都会重新计算每个纹理所需的分辨率，并生成mip加载或卸载请求。较高的值会降低纹理流送器CPU使用率，而较低的值会提高其反应能力。|
|r.Streaming.UseNewMetrics|仅用于兼容性。当设置为假时，纹理流送器将按照4.12版本继续进行处理。|&lt;/p></description></item><item><title>移动平台景深方法</title><link>https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/randg_herobanner.png" alt="Featured image of post 移动平台景深方法" />&lt;h1 id="高斯">高斯
&lt;/h1>&lt;blockquote>
&lt;p>已移除高斯景深与 延迟渲染器（Deferred Renderer） 和 桌面前向渲染器（Desktop Forward Renderer） 的配合使用，该景深仅支持移动平台。如需在桌面计算机上在编辑器内工作时使用此高斯景深，请使用移动预览器启用其中一个移动平台预览器。&lt;/p>&lt;/blockquote>
&lt;p>高斯 景深方法使用标准的&lt;a class="link" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A" target="_blank" rel="noopener"
>高斯模糊&lt;/a>（也叫高斯平滑）函数对场景进行模糊处理。高斯DOF使用固定大小的高斯模糊核对前景和背景进行模糊处理，在移动设备等低端硬件上它的速度非常快。在非常注重性能的场合，它可以在降低开销的情况下保持高性能。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_0.png"
width="1415"
height="796"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_0_hu_4fecfe220d92d046.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_0_hu_e1f7c743d28f242f.png 1024w"
loading="lazy"
alt="无景深"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>
&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_1.png"
width="1415"
height="796"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_1_hu_5f95c64f3d699239.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_1_hu_1aec8e03adb98eef.png 1024w"
loading="lazy"
alt="高斯景深"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;h1 id="查看景深">查看景深
&lt;/h1>&lt;p>可以使用关卡视口中的 景深图层（Depth of Field layers） 显示标志来使包括过渡区在内的图层可视化，该显示标志位于 显示（Show） &amp;gt; 可视化（Visualize） 下。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_2.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_2_hu_7dd9e637e0c3bf70.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_2_hu_65d4db5bdb216334.png 1024w"
loading="lazy"
alt="最终场景"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>
&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_3.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_3_hu_2ed0772d4a7b30bb.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_3_hu_30a6a8862b3a15a6.png 1024w"
loading="lazy"
alt="景深查看"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;h1 id="对焦距离focal-distance">对焦距离（Focal Distance）
&lt;/h1>&lt;p>对焦距离（Focal Distance） 表示对焦区域和捕捉的视角。焦距越长，景深越浅，对焦区域外的对象越模糊；焦距越短，景深越大，聚焦越准确而且失焦的对象越少。光圈数值可以保持不变，更改透镜尺寸将调整景深效果的深浅。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_5.png"
width="2500"
height="1946"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_5_hu_dc9299fc1fcae59d.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_5_hu_64bc36050e0c1c0d.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="128"
data-flex-basis="308px"
>&lt;/p>
&lt;p>设置好 对焦距离（Focal Distance） 和 对焦区域（Focal Region） 之后，就可以使用 近过渡（Near Transition） 和 远过渡（Far Transition） 来调整对焦区域和完全模糊的场景之间的距离。另外，你甚至还可以调整 近景模糊尺寸（Near Blur Size） 和 远景模糊尺寸（Far Blur Size） 来进一步对高斯景深的外观进行微调。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_6.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_6_hu_4abb0c0ce2ea3f61.png 480w, https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E6%99%AF%E6%B7%B1%E6%96%B9%E6%B3%95/image_6_hu_b0749e0bddcf6ff.png 1024w"
loading="lazy"
alt="为得到良好的景深效果，对近/远过渡和模糊尺寸的数值进行了调整之后的高斯景深。"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;p>在本示例中，为了实现近景和远景区域的柔和景深效果，我们设置了以下数值。&lt;/p>
&lt;ul>
&lt;li>对焦距离（Focal Distance）： 215&lt;/li>
&lt;li>影调范围（Scale）： 2500&lt;/li>
&lt;li>近过渡（Near Transition）： 500&lt;/li>
&lt;li>远过渡（Far Transition）： 400&lt;/li>
&lt;li>近景模糊尺寸（Near Blur Size）： 2.0&lt;/li>
&lt;li>远景模糊尺寸（Far Blur Size）： 2.5&lt;/li>
&lt;/ul>
&lt;h1 id="可用设置">可用设置
&lt;/h1>&lt;p>高斯景深的设置和属性可以在后期处理体积的 细节 面板中找到，位于 移动景深（Mobile Depth of Field） 的 镜头（Lens） 分类中。&lt;/p></description></item><item><title>预计算可视性体积</title><link>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ue5-hero.png" alt="Featured image of post 预计算可视性体积" />&lt;p>像其他剔除方法一样，预计算可视性体积用于实现中小型场景的性能优化，通常用于因为硬件问题而使动态遮挡剔除受到限制的移动平台。预计算可视性体积根据玩家或摄像机的位置，将Actor位置的可视性状态存储在场景中。因此，预计算可视性对于主要为静态点亮的环境项目、玩家运动受限和某些2D游戏区域最有用。&lt;/p>
&lt;p>在照明构建期间，会在阴影投射几何体上方生成可视性单元格。Actor可视性从每个单元格位置存储。由于预计算可视性是在线下生成的，因此你省去的是通常用于硬件遮挡查询的渲染线程时间，但代价是会增加运行时内存和照明构建时间。基于这一点，建议仅在玩家或摄像机可访问区域放置体积来保持可视性剔除。&lt;/p>
&lt;h1 id="设置和用法">设置和用法
&lt;/h1>&lt;p>首先，需要为关卡启用预计算可视性。方法是打开世界场景设置（World Settings）并找到预计算可视性（Precomputed Visibility）部分。找到后，启用预计算可视性（Precomputed Visibility）旁边的复选框。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis.png"
width="501"
height="243"
srcset="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_ff7454136b0cf587.png 480w, https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_fd5ffa0c6d38ac85.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="494px"
>&lt;/p>
&lt;p>从模式（Modes）面板中，将预计算可视性&lt;/p></description></item><item><title>预计算可视性体积</title><link>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ue5-hero.png" alt="Featured image of post 预计算可视性体积" />&lt;p>像其他剔除方法一样，预计算可视性体积用于实现中小型场景的性能优化，通常用于因为硬件问题而使动态遮挡剔除受到限制的移动平台。预计算可视性体积根据玩家或摄像机的位置，将Actor位置的可视性状态存储在场景中。因此，预计算可视性对于主要为静态点亮的环境项目、玩家运动受限和某些2D游戏区域最有用。&lt;/p>
&lt;p>在照明构建期间，会在阴影投射几何体上方生成可视性单元格。Actor可视性从每个单元格位置存储。由于预计算可视性是在线下生成的，因此你省去的是通常用于硬件遮挡查询的渲染线程时间，但代价是会增加运行时内存和照明构建时间。基于这一点，建议仅在玩家或摄像机可访问区域放置体积来保持可视性剔除。&lt;/p>
&lt;h1 id="设置和用法">设置和用法
&lt;/h1>&lt;p>首先，需要为关卡启用预计算可视性。方法是打开世界场景设置（World Settings）并找到预计算可视性（Precomputed Visibility）部分。找到后，启用预计算可视性（Precomputed Visibility）旁边的复选框。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis.png"
width="501"
height="243"
srcset="https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_ff7454136b0cf587.png 480w, https://zentia.github.io/p/%E9%A2%84%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%A7%86%E6%80%A7%E4%BD%93%E7%A7%AF/ws_enablepvis_hu_fd5ffa0c6d38ac85.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="494px"
>&lt;/p>
&lt;p>从模式（Modes）面板中，将预计算可视性&lt;/p></description></item><item><title>支持的纹理格式和设置</title><link>https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/ue5-hero.png" alt="Featured image of post 支持的纹理格式和设置" />&lt;p>在任何数字项目内存占用比例中，最大的一个内存占用来源是所用的纹理大小和数量。幸运的是，虚幻引擎 拥有非常可靠的系统，能够以非破坏性方式减小所有项目纹理的纹理大小。在以下页面中，我们将介绍这些系统，以及如何使用它们来降低项目纹理内存要求。&lt;/p>
&lt;h1 id="纹理分辨率">纹理分辨率
&lt;/h1>&lt;p>虚幻引擎支持1x1到8192x8192的纹理分辨率，只需要对.INI文件进行少许修改。最新的DirectX视频适配器和游戏主机支持1x1到2048x2048的各种纹理分辨率，最高可达8192x8192。特定硬件设备支持的最高纹理分辨率因制造商、型号和可用纹理内存而异。虚幻引擎4中有一些功能和设置，用于管理针对各种区域渲染的纹理分辨率，如场景几何结构或用户界面。&lt;/p>
&lt;h1 id="引擎纹理分辨率限制">引擎纹理分辨率限制
&lt;/h1>&lt;p>虚幻引擎4默认将最大纹理mip数量限制为14，这样有效地将最大渲染纹理限制为8192（1x1到8192x8192为14个mip）。&lt;/p>
&lt;p>这有一种副作用，即导入的8192纹理将仅渲染4096中的mip1。恒定值MAX_TEXTURE_MIP_COUNT在引擎源文件中默认为13，可以修改为值14以支持8192纹理渲染。该恒定值在以下源文件中定义（截至QAMar09，确保在其他QA版本上验证）。&lt;/p>
&lt;p>从发布UE 4.8开始，您现在可以修改项目以使用高达8192的大小，而不必修改C++代码，只需在项目的 BaseDeviceProfiles.ini 文件中添加以下文本并将 MaxLODsize 设置为 8192 即可&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[/Script/Engine.TextureLODSettings]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">TextureLODGroup_World=(MinLODSize=1,MaxLODSize=8192,LODBias=0,MinMagFilter=aniso,MipFilter=point)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>添加了想要增加其大小的分段后，保存文件并重新启动编辑器。编辑器重新启动后，以8192大小导入的任何纹理现在应该在LOD 1显示大小8192，而不是限制在最大值4096以内。在以下示例图像中，我们修改了UE 4.8项目中的BaseDeviceProfiles.ini文件，以允许使用大小高达8192的纹理。在UE4中加载纹理Texture_8k_Test时，我们可以看到导入和显示的纹理大小均为8192。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/texturelod_8k.png"
width="1391"
height="604"
srcset="https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/texturelod_8k_hu_f226750a3f6518e9.png 480w, https://zentia.github.io/p/%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%AE%BE%E7%BD%AE/texturelod_8k_hu_87bed8015e6dc264.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="230"
data-flex-basis="552px"
>&lt;/p>
&lt;h1 id="压缩的纹理内存要求">压缩的纹理内存要求
&lt;/h1>&lt;p>DXT使用有损压缩，通过调色板颜色和插值颜色将像素压缩在4x4的块中。这样会产生8:1 DXT1和4:1 DXT5恒定压缩文件大小。由于特定平台和硬件的视频内存和纹理池资源是固定的，因此纹理分辨率和资源使用必须达到平衡。下表列出了各种常见分辨率和完全mip下，DXT1和DXT5的纹理内存要求（1x1到完全原生mip0）。请注意，内存要求几乎是纹理分辨率比例的倍数不变，DXT5纹理对内存的占用几乎是DXT1的两倍。&lt;/p>
&lt;p>由于分辨率与压缩的比值是常量，为了计算本文未列出的纹理的内存要求，只需乘以分辨率比例即可。例如，1024x512纹理的内存要求是1024x1024纹理的一半。&lt;/p>
&lt;p>下表数据是根据使用箱式过滤器mip生成和DirectX纹理压缩，由ATI的Compressonator创建的纹理编译的。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>分辨率&lt;/th>
&lt;th>来自1x1的总Mip&lt;/th>
&lt;th>DXT1&lt;/th>
&lt;th>DXT5&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>16x16&lt;/td>
&lt;td>5个mip&lt;/td>
&lt;td>312字节&lt;/td>
&lt;td>496字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8192x8192&lt;/td>
&lt;td>14个mip&lt;/td>
&lt;td>42.6MB（44,739,384字节）&lt;/td>
&lt;td>85.3MB（89,478,640字节）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="引擎配置texturegroup属性">引擎配置TextureGroup属性
&lt;/h1>&lt;p>特定游戏的TextureGroup支持的最低和最高LOD（mip）在多个引擎配置文件中定义。
源配置设置文件组位于&lt;code>[虚幻引擎4安装位置]\Engine\Config\BaseDeviceProfiles.ini&lt;/code> 文件的[/Scripts/Engine.TextureLODSettings]分段中。&lt;/p>
&lt;p>为开发游戏，[your_game]\Config\DefaultDeviceProfiles.ini 文件还在 Engine\Config\ 文件夹中包含一组镜像基础文件，这应当是通常根据游戏特定设置进行修改的副本。&lt;/p>
&lt;p>需要注意的是，虚幻编辑器和游戏中拥有一组独立的TextureGroup条目。这两组分别位于配置文件的[SystemSettingsEditor]和[SystemSettings]分段中。&lt;/p>
&lt;p>DefaultDeviceProfiles.ini 文件中的TextureLODGroup设置条目类与此类似。请注意，较早QA版本可能不包含各个设置的MinMagFilter和MipFilter属性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[/Script/Engine.TextureLODSettings]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; 请注意，该分段中的任何项目会影响所有平台！！！
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@TextureLODGroups=Group
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">TextureLODGroups=(Group=TEXTUREGROUP_World,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_WorldNormalMap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_WorldSpecular,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Character,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_CharacterNormalMap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_CharacterSpecular,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Weapon,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_WeaponNormalMap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_WeaponSpecular,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Vehicle,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_VehicleNormalMap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_VehicleSpecular,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Cinematic,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Effects,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=linear,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_EffectsNotFiltered,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Skybox,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_UI,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Lightmap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Shadowmap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,NumStreamedMips=3,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_RenderTarget,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_MobileFlattened,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Terrain_Heightmap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Terrain_Weightmap,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Bokeh,MinLODSize=1,MaxLODSize=256,LODBias=0,MinMagFilter=linear,MipFilter=linear,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+TextureLODGroups=(Group=TEXTUREGROUP_Pixels2D,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=point,MipFilter=point,MipGenSettings=TMGS_SimpleAverage)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="pc-appcompat桶">PC AppCompat桶
&lt;/h1>&lt;p>AppCompat用于根据目标和启动时收集的经验证据来覆盖各种SystemSettings。启用应用兼容性（仅限PC）时，系统衡量机器能力，然后使用五个&amp;quot;桶&amp;quot;中的其中一个桶的预设值来覆盖Engine.ini值。请参阅Engine\Config\文件夹中的BaseCompat.ini以了解相关用法示例。&lt;/p>
&lt;p>AppCompat应该仅在首次运行游戏（而不是编辑器）时检查一次。它通过在[game]Engine.ini中检查是否存在[AppCompat]分段来进行检测，这个分段包含机器先前计算的分数。如果AppCompat已经应用过一次，则不会再次更改以允许用户每次在不进行覆盖的情况下进行自定义更改。&lt;/p>
&lt;p>AppCompat专门针对编辑器禁用，这样机器规格不会影响开发期间在各种机器上查看资源的方式。因此，SystemSettings和SystemSettingsEditor才需要区分开来。&lt;/p>
&lt;p>您可以有效地禁用AppCompat，方法是为游戏提供空的DefaultCompat.ini，使其从Engine.ini中的[SystemSettings]初始化所有桶。在此情况下，系统完全按照引入AppCompat之前的状态运行。&lt;/p>
&lt;h1 id="texturegroup属性">TEXTUREGROUP属性
&lt;/h1>&lt;p>每个TextureGroup条目为游戏渲染中使用的特定纹理集定义纹理属性。通过将纹理分组为常用集，可以更好地控制各种游戏纹理资源的纹理内存池使用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MinLODSize&lt;/td>
&lt;td>将渲染的最小mip大小，以像素为单位指定，范围1到8192中的2的幂值，必须小于MaxLODSize。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MaxLODSize&lt;/td>
&lt;td>将渲染的最大mip大小，以像素为单位指定，范围1到8192中的2的幂值，必须大于MinLODSize。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="过滤">过滤
&lt;/h1>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>MinMagFilter&lt;/th>
&lt;th>MipFilter&lt;/th>
&lt;th>过滤类型&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>点&lt;/td>
&lt;td>&lt;/td>
&lt;td>点&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>各向异性&lt;/td>
&lt;td>&lt;/td>
&lt;td>各向异性线性&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="texturegrouplodgroup和lodbias">TextureGroup、LODGroup和LODBias
&lt;/h1>&lt;p>配置ini文件中指定的TextureGroup和LODBias设置以及纹理属性中指定的LODGroup和LODBias设置确定了用于单个纹理的最终纹理mip集。&lt;/p>
&lt;p>[your_game]Engine.ini中的示例TextureGroup条目可能类似于：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Group=TEXTUREGROUP_World,MinLODSize=1,MaxLODSize=4096,LODBias=0,MinMagFilter=aniso,MipFilter=point,MipGenSettings=TMGS_SimpleAverage
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="纹理属性">纹理属性
&lt;/h1>&lt;p>关于各种纹理属性的含义说明，请参阅纹理属性页面。&lt;/p></description></item><item><title>指数高度雾（Exponential Height Fog）</title><link>https://zentia.github.io/p/%E6%8C%87%E6%95%B0%E9%AB%98%E5%BA%A6%E9%9B%BEexponential-height-fog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%8C%87%E6%95%B0%E9%AB%98%E5%BA%A6%E9%9B%BEexponential-height-fog/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%8C%87%E6%95%B0%E9%AB%98%E5%BA%A6%E9%9B%BEexponential-height-fog/ue5-hero.png" alt="Featured image of post 指数高度雾（Exponential Height Fog）" />&lt;p>指数高度雾在地图的低处创造更多的密度，在高处创造更少的密度。过渡是平稳的，所以当你增加高度时，你永远不会遇到一个硬的切断。指数高度雾也提供了两种雾色：一种时面向主导方向光的半球（或者如果不存在直接向上），另一种时面向相反半球的颜色。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>雾密度（Fog Density）&lt;/td>
&lt;td>此为整体密度稀疏，是可视雾层的厚度。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>雾高度衰减（Fog Height Falloff）&lt;/td>
&lt;td>高度密度系数，控制高度降低时密度增加的成都。值越小，过渡就越大。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>高度雾偏移（Height Fog Offset）&lt;/td>
&lt;td>此控制相对于Actor放置Z（高度）的雾层高度偏移。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Getting started with Texture Graph</title><link>https://zentia.github.io/p/getting-started-with-texture-graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/getting-started-with-texture-graph/</guid><description>&lt;img src="https://zentia.github.io/p/getting-started-with-texture-graph/ue5-hero.png" alt="Featured image of post Getting started with Texture Graph" />&lt;p>The Texture Graph Editor provides artists a node-based interface to procedurally create and edit textures in Unreal Engine.&lt;/p></description></item><item><title>GPU Lightmass全局光照</title><link>https://zentia.github.io/p/gpu-lightmass%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/gpu-lightmass%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</guid><description>&lt;img src="https://zentia.github.io/p/gpu-lightmass%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/ue5-hero.png" alt="Featured image of post GPU Lightmass全局光照" />&lt;p>GPU Lightmass（GPULM）是一种光照烘培解决方案，它可以预计算移动性设置为静止（Stationary）或静态（Static）的光源的复杂光线交互，并将这些数据保存在生成的光照贴图纹理中，这些纹理又转而应用到场景几何体。这个将光照烘培到纹理中的系统类似于基于CPU的Lightmass全局光照系统。&lt;/p></description></item><item><title>GPU光线追踪碰撞</title><link>https://zentia.github.io/p/gpu%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%A2%B0%E6%92%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/gpu%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%A2%B0%E6%92%9E/</guid><description>&lt;img src="https://zentia.github.io/p/gpu%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%A2%B0%E6%92%9E/bannerimage_workingwithmedia.png" alt="Featured image of post GPU光线追踪碰撞" /></description></item><item><title>Nanite虚拟几何体</title><link>https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/</guid><description>&lt;img src="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/ue5-hero.png" alt="Featured image of post Nanite虚拟几何体" />&lt;p>Nanite是虚幻引擎5的虚拟化几何体系统，它采用全新的内部网格体格式和渲染技术来渲染像素级别的细节以及海量对象。它可以智能的仅处理你能感受到的细节。另外，Nanite采用高度压缩的数据格式，并且支持具有自动细节级别的颗粒度流送。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/nanite-in-unreal-engine.png"
width="3840"
height="3174"
srcset="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/nanite-in-unreal-engine_hu_86c148fb16e944c0.png 480w, https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/nanite-in-unreal-engine_hu_f35cbd38f3710ec.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;h1 id="nanite的优势">Nanite的优势
&lt;/h1>&lt;ul>
&lt;li>几何体形状的复杂度提高了数个数量级，三角形和对象的实时渲染数量达到了前所未有的高度&lt;/li>
&lt;li>帧预算不再会因为多边形数量、绘制调用和网格体内存使用情况而受限&lt;/li>
&lt;li>现在可以直接导入电影级品质的美术资源，例如ZBrush雕刻模型和摄影测量扫描数据&lt;/li>
&lt;li>通过高模实现细节，而非将细节烘培到法线贴图纹理&lt;/li>
&lt;li>自动处理细节级别（LOD），不再需要手动设置单个网格体的LOD&lt;/li>
&lt;li>品质损失极少或没有损失，特别是在LOD发生过渡时&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>尽管Nanite带来了前所未有的变革，但在实际使用上，仍会存在一些限制。 例如，在考虑实例总数、单个网格体的三角形数量、材质复杂度、输出分辨率、项目性能等方面时，还是需要根据实际项目内容和硬件水平来仔细衡量。 与此同时，在虚幻引擎未来的版本中，Nanite将不断扩展功能并提升性能。&lt;/p>&lt;/blockquote>
&lt;h1 id="nanite网格体和传统静态网格体的不同之处">Nanite网格体和传统静态网格体的不同之处
&lt;/h1>&lt;p>Nanite网格体是一种启用了Nanite的特殊静态网格体。 Nanite网格体本质上仍是三角形网格体，但对其数据进行了大量细节和压缩处理。 此外，Nanite使用了一种全新系统，能以极高效的方式来渲染这种数据格式。&lt;/p>
&lt;p>要让静态网格体利用Nanite，只需一个标记来启用它即可。 编辑Nanite网格体的内容和传统网格体没太大不同，区别就在于相比使用传统方法渲染的几何体，Nanite能够渲染的三角形和实例要多出数个数量级。 将摄像机移到足够近的位置后，Nanite就会绘制出导入的原始源三角形。&lt;/p>
&lt;p>Nanite网格体支持多重UV和顶点颜色。 材质可以被分配给网格体的不同分段，并且这些材质可以使用不同的着色模型和动态效果（在着色器中完成）。 材质指定可以动态切换，就像其他静态网格体一样。Nanite也无需任何烘焙材质的过程。&lt;/p>
&lt;p>&lt;a class="link" href="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/" target="_blank" rel="noopener"
>虚拟纹理&lt;/a>并非必须与Nanite一起使用，但强烈建议使用虚拟纹理。 虚拟纹理是正交虚幻引擎功能，它与纹理数据的关系类似于Nanite与网格体数据的关系。&lt;/p>
&lt;h1 id="nanite如何工作">Nanite如何工作？
&lt;/h1>&lt;p>Nanite可最大限度地与现有的引擎工作流程无缝集成，可使用前所未有的方法来存储和渲染网格体数据。&lt;/p>
&lt;ul>
&lt;li>导入期间 — 分析网格体，并将其拆分成由三角形组构成的分层群集。&lt;/li>
&lt;li>渲染期间 — 根据摄像机视图以不同LOD随时切换群集，并且可以在不破坏同一对象中相邻群集的情况下完美连接。 数据会根据需求流送，因此只有可见细节才会保存在内存中。 Nanite在自己的渲染通道中运行，该通道完全绕过了传统的绘制调用。 你可以使用可视化模式来检视Nanite管线。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于Nanite需要从磁盘快速流送网格体数据。 建议使用固态硬盘（即SSD）来存储运行时数据。&lt;/p>&lt;/blockquote>
&lt;h1 id="应该将nanite用于哪些类型的网格体">应该将Nanite用于哪些类型的网格体？
&lt;/h1>&lt;p>一般来说，能启用时应该尽量启用Nanite。 启用了Nanite的静态网格体通常可以更快地渲染，占用的内存和磁盘空间会更少。&lt;/p>
&lt;p>具体来说，如果网格体满足以下条件，则尤其适合使用Nanite：&lt;/p>
&lt;ul>
&lt;li>包含很多三角形，或屏幕上的三角形非常小&lt;/li>
&lt;li>场景中有很多实例&lt;/li>
&lt;li>是其他Nanite几何体的主要遮挡物&lt;/li>
&lt;li>使用虚拟阴影贴图投射阴影&lt;/li>
&lt;/ul></description></item><item><title>调试着色器编译过程</title><link>https://zentia.github.io/p/%E8%B0%83%E8%AF%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%B0%83%E8%AF%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%B0%83%E8%AF%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/ue5-hero.png" alt="Featured image of post 调试着色器编译过程" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>引擎中的渲染器模块管理并渲染场景，而场景拥有和每个世界场景相关的可渲染信息。它包括所有绘制规则和着色器的定义。&lt;/p>
&lt;p>RHI 模块是渲染 API 的接口，是图形编程的另一个关键组件。图形编程介绍包含许多可研究的键类、设置和变量，以下子页面包含详细的渲染要点。&lt;/p></description></item><item><title>构建虚拟世界</title><link>https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%96%E7%95%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%96%E7%95%8C/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E4%B8%96%E7%95%8C/worlds_topic.png" alt="Featured image of post 构建虚拟世界" />&lt;h1 id="分层细节级别hlod">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/hierarchical-level-of-detail-in-unreal-engine" target="_blank" rel="noopener"
>分层细节级别（HLOD）&lt;/a>
&lt;/h1>&lt;h1 id="地形户外地貌">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/landscape-outdoor-terrain-in-unreal-engine" target="_blank" rel="noopener"
>地形户外地貌&lt;/a>
&lt;/h1>&lt;h1 id="为场景设置光照">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/lighting-the-environment-in-unreal-engine" target="_blank" rel="noopener"
>为场景设置光照&lt;/a>
&lt;/h1>&lt;h2 id="雾云天空和大气的环境光源">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/environmental-light-with-fog-clouds-sky-and-atmosphere-in-unreal-engine" target="_blank" rel="noopener"
>雾、云、天空和大气的环境光源&lt;/a>
&lt;/h2>&lt;h3 id="环境光源混合器">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/environment-light-mixer-in-unreal-engine" target="_blank" rel="noopener"
>环境光源混合器&lt;/a>
&lt;/h3>&lt;p>打开方式：Window-&amp;gt;Env.Light Mixer&lt;/p>
&lt;h3 id="exponential-height-fog">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/exponential-height-fog-in-unreal-engine" target="_blank" rel="noopener"
>Exponential Height Fog&lt;/a>
&lt;/h3>&lt;h3 id="异类体积">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/heterogeneous-volumes-in-unreal-engine" target="_blank" rel="noopener"
>异类体积&lt;/a>
&lt;/h3>&lt;p>异类体积Actor用户渲染对稀疏体积纹理取样的体积域材质。&lt;/p>
&lt;h3 id="局部雾体积">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/local-fog-volumes-in-unreal-engine" target="_blank" rel="noopener"
>局部雾体积&lt;/a>
&lt;/h3>&lt;h3 id="天空大气组件">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/sky-atmosphere-component-in-unreal-engine" target="_blank" rel="noopener"
>天空大气组件&lt;/a>
&lt;/h3>&lt;h4 id="天空大气组件属性">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/sky-atmosphere-component-properties-in-unreal-engine" target="_blank" rel="noopener"
>天空大气组件属性&lt;/a>
&lt;/h4>&lt;h2 id="直接光照">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/features-and-properties-of-lights-in-unreal-engine" target="_blank" rel="noopener"
>直接光照&lt;/a>
&lt;/h2>&lt;h2 id="全局光照">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/global-illumination-in-unreal-engine" target="_blank" rel="noopener"
>全局光照&lt;/a>
&lt;/h2>&lt;h2 id="光源类型及其可移动性">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/light-types-and-their-mobility-in-unreal-engine" target="_blank" rel="noopener"
>光源类型及其可移动性&lt;/a>
&lt;/h2>&lt;h2 id="光照工具和插件">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/lighting-tools-and-plugins-in-unreal-engine" target="_blank" rel="noopener"
>光照工具和插件&lt;/a>
&lt;/h2>&lt;h2 id="网格体距离场">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/mesh-distance-fields-in-unreal-engine" target="_blank" rel="noopener"
>网格体距离场&lt;/a>
&lt;/h2>&lt;h2 id="硬件光线追踪和路径追踪功能">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/ray-tracing-and-path-tracing-features-in-unreal-engine" target="_blank" rel="noopener"
>硬件光线追踪和路径追踪功能&lt;/a>
&lt;/h2>&lt;h2 id="反射环境">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/reflections-environment-in-unreal-engine" target="_blank" rel="noopener"
>反射环境&lt;/a>
&lt;/h2>&lt;h2 id="阴影">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/shadowing-in-unreal-engine" target="_blank" rel="noopener"
>阴影&lt;/a>
&lt;/h2>&lt;h2 id="一actor一文件">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/one-file-per-actor-in-unreal-engine" target="_blank" rel="noopener"
>一Actor一文件&lt;/a>
&lt;/h2>&lt;h3 id="稀疏体积纹理">稀疏体积纹理
&lt;/h3>&lt;p>稀疏体积纹理（SVT）是将纹素（体素）存储在3D数据结构&lt;/p>
&lt;h2 id="天空大气组件-1">天空大气组件
&lt;/h2>&lt;h2 id="天空大气组件属性-1">天空大气组件属性
&lt;/h2>&lt;h3 id="光束">光束
&lt;/h3>&lt;h3 id="megalights">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/megalights-in-unreal-engine" target="_blank" rel="noopener"
>MegaLights&lt;/a>
&lt;/h3>&lt;h1 id="开放世界工具">开放世界工具
&lt;/h1>&lt;h1 id="程序化内存生成框架">程序化内存生成框架
&lt;/h1>&lt;h1 id="水体系统">水体系统
&lt;/h1>&lt;h1 id="世界分区">世界分区
&lt;/h1>&lt;h1 id="关卡编辑器">关卡编辑器
&lt;/h1></description></item><item><title>后期处理效果</title><link>https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/ue5-hero.png" alt="Featured image of post 后期处理效果" />&lt;p>后期处理效果（Post-processing effect）使美术师和设计师能够对影响颜色、色调映射、光照的属性和功能进行组合选择，从而定义场景的整体外观。要访问这些功能，可以将一种称为 后期处理体积（Post Process Volume） 的特殊类型的体积添加到关卡。可以放置多个体积来定义特定区域的外观，也可以将其设置为影响整个场景。&lt;/p>
&lt;h1 id="使用后期处理体积">使用后期处理体积
&lt;/h1>&lt;p>可以使用 放置Actor（Place Actors） 面板将一个 后期处理体积 添加到关卡。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/placing-post-process-volume.png"
width="1410"
height="753"
srcset="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/placing-post-process-volume_hu_708b21c73bcb0dd7.png 480w, https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/placing-post-process-volume_hu_420d14bdcf39a55f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="449px"
>&lt;/p>
&lt;p>放置到关卡中后，可以使用 细节（Details） 面板访问所有可用的属性和功能。你会发现后期处理体积根据它们的功能类型和它们的影响分为多个类目。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/post-process-details-panel.png"
width="1725"
height="944"
srcset="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/post-process-details-panel_hu_ed825485efe8c4e4.png 480w, https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/post-process-details-panel_hu_a47a0532e3f69eb5.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="182"
data-flex-basis="438px"
>&lt;/p>
&lt;p>后期处理体积设置（Post Process Volume Settings） 是这个已放置的体积的特定设置，以及该体积如何与场景以及可能与之重叠的任何其他后期处理体积进行交互。例如，可以选中 无限范围（Infinite Extent） 属性以使此后期处理体积影响场景中的所有位置，或者不选中该属性以仅影响特定区域。当多个体积发生重叠时，你可以控制这些体积如何相互交互以从一个体积混合到另一个体积，这在它们之间具有完全不同的外观时会很有用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>优先级（Priority）&lt;/td>
&lt;td>指定此体积的优先级。在体积重叠的情况下，具有最高优先级的体积会覆盖较低优先级的体积。如果两个或多个重叠的体积具有相同的优先级，则顺序是不明确的。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>混合半径（Blend Radius）&lt;/td>
&lt;td>设置用于混合的体积周围半径（采用世界单位）。例如，当步入一个体积时，体积内的外观可能与体积外的不同。混合半径会在体积周围创建一个过渡区域。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>混合权重（Blend Weight）&lt;/td>
&lt;td>体积属性的影响程度。值为1具有全部效果，而值为0则没有效果。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>已启用（Enabled）&lt;/td>
&lt;td>此体积是否影响后期处理。如果启用，体积的设置将用于混合。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>无限范围（无边界）（Infinite Extent (Unbound)）&lt;/td>
&lt;td>是否考虑体积的边界。如果启用，体积会影响整个场景，而不考虑其体积的边界。未启用时，体积仅在其边界范围内有效。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="后期处理功能和属性">后期处理功能和属性
&lt;/h1>&lt;p>通过选择放置在关卡中的一个后期处理体积来访问该体积的属性和设置。细节（Details） 面板将列出可用类目及其可用属性。&lt;/p>
&lt;blockquote>
&lt;p>即使关卡中没有放置后期处理体积，虚幻引擎也会使用一些默认的后期处理设置。可以在 项目设置（Project Settings） 的 渲染（Rendering）&amp;gt; 默认设置（Default Settings） 分段中找到和配置这些默认的后期处理设置。&lt;/p>
&lt;p>在开始定义场景外观之前，配置这些选项有助于进行关卡编辑以稳定自动曝光或泛光。&lt;/p>&lt;/blockquote>
&lt;h2 id="镜头">镜头
&lt;/h2>&lt;p>镜头（Lens） 类目包含的属性和设置用于模拟摄像机镜头产生的常见真实世界效果。&lt;/p>
&lt;h3 id="景深">景深
&lt;/h3>&lt;p>与真实的摄像机类似，景深（Depth of Field） 根据焦点前后的距离为场景应用模糊效果。该效果用于根据深度将观看者的注意力吸引到镜头中的特定主体上。它还可以增加一种美感，使渲染的图像看起来更像照片或胶片。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_disabled.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_disabled_hu_3989771e759a9fa6.png 480w, https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_disabled_hu_216ec5c823000df5.png 1024w"
loading="lazy"
alt="已禁用景深"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>
&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_enabled.png"
width="1916"
height="1015"
srcset="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_enabled_hu_75955f69df7591d6.png 480w, https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/dof_cine_enabled_hu_38507762aa83299c.png 1024w"
loading="lazy"
alt="已启用景深"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;p>有两个可用的景深选项：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://zentia.github.io/p/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%99%AF%E6%B7%B1/" target="_blank" rel="noopener"
>过场动画景深（Cinematic Depth of Field）&lt;/a>用于桌面平台和游戏主机平台。它可以提供一种胶片视觉效果，其属性与真实摄像机上的属性一致。后期处理体积提供了一些设置，但主要应该使用过场动画摄像机Actor上的摄像机属性来控制景深。&lt;/li>
&lt;/ul></description></item><item><title>如何修复GPU驱动程序崩溃</title><link>https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/ue5-hero.png" alt="Featured image of post 如何修复GPU驱动程序崩溃" />&lt;p>在处理含有大量图形的项目时，你有可能会遇到GPU崩溃。发生这种情况时，你将看到如下所示的窗口。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/gpu-crash.png"
width="360"
height="243"
srcset="https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/gpu-crash_hu_e395c92000460a5d.png 480w, https://zentia.github.io/p/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8Dgpu%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83/gpu-crash_hu_6555e6d4ec9126cc.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="148"
data-flex-basis="355px"
>&lt;/p></description></item><item><title>世界分区 - 数据层</title><link>https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA-%E6%95%B0%E6%8D%AE%E5%B1%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA-%E6%95%B0%E6%8D%AE%E5%B1%82/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA-%E6%95%B0%E6%8D%AE%E5%B1%82/ue5-hero.png" alt="Featured image of post 世界分区 - 数据层" />&lt;p>数据层（Data Layers） 是世界分区中的一个系统，用于在编辑器中和在运行时整理Actor。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA-%E6%95%B0%E6%8D%AE%E5%B1%82/data-layer-sample-finished.png"
width="1920"
height="1127"
srcset="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA-%E6%95%B0%E6%8D%AE%E5%B1%82/data-layer-sample-finished_hu_5c2b41aa07bed477.png 480w, https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA-%E6%95%B0%E6%8D%AE%E5%B1%82/data-layer-sample-finished_hu_142a8c80fb8220c2.png 1024w"
loading="lazy"
alt="一个使用数据层完成的示例关卡。"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>使用数据层资产和数据层实例，你可以在编辑器中动态加载和卸载层，以此实现复杂的关卡效果。该系统旨在取代旧版本虚幻引擎中先前的层系统。&lt;/p>
&lt;p>借助数据层，你可以在编辑器中将游戏逻辑类元素和环境资产分隔开来。美术师可以单独处理特定元素，不会受到游戏逻辑触发器或游戏对象的干扰。设计师则可以借助数据层的动态加载来设计有趣的游戏体验，并让关卡过度更加丰富多变。&lt;/p>
&lt;p>在运行时，你可以使用蓝图或C++代码切换数据层，进而驱动游戏逻辑（如任务、进度和游戏内事件）。数据层是在世界分区工作流程中管理资产流送的重要工具。&lt;/p>
&lt;h1 id="创建数据层">创建数据层
&lt;/h1>&lt;p>数据层分为两种类型的资产：数据层资产和数据层实例。数据层资产包含交叉世界数据，使用数据层大纲视图（Data Layers Outliner）或在 内容浏览器（Content Browser） 中创建。数据层实例包含世界特定数据，在 数据层大纲视图（Data Layers Outliner） 中创建。&lt;/p>
&lt;blockquote>
&lt;p>数据层（Data Layers）系统要求你在地图中启用 世界分区（World Partition） 。你可以使用 工具（Tools）&amp;gt; 转换关卡（Convert Level） 或使用命令将地图转换为世界分区。有关将现有关卡转换为世界分区的更多信息，请参阅世界分区。&lt;/p>&lt;/blockquote></description></item><item><title>纹理流送概述</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%A6%82%E8%BF%B0/ue5-hero.png" alt="Featured image of post 纹理流送概述" />&lt;p>纹理流送系统或流送器是引擎的一部分，负责增大和减小每个纹理的分辨率。该系统使您可以拥有良好的视觉质量， 同时有效地管理可用内存。这在一定程度上是通过Mip或Mipmap实现的，Mip或Mipmap是为您的纹理分辨率预先计算的图像序列。您可以将它们视为纹理的LOD。 有关Mip的更多信息，您可以在我们的纹理支持和设置页面上加以了解。&lt;/p>
&lt;p>流送器有自己的场景视图，它的更新周期包括&lt;/p>
&lt;ol>
&lt;li>更新场景视图&lt;/li>
&lt;li>计算每个纹理的理想分辨率&lt;/li>
&lt;li>根据流送池大小选择哪个分辨率实际上是可行的&lt;/li>
&lt;li>选择要更新的纹理&lt;/li>
&lt;li>生成加载/卸载请求&lt;/li>
&lt;/ol>
&lt;p>为完成这些任务，流送器使用异步工作线程来降低游戏线程上的工作负载，这样上述只有第一个和最后一个任务需要在游戏更新循环中完成。 场景视图包含每个Primitive组件使用的所有纹理列表以及每个纹理的场景边界和纹素场景大小。根据该信息和给定视点，可以计算出 获得良好的逐像素比率纹素所必需的分辨率。然后还会考虑一些额外的信息，例如该组件实际上是否可以在屏幕上看到。 这最终会定义每个纹理的理想分辨率。然后流送器会计算流送内存池是不是足够大，能容纳这些分辨率。如果不够，流送器会降低所选纹理的计划质量， 一次降低一个mip，直到计划的分辨率降低到预算之下。&lt;/p>
&lt;p>降低mip时处理纹理的顺序由保留时间优先级来定义，请按以下顺序遵循这些规则：&lt;/p>
&lt;ol>
&lt;li>保留地形纹理、强制加载纹理和已经缺失分辨率的纹理&lt;/li>
&lt;li>保留在屏幕上可见的mip&lt;/li>
&lt;li>保留角色纹理和不占用过多内存的纹理&lt;/li>
&lt;li>删掉不可见的mip，先删掉最新看到的mip&lt;/li>
&lt;/ol>
&lt;p>流送器确定针对每个纹理加载的分辨率后，就会根据加载顺序优先级计算先更新哪个纹理。优先级根据按照以下顺序评估的多个条件定义：&lt;/p>
&lt;ol>
&lt;li>先加载可见mip&lt;/li>
&lt;li>先加载强制加载纹理、地形纹理和角色纹理&lt;/li>
&lt;li>先加载远离目标分辨率的纹理&lt;/li>
&lt;li>对于不可见的纹理，先加载最新看到的&lt;/li>
&lt;/ol>
&lt;p>最后一步是为了生成一批更新请求，每个请求增大或降低当前纹理分辨率。针对一批更新的内存量 受到内存池大小的限制，以便保持较低的动态请求数量。&lt;/p></description></item><item><title>虚拟阴影贴图</title><link>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE/ue5-hero.png" alt="Featured image of post 虚拟阴影贴图" />&lt;p>虚拟阴影贴图（VSM）是一种全新的阴影贴图方法，可以提供稳定的高分辨率阴影。通过与虚幻引擎5的&lt;a class="link" href="https://zentia.github.io/p/nanite%E8%99%9A%E6%8B%9F%E5%87%A0%E4%BD%95%E4%BD%93/" target="_blank" rel="noopener"
>Nanite虚拟几何体&lt;/a>、Lumen全局光照和反射以及世界分区功能结合使用，它能够实现电影级的品质效果，为大型开放场景提供光照。&lt;/p></description></item><item><title>颜色分级和胶片色调映射器</title><link>https://zentia.github.io/p/%E9%A2%9C%E8%89%B2%E5%88%86%E7%BA%A7%E5%92%8C%E8%83%B6%E7%89%87%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%A2%9C%E8%89%B2%E5%88%86%E7%BA%A7%E5%92%8C%E8%83%B6%E7%89%87%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%A2%9C%E8%89%B2%E5%88%86%E7%BA%A7%E5%92%8C%E8%83%B6%E7%89%87%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84%E5%99%A8/randg_herobanner.png" alt="Featured image of post 颜色分级和胶片色调映射器" />&lt;p>在虚幻引擎中，颜色分级 一词涵盖了高动态范围（HDR）显示输出使用的色调映射功能（HDR到LDR转换），并改进了图像的颜色校正（用于筛选颜色变换的LDR颜色）处理。&lt;/p></description></item><item><title>运行时虚拟纹理</title><link>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%BF%90%E8%A1%8C%E6%97%B6%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 运行时虚拟纹理" />&lt;p>运行时虚拟纹理 (RVT)在运行时使用GPU按需创建其纹素数据，工作方式与传统纹理映射类似。较大区域上的RVT缓存着色数据非常适用于使用贴花类材质的地形和适配地形的样条。&lt;/p>
&lt;h1 id="工作流程">工作流程
&lt;/h1>&lt;p>使用以下高级步骤在项目中设置和使用运行时虚拟纹理：&lt;/p>
&lt;ol>
&lt;li>在内容浏览器中创建 运行时虚拟纹理 资产。用于将所有组件（包括RVT体积Actor和RVT材质）链接在一起，渲染运行时虚拟纹理。&lt;/li>
&lt;li>在 模式（Modes） 面板中将 运行时虚拟纹理体积（Runtime Virtual Texture Volume） 添加到场景。此操作用于将RVT资产放置到场景中。&lt;/li>
&lt;li>配置材质以 写入 到RVT资产。&lt;/li>
&lt;li>配置材质以从RVT资产 采样。&lt;/li>
&lt;li>设置一个或多个图元组件或地形Actor，以渲染至RVT资产。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>欲了解设置RVT的详细步骤指南，参见运行时虚拟纹理快速入门。本指南将设置地形材质和其他场景组件，以使用运行时虚拟纹理。&lt;/p>&lt;/blockquote></description></item><item><title>组件</title><link>https://zentia.github.io/p/%E7%BB%84%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BB%84%E4%BB%B6/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BB%84%E4%BB%B6/ue5-hero.png" alt="Featured image of post 组件" />&lt;p>组件 是一种特殊类型的 对象，Actor 可以将组件作为子对象附加到自身。组件适用于共享相同的行为，例如显示视觉表现、播放声音。它们还可以表示项目特有的概念，例如载具解译输入和改变其速度与方向的方式。举例而言，某个项目拥有用户可控制车辆、飞机和船只。可以通过更改载具Actor所使用的组件来实现载具控制和移动的差异。&lt;/p>
&lt;h1 id="actor组件">Actor组件
&lt;/h1>&lt;p>UActorComponent 是所有组件的基类。由于组件是渲染网格体和图像、实现碰撞和播放音频的唯一方法，因此玩家游戏期间在场景中看到或进行交互的一切其实都是某一类组件的成果。&lt;/p>
&lt;p>创建自己的组件时，需要了解一些主要的类：Actor组件、场景组件 和 Primitive组件。&lt;/p>
&lt;ul>
&lt;li>Actor组件（类 UActorComponent）最适用于抽象行为，例如移动、物品栏或属性管理，以及其他非物理概念。Actor组件没有变换，即它们在场景中不存在任何物理位置或旋转。&lt;/li>
&lt;li>场景组件（类 USceneComponent、UActorComponent 的子项）支持基于位置的行为，这类行为不需要几何表示。这包括弹簧臂、摄像机、物理力和约束（但不包括物理对象），甚至音频。&lt;/li>
&lt;li>Primitive组件（类 UPrimitiveComponent、USceneComponent 的子项）是拥有几何表示的场景组件，通常用于渲染视觉元素或与物理对象发生碰撞或重叠。这包括静态或骨架网格体、Sprite或公告板、粒子系统以及盒体、胶囊体和球体碰撞体积。&lt;/li>
&lt;/ul>
&lt;h2 id="注册组件">注册组件
&lt;/h2>&lt;p>为了让Actor组件能够逐帧更新并影响场景，引擎必须 注册 这类组件。如果在Actor产生过程中，作为Actor子对象自动创建了组件，则这类组件会自动注册。但是，游戏期间创建的组件可以使用手动注册。RegisterComponent 函数提供了这个功能，要求是组件与Actor关联。&lt;/p>
&lt;blockquote>
&lt;p>游戏期间注册组件可能会影响性能，因此只应在必要时进行此操作。&lt;/p>&lt;/blockquote>
&lt;h3 id="注册事件">注册事件
&lt;/h3>&lt;p>在注册组件的过程中，引擎会将组件与场景关联起来，让其可用于逐帧更新，并运行以下 UActorComponent 函数：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>函数&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>OnRegister&lt;/td>
&lt;td>在注册组件时，可以覆写此函数来添加代码。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CreateRenderState&lt;/td>
&lt;td>初始化组件的渲染状态。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OnCreatePhysicsState&lt;/td>
&lt;td>初始化组件的物理状态。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="取消注册组件">取消注册组件
&lt;/h2>&lt;p>要从更新、模拟或渲染过程中移除Actor组件，可以使用 &lt;code>UnregisterComponent&lt;/code> 函数将其取消注册。&lt;/p>
&lt;h3 id="取消注册事件">取消注册事件
&lt;/h3>&lt;p>在组件取消注册时，将运行下面的 UActorComponent 函数。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>函数&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>OnUnregister&lt;/code>&lt;/td>
&lt;td>在取消注册组件时，可以覆写此函数来添加代码。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>DestroyRenderState&lt;/code>&lt;/td>
&lt;td>取消初始化组件的渲染状态。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>OnDestroyPhysicsState&lt;/code>&lt;/td>
&lt;td>取消初始化组件的物理状态。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="更新">更新
&lt;/h2>&lt;p>Actor组件能够以类似于Actor的方法逐帧更新。TickComponent 函数允许组件逐帧运行代码。例如，USkeletalMeshComponent 使用其 TickComponent 函数来更新动画和骨架控制器，而 UParticleSystemComponent 更新其发射器和处理粒子事件。&lt;/p>
&lt;p>默认情况下，Actor组件不更新。为了让Actor组件逐帧更新，必须在构造函数中将 PrimaryComponentTick.bCanEverTick 设置为 true 来启用tick。之后，在构造函数中或其他位置处，必须调用 &lt;code>PrimaryComponentTick.SetTickFunctionEnable(true)&lt;/code> 以开启更新。之后可调用 &lt;code>PrimaryComponentTick.SetTickFunctionEnable(false)&lt;/code> 停用tick。如果您知道组件永远不需要更新，或者打算手动调用自己的更新函数（也许从拥有的Actor类），将 PrimaryComponentTick.bCanEverTick 保留为默认值 false 即可，这样可以稍微改善性能。&lt;/p>
&lt;h2 id="渲染状态">渲染状态
&lt;/h2>&lt;p>为进行渲染，Actor组件必须创建渲染状态。此渲染状态还会告诉引擎，需要更新渲染数据的组件已发生变更。当发生此类变更时，渲染状态会被标记为&amp;quot;dirty&amp;quot;。如果编译您自己的组件，可以使用 &lt;code>MarkRenderStateDirty&lt;/code> 函数将渲染数据标记为dirty。在一帧结束时，所有dirty组件的渲染数据都会在引擎中更新。场景组件（包括Primitive组件）默认会创建渲染状态，而Actor组件则不会。&lt;/p>
&lt;h2 id="物理状态">物理状态
&lt;/h2>&lt;p>要与引擎的物理模拟系统交互，Actor组件需要物理状态。物理状态会在发生变化时立即更新，防止出现&amp;quot;帧落后&amp;quot;瑕疵等问题，也不需要&amp;quot;dirty&amp;quot;标记。默认情况下，Actor组件和场景组件没有物理状态，但基元组件有。覆盖 &lt;code>ShouldCreatePhysicsState&lt;/code> 函数以确定组件类实例是否需要物理状态。&lt;/p>
&lt;blockquote>
&lt;p>如果类使用物理，则不建议只返回 true。请参阅函数的 &lt;code>UPrimitiveComponent&lt;/code> 版本，了解不应创建物理状态的情况（例如在组件破坏期间）。在正常返回 true 的情况下，还可以返回 &lt;code>Super::ShouldCreatePhysicsState&lt;/code>。&lt;/p>&lt;/blockquote>
&lt;h2 id="视觉化组件">视觉化组件
&lt;/h2>&lt;p>某些Actor和组件没有视觉表示，使它们难以选择，或有一些重要属性不可见。在编辑器中工作时，开发者可以添加额外的组件来显示信息，但在编辑器中运行时或运行打包版本时不需要这些额外组件。为解决这个问题，编辑器支持 视觉化组件 的概念，这是只在编辑器中工作时存在的普通组件。&lt;/p>
&lt;p>要创建视觉化组件，需创建常规组件并在其上方调用 &lt;code>SetIsVisualizationComponent&lt;/code>。由于组件无需存在于编辑器之外，所有对它的引用都应当处在对 &lt;code>WITH_EDITORONLY_DATA&lt;/code> 或 &lt;code>WITH_EDITOR&lt;/code> 的预处理器检查之中。这将确保打包版本不受这些组件的影响，并保证不会在代码中的任何位置引用它们。举例而言，摄像机组件 使用多个其他组件来在编辑器中显示实用信息，包括用于显示视图视锥的 绘制视锥组件。在头文件中，绘制视锥组件在类中进行如下定义：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#if WITH_EDITORONLY_DATA
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="c1">// 用于显示摄像机视野所在位置的视锥组件
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">UDrawFrustumComponent&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">DrawFrustum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="cp">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同样，对这个组件的所有引用应当位于源文件中对 &lt;code>WITH_EDITORONLY_DATA&lt;/code> 的预处理器检查之中。&lt;code>OnRegister&lt;/code> 中的 &lt;code>WITH_EDITORONLY_DATA&lt;/code> 检查内部的这段代码，将检查确认摄像机组件是否连接到有效Actor，然后添加绘制视锥组件代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">UCameraComponent&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">OnRegister&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#if WITH_EDITORONLY_DATA
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">AActor&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">MyOwner&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetOwner&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">DrawFrustum&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">DrawFrustum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NewObject&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">UDrawFrustumComponent&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyOwner&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">NAME_None&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RF_Transactional&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">RF_TextExportTransient&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">DrawFrustum&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetupAttachment&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">DrawFrustum&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetIsVisualizationComponent&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="cp">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">Super&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">OnRegister&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...在此处编写其他代码（在所有版本中运行）...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>DrawFrustum&lt;/code> 现仅存在于编辑器中，被视为视觉化组件，即在编辑器中进行游戏测试时不会显示。&lt;/p>
&lt;h1 id="场景组件">场景组件
&lt;/h1>&lt;p>场景组件是指存在于场景中特定物理位置处的Actor组件。该位置由 变换（类 FTransform）定义，其中包含组件的位置、旋转和缩放。场景组件能够通过将彼此连接起来形成树，Actor可以将单个场景组件指定为&amp;quot;根&amp;quot;，意味着这个Actor的场景位置、旋转和缩放都根据此组件来绘制。&lt;/p>
&lt;h2 id="附加">附加
&lt;/h2>&lt;p>只有场景组件（USceneComponent 及其子类）可以彼此附加，因为需要变换来描述子项和父项组件之间的空间关系。虽然场景组件可以拥有任意数量的子项，但只能拥有一个父项，或可直接放置在场景中。场景组件系统不支持附加循环。两种主要方法分别是 &lt;code>SetupAttachment&lt;/code>和 &lt;code>AttachToComponent&lt;/code>。前者在构造函数中、以及处理尚未注册的组件时十分实用；后者会立即将场景组件附加到另一个组件，在游戏进行中十分实用。该附加系统还允许将Actor彼此之间进行附加，方法是将一个Actor的根组件附加到属于另一个Actor的组件。&lt;/p>
&lt;h1 id="基元组件">基元组件
&lt;/h1>&lt;p>基元组件（类 UPrimitiveComponent）是包含或生成某类几何的场景组件，通常用于渲染或碰撞。各种类型的几何体，目前最常用的是 盒体组件、胶囊体组件、静态网格体组件 和 骨架网格体组件。盒体组件和胶囊体组件生成不可见的几何体进行碰撞检测，而静态网格体组件和骨架网格体组件包含将被渲染的预制几何体，需要时也可以用于碰撞检测。&lt;/p>
&lt;h2 id="场景代理">场景代理
&lt;/h2>&lt;p>基元组件的 场景代理（类 FPrimitiveSceneProxy）封装场景数据，引擎使用这些数据来与游戏线程并行渲染组件。每种类型的基元都有自身的场景代理子类，用来保存所需的特定渲染数据。&lt;/p></description></item><item><title>Unreal Swarm</title><link>https://zentia.github.io/p/unreal-swarm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/unreal-swarm/</guid><description>&lt;img src="https://zentia.github.io/p/unreal-swarm/ue5-hero.png" alt="Featured image of post Unreal Swarm" />&lt;p>Unreal Swarm是一种通用的应用程序和任务分配系统，由两种应用程序类型组成，一种是分配构建任务的协调程序，另一种是利用主机系统资产完成分配任务的代理程序。&lt;/p></description></item><item><title>并行渲染介绍</title><link>https://zentia.github.io/p/%E5%B9%B6%E8%A1%8C%E6%B8%B2%E6%9F%93%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%B9%B6%E8%A1%8C%E6%B8%B2%E6%9F%93%E4%BB%8B%E7%BB%8D/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%B9%B6%E8%A1%8C%E6%B8%B2%E6%9F%93%E4%BB%8B%E7%BB%8D/ue5-hero.png" alt="Featured image of post 并行渲染介绍" />&lt;h1 id="线程概述">线程概述
&lt;/h1>&lt;p>最初，渲染器运行在渲染线程中，游戏线程将该线程的命令排队，以便稍后在帧中运行。这些命令会调用渲染硬件接口（RHI）曾，它是受支持的平台上不同图形API的跨平台接口。&lt;/p>
&lt;p>为了提高此过程的效率并利用受支持的平台功能，渲染线程现在作为一个前端，将不受平台限制的图形命令排入渲染器的命令列表，然后新的RHI线程通过后端的相应图形API转换（执行）这些命令。借助这种分离，可在支持它的平台（例如游戏机、DX12和Vulkan）上实现独立的后端并行化。一般来说，在前端并行生成的任何内容都会在后端并行转换。&lt;/p>
&lt;blockquote>
&lt;p>某些命令可在不使用命令列表系统的情况下执行，例如锁定和解锁操作。这些命令由渲染线程直接发出。在这些情况下，引擎要么转储清楚RHI线程并等待操作完成，要么复制数据并对其进行排队。实现方式根据操作和平台的不同而异。&lt;/p>&lt;/blockquote></description></item><item><title>间接光照缓存</title><link>https://zentia.github.io/p/%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7%E7%BC%93%E5%AD%98/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7%E7%BC%93%E5%AD%98/ue5-hero.png" alt="Featured image of post 间接光照缓存" />&lt;p>CPU Lightmass可以在静态对象上生成间接光照的光照贴图，但角色之类的动态对象同样需要一种接受间接光照的方法。这能通过间接光照缓存（Indirect Lighting Cache）来解决，其在光照构建时使用Lightmass生成的采样来计算动态对象在运行时的间接光照。&lt;/p>
&lt;p>下图显示了带与不带间接光照缓存渲染的效果差异：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7%E7%BC%93%E5%AD%98/01-indirect-cache-diffuse-no-indirect.png"
width="1918"
height="1130"
srcset="https://zentia.github.io/p/%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7%E7%BC%93%E5%AD%98/01-indirect-cache-diffuse-no-indirect_hu_4096c6f569dd0e1e.png 480w, https://zentia.github.io/p/%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7%E7%BC%93%E5%AD%98/01-indirect-cache-diffuse-no-indirect_hu_f8d09119c334506.png 1024w"
loading="lazy"
alt="Elemental关卡中的漫反射光照，不带间接光照缓存"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="407px"
>&lt;/p></description></item><item><title>景深</title><link>https://zentia.github.io/p/%E6%99%AF%E6%B7%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%99%AF%E6%B7%B1/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%99%AF%E6%B7%B1/randg_herobanner.png" alt="Featured image of post 景深" />&lt;p>与真实世界的摄像机类似，景深（DOF）基于距离对焦点前后的场景应用模糊处理。 这种效果可以用来基于景深将观者的注意力吸引到特定的拍摄物体上，同时增加美学观感，使渲染看起来更像照片或影片。&lt;/p>
&lt;h1 id="景深类型">景深类型
&lt;/h1>&lt;p>在虚幻引擎中，您可以使用几种方法来执行景深效果。 这些方法被分为两大类：&lt;/p>
&lt;ul>
&lt;li>影片： 此方法向景深效果提供了一种影视的观感。 对此方法进行调整可以与摄影和影片摄影中常见的摄像机选项更加一致。 该选项对于个人电脑和主机平台来说非常适合。&lt;/li>
&lt;li>移动： 该方法提供了移动平台可以接受的最优化、低开销的DOF选项。&lt;/li>
&lt;/ul>
&lt;p>从以下方法中选择，了解它们的更多功能：&lt;/p></description></item><item><title>流送虚拟纹理</title><link>https://zentia.github.io/p/%E6%B5%81%E9%80%81%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B5%81%E9%80%81%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B5%81%E9%80%81%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 流送虚拟纹理" />&lt;p>流送虚拟纹理 (SVT)是一种在项目中从硬盘流送纹理的替代方法，与虚幻引擎4（UE4）中现有基于mip的纹理流送相比，其既有优点也有缺点。&lt;/p></description></item><item><title>纹理流送指标</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/ue5-hero.png" alt="Featured image of post 纹理流送指标" />&lt;p>可使用 STAT STREAMING 控制台命令分析纹理流送状态。此分析报告性能、内存使用，以及纹理流送器使用的其他指标。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">STAT STREAMING sortby=name maxhistoryframes=1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/statstreaming.png"
width="1136"
height="626"
srcset="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/statstreaming_hu_7d663e3bd6568f81.png 480w, https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81%E6%8C%87%E6%A0%87/statstreaming_hu_53f6b5ad6d3d0ecc.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>读取内存数据时，术语&amp;quot;pool&amp;quot;代表概念（保留）内存，与实际使用的内存无关。 术语&amp;quot;mips&amp;quot;代表纹理当前使用的内存，而非未发生或未来的使用。内存指标分为三种主要的池：&lt;/p>
&lt;ul>
&lt;li>Texture&lt;/li>
&lt;li>Streaming&lt;/li>
&lt;li>Wanted&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这些池的大小显示在 Memory Counters 类目中每行的右方。&lt;/p>&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数据&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Game Thread Update Time&lt;/td>
&lt;td>流送器更新函数所占用的时间。这负责大多数的纹理流送工作。只有少数任务在纹理流送器外处理，如移除对纹理、组件或关卡的引用。在一个游戏线程更新中，流送器向完整更新执行一步。完成更新将持续数帧，并与 r.Streaming.FramesForFullUpdate 相关。如数据的 Counter 部分所定义，更新步骤各有不同。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Texture Pool&lt;/td>
&lt;td>纹理资源可用的总内存。这包含各种非流送资源，如渲染目标、GPU 粒子缓存、立方体贴图、UI 纹理和不可流送纹理。在部分平台上，此内存可用于保存静态网格体之类的非纹理资源。Texture Pool 约等于 Safety Pool + Temporary Pool + Streaming Pool + NonStreaming Mips（如有，仅限波动的量，上至安全池的大小）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Safety Pool&lt;/td>
&lt;td>此值在 Engine 配置文件中设置（在 [TextureStreaming] 下，作为 MemoryMargin）。这是为意外（非流送）分配预留的内存。如可用的内存因低于此值的量形成周期波动，纹理流送器将在此波动下最大程度地稳定其流送池如正常（预计）的波动超过安全池大小，纹理流送器将不断应用其预算，可能会创建流入和流出纹理的无限循环。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Temporary Pool&lt;/td>
&lt;td>此值由 r.Streaming.MaxTempMemoryAllowed 控制，并指定调整纹理大小时流送器可用的额外内存量。变更纹理的 mip 数量时，引擎需要新建一个纹理（无论大小），用于保存之后的 mip 数据。这能间接控制进行中请求的数量，因为流送器将向 IO 系统发送临时池允许的请求数量。注意：临时池最小尺寸必须与需要流送的最大资源相同，但设为过大会浪费内存（因其正是为此目的而预留）。从另一方面而言，设为过小会减缓流送速度（无法为 IO 系统生成足够的工作，使其进入待机状态）。此外还需注意：流送器无法对进行中请求内的处理顺序进行较大程度的控制。这意味着使用相对较小的临时池可更大程度地控制加载顺序。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Streaming Pool&lt;/td>
&lt;td>纹理流送器可用的内存量。流送器通常会将所有可用内存用于流送新 mip，或将之前流送的 mip 尽可能久地保存在内存中。流送池（Streaming Pool）包含可见 Mip（Visible Mip）、隐藏 Mip（Hidden Mip）、强制 Mip（Force Mip）和缓存 Mip（Cached Mip）。Streaming Pool 约等于 Visible Mips* + Hidden Mips + Forced Mips + Cached Mips（完全使用时为 *:，否则未使用的空间必须被占用）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NonStreaming Mips&lt;/td>
&lt;td>非流送分配使用的内存量。如这些分配因超过安全池的值而出现定期波动，这将影响流送池的预算，应避免出现此状况（减少分配次数或增加安全池）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Required Pool&lt;/td>
&lt;td>纹理流送器需要根据其指标加载的 mip 数据量。这可超过纹理流送池的 100%，但同时也会进行一些妥协，部分纹理将不会以其所要求的分辨率加载。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Visible Mips&lt;/td>
&lt;td>可见纹理 mip 当前占用的所需内存。这并不包含强制 mip。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hidden Mips&lt;/td>
&lt;td>非可见纹理 mip 当前占用的所需内存。这并不包含强制 mip。为防止首次显示纹理时出现低精度纹理，流送器会提前预流送纹理，但通常会比所需要的少一个 mip（详见 r.Streaming.HiddenPrimitiveScale）。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>着色器调试工作流程</title><link>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/ue5-hero.png" alt="Featured image of post 着色器调试工作流程" />&lt;h1 id="渲染线程">渲染线程
&lt;/h1>&lt;p>在虚幻引擎中，整个渲染器在其自身的线程中执行操作，该线程位于游戏线程的一两帧后。&lt;/p>
&lt;p>执行渲染操作时，必须仔细地考虑内存读写，确保线程安全，以及行为的确定性。功能行为取决于两个线程之间的执行速度差，这种情况被称作竞争条件。需要尽量避免竞争条件的出现，因为它们难以重现；且因为速度差的缘故，它们可能依赖于机器、平台、调试器或配置。这类 bug 很难进行调试，所花费的修复时间约为可重现的普通 bug 的 10 倍。&lt;/p></description></item><item><title>GPU转储文件查看器工具</title><link>https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/</guid><description>&lt;img src="https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/ue5-hero.png" alt="Featured image of post GPU转储文件查看器工具" />&lt;p>DumpGPU是一个不受平台限制的控制台命令，能够将中间渲染资源二进制或采集帧转储到磁盘中。转储文件会保存为.json和.bin文件，可以使用轻量级网页浏览器查看。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/gpu-dump-viewer.png"
width="1920"
height="1040"
srcset="https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/gpu-dump-viewer_hu_2764e0b66fdcbb5c.png 480w, https://zentia.github.io/p/gpu%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%E5%B7%A5%E5%85%B7/gpu-dump-viewer_hu_de89706a1b9f7dd.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p></description></item><item><title>Lightmass基础知识</title><link>https://zentia.github.io/p/lightmass%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/lightmass%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>&lt;img src="https://zentia.github.io/p/lightmass%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ue5-hero.png" alt="Featured image of post Lightmass基础知识" />&lt;p>全局光照（Lightmass）创建具有复杂光交互作用的光照图，例如区域阴影和漫反射。&lt;/p></description></item><item><title>Niagara调试器</title><link>https://zentia.github.io/p/niagara%E8%B0%83%E8%AF%95%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/niagara%E8%B0%83%E8%AF%95%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/niagara%E8%B0%83%E8%AF%95%E5%99%A8/niagara-landing-hero.png" alt="Featured image of post Niagara调试器" /></description></item><item><title>添加细节纹理</title><link>https://zentia.github.io/p/%E6%B7%BB%E5%8A%A0%E7%BB%86%E8%8A%82%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B7%BB%E5%8A%A0%E7%BB%86%E8%8A%82%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B7%BB%E5%8A%A0%E7%BB%86%E8%8A%82%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 添加细节纹理" />&lt;p>在项目开发中，你可能需要用到自发光材质或发光材质。在UE中，Self-Illuminated和Emissive材质均称为自发光材质。&lt;/p></description></item><item><title>渲染依赖图</title><link>https://zentia.github.io/p/%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/ue5-hero.png" alt="Featured image of post 渲染依赖图" />&lt;p>渲染依赖图（Render Dependency Graph），也称为渲染图或RDG，是一种即时模式应哟个程序编程接口（API），它将要编译和执行的渲染命令记录到图数据结构中。RDG通过自动化易出错的操作来简化代码，并遍历依赖图以优化内存使用并在CPU和GPU上进行渲染通道。&lt;/p></description></item><item><title>优化Niagara</title><link>https://zentia.github.io/p/%E4%BC%98%E5%8C%96niagara/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BC%98%E5%8C%96niagara/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BC%98%E5%8C%96niagara/bannerimage_workingwithmedia.png" alt="Featured image of post 优化Niagara" />&lt;h1 id="衡量性能">衡量性能
&lt;/h1>&lt;h2 id="概述">概述
&lt;/h2>&lt;p>衡量粒子的性能后，你将知道进行优化时应重点关注的具体区域。在做出更改之前验证假设非常重要，这可避免错误地优化无需优化地地方，而且这样可以有一个比较点，用来显示更改带来地影响程度。&lt;/p>
&lt;p>本节将介绍虚幻提供地一些用于衡量Niagara粒子系统性能地工具，以及如何读取这些系统，和如何根据它们地数据做出决定。&lt;/p>
&lt;h2 id="衡量性能-1">衡量性能
&lt;/h2>&lt;h3 id="unreal-insights-关卡中地衡量系统">Unreal Insights-关卡中地衡量系统
&lt;/h3>&lt;p>捕获具有代表性的Gameplay窗口，最好是游戏本身，以便提供最具有参考价值的数据。适合某个项目的设置未必适合其他项目，甚至同一项目的不同关卡也是如此。
例如，带受摄像机的过长动画可能会有运行3D流体模拟的预算，但着如果在正常Gameplay期间运行，开销就太高了。&lt;/p>
&lt;h2 id="视图模式-衡量渲染复杂性">视图模式-衡量渲染复杂性
&lt;/h2>&lt;p>视觉特效通常有许多重叠的半透明Sprite和网格体，所以它们通常会到导致过渡绘制，因此验证Niagara系统的着色器复杂性也很重要。你可以在着色器复杂性视图模式查看复杂性的总体概况。要获得更详细的度过绘制视图，可以使用四边形过渡绘制视图模式。&lt;/p>
&lt;p>减少颗粒数和进一步扩散粒子可以减少过渡绘制。粒子占据的屏幕控件越少，受到的关注就越少，在本例中也是如此。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BC%98%E5%8C%96niagara/niagara-measuring-perf-11.png"
width="1400"
height="796"
srcset="https://zentia.github.io/p/%E4%BC%98%E5%8C%96niagara/niagara-measuring-perf-11_hu_12ae42f023f794ec.png 480w, https://zentia.github.io/p/%E4%BC%98%E5%8C%96niagara/niagara-measuring-perf-11_hu_a27713eeec94e186.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="422px"
>&lt;/p>
&lt;h1 id="伸缩性和最佳实践">伸缩性和最佳实践
&lt;/h1>&lt;h2 id="概述-1">概述
&lt;/h2>&lt;p>本节概述了多个策略，主要用来减少粒子系统在单个和总体关卡上所作的工作量。 上一节已经指出了执行额外工作的区域，本节将介绍在这些区域做出更改的工具和选项。通常，减少了执行的工作量，就可以避免不必要的工作，或者选择开销更少的解决方案。&lt;/p>
&lt;h2 id="实例数减少关卡中的系统数量">实例数：减少关卡中的系统数量
&lt;/h2>&lt;p>即使一个系统经过了优化，如果关卡中这样的系统太多，也会影响性能。默认情况下，我们会使用Niagara World Manager批量刷新同一系统的实例，但系统的实例越多，游戏线程上需要执行的工作就越多。通常，在模拟的粒子数量不变的情况下，实例越多，达到的性能就越低，但拥有更多的实例可以让Niagara以更高的粒度剔除粒子，所以你需要在少量大实例与大量小实例之间进行权衡。&lt;/p></description></item><item><title>自动曝光</title><link>https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/rendering-herobanner-5-0.png" alt="Featured image of post 自动曝光" />&lt;p>后期处理体积（Post Process Volume） 提供 自动曝光（Automatic Exposure） （通常称为眼部适应）控制选项，可自动调整当前场景视图的明暗。此效果可再现人眼适应不同光照条件的体验，例如从昏暗的室内走到明亮的室外，或从室外走到室内。&lt;/p>
&lt;h1 id="曝光测光模式">曝光测光模式
&lt;/h1>&lt;p>在场景中设置自动曝光时，引擎提供几种测光模式选项。此类不同测光模式提供可精确模拟实际摄像机的设置，可在后期处理过程中控制场景中的曝光。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/exposuremeteringmodes.png"
width="473"
height="169"
srcset="https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/exposuremeteringmodes_hu_e38fe788089f76f5.png 480w, https://zentia.github.io/p/%E8%87%AA%E5%8A%A8%E6%9B%9D%E5%85%89/exposuremeteringmodes_hu_1b5084dde9f1ae7.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="279"
data-flex-basis="671px"
>&lt;/p>
&lt;ul>
&lt;li>自动曝光直方图（Auto Exposure Histogram） 模式通过由64bin直方图构成的高级设置更好地控制自动曝光。这是虚幻引擎中的默认曝光测光模式。&lt;/li>
&lt;li>基本自动曝光（Auto Exposure Basic） 模式提供的设置较少，但这是通过下采样曝光计算单个值的更快速方法。&lt;/li>
&lt;li>手动（Manual） 模式支持使用后期处理和摄像机设置中的 摄像机（Camera） 设置控制曝光，而非仅使用 曝光（Exposure） 类别中的设置。&lt;/li>
&lt;/ul>
&lt;h2 id="直方图和基本算法">直方图和基本算法
&lt;/h2></description></item><item><title>Lightmass门户</title><link>https://zentia.github.io/p/lightmass%E9%97%A8%E6%88%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/lightmass%E9%97%A8%E6%88%B7/</guid><description>&lt;img src="https://zentia.github.io/p/lightmass%E9%97%A8%E6%88%B7/ue5-hero.png" alt="Featured image of post Lightmass门户" />&lt;p>在收集光线时，Lightmass可以使用来自光子映射技术的光子追溯到聚光源、点光源和定向光源。这意味着它可以找到这些类型的光源来自哪个小窗户，并以高品质解析射入的光线。但是，天空光照自发光网格体不能有效地支持光子发射，所以Lightmass只能强行查找微小地重要光照特性。&lt;/p></description></item><item><title>Lumen全局光照和反射</title><link>https://zentia.github.io/p/lumen%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E5%92%8C%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/lumen%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E5%92%8C%E5%8F%8D%E5%B0%84/</guid><description>&lt;img src="https://zentia.github.io/p/lumen%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E5%92%8C%E5%8F%8D%E5%B0%84/ue5-hero.png" alt="Featured image of post Lumen全局光照和反射" />&lt;p>Lumen是虚幻引擎5的全动态全局光照和反射系统，专门针对下一代主机进行设计，是默认的全局光照和反射系统。Lumen能够在拥有大量细节的宏大场景中渲染间接漫反射，并确保无限次数的反弹以及间接高光度反射效果；无论是毫米级别的场景细节，还是数以千米的宏大场景，它都能应对得游刃有余。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/lumen%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E5%92%8C%E5%8F%8D%E5%B0%84/lumen-scionti-04.png"
width="1920"
height="1080"
srcset="https://zentia.github.io/p/lumen%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E5%92%8C%E5%8F%8D%E5%B0%84/lumen-scionti-04_hu_838cdccfad3513a1.png 480w, https://zentia.github.io/p/lumen%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E5%92%8C%E5%8F%8D%E5%B0%84/lumen-scionti-04_hu_ca894aaced6f2e95.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;h1 id="lumen入门">Lumen入门
&lt;/h1>&lt;p>新创建的项目默认启用Lumen全局光照和反射，及其依赖功能，例如生成网格体距离场。项目从虚幻引擎4升级到虚幻引擎5时， 不会 自动启用Lumen功能。这能防止破坏或更改这些项目中的光照路线。&lt;/p></description></item><item><title>Panini 投影</title><link>https://zentia.github.io/p/panini-%E6%8A%95%E5%BD%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/panini-%E6%8A%95%E5%BD%B1/</guid><description>&lt;img src="https://zentia.github.io/p/panini-%E6%8A%95%E5%BD%B1/randg_herobanner.png" alt="Featured image of post Panini 投影" /></description></item><item><title>编程和脚本编写</title><link>https://zentia.github.io/p/%E7%BC%96%E7%A8%8B%E5%92%8C%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BC%96%E7%A8%8B%E5%92%8C%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BC%96%E7%A8%8B%E5%92%8C%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/programmingwithcpphero.png" alt="Featured image of post 编程和脚本编写" />&lt;h1 id="用c编程">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/programming-with-cplusplus-in-unreal-engine" target="_blank" rel="noopener"
>用C++编程&lt;/a>
&lt;/h1>&lt;h1 id="蓝图可视化脚本">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/blueprints-visual-scripting-in-unreal-engine" target="_blank" rel="noopener"
>蓝图可视化脚本&lt;/a>
&lt;/h1>&lt;h1 id="类创建基础知识">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/class-creation-basics-in-unreal-engine" target="_blank" rel="noopener"
>类创建基础知识&lt;/a>
&lt;/h1>&lt;h1 id="在线子系统和服务">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/online-subsystems-and-services-in-unreal-engine" target="_blank" rel="noopener"
>在线子系统和服务&lt;/a>
&lt;/h1>&lt;h1 id="虚幻架构">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/programming-in-the-unreal-engine-architecture" target="_blank" rel="noopener"
>虚幻架构&lt;/a>
&lt;/h1>&lt;h1 id="开发设置">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/setting-up-your-development-environment-for-cplusplus-in-unreal-engine" target="_blank" rel="noopener"
>开发设置&lt;/a>
&lt;/h1></description></item><item><title>后期处理材质</title><link>https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%9D%90%E8%B4%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%9D%90%E8%B4%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%9D%90%E8%B4%A8/randg_herobanner.png" alt="Featured image of post 后期处理材质" /></description></item><item><title>一Actor一文件</title><link>https://zentia.github.io/p/%E4%B8%80actor%E4%B8%80%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%B8%80actor%E4%B8%80%E6%96%87%E4%BB%B6/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%B8%80actor%E4%B8%80%E6%96%87%E4%BB%B6/ue5-hero.png" alt="Featured image of post 一Actor一文件" />&lt;p>在之前的虚幻引擎版本中，要更改关卡中的一个或多个Actor，必须从源控制中检出文件。在你完成工作之前，其他团队成员访问不了该文件；这样会导致开发流程速度变慢，因为一次只有一个人员可以处理该文件。&lt;/p>
&lt;p>一Actor一文件（One File Per Actor，简称OFPA） 可以将Actor实例的数据保存到外部文件中，更改Actor时不再需要保存主关卡文件，从而减少用户之间的重叠。&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;一Actor一文件&amp;quot;功能仅在编辑器中可用。在烘焙时，所有Actor都嵌入到各自的关卡文件。&lt;/p>&lt;/blockquote>
&lt;h1 id="启用一actor一文件">启用&amp;quot;一Actor一文件&amp;rdquo;
&lt;/h1>&lt;p>使用世界分区时，默认启用&amp;quot;一Actor一文件&amp;quot;。要在非分区世界中启用OFPA，请执行以下操作：&lt;/p></description></item><item><title>World Settings</title><link>https://zentia.github.io/p/world-settings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/world-settings/</guid><description>&lt;img src="https://zentia.github.io/p/world-settings/ue5-hero.png" alt="Featured image of post World Settings" />&lt;p>Each Level can have unique settings applied to it from the World Settings panel. You can use this panel to do everthing from making sure the right Game Mode is activated when you play the Level to adjusting how global illumination works for that Level.&lt;/p>
&lt;p>To open the World Settings panel, from the main menu, go to Window, then select World Settings.&lt;/p></description></item><item><title>从影片渲染队列过渡到影片渲染图表</title><link>https://zentia.github.io/p/%E4%BB%8E%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97%E8%BF%87%E6%B8%A1%E5%88%B0%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E5%9B%BE%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BB%8E%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97%E8%BF%87%E6%B8%A1%E5%88%B0%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E5%9B%BE%E8%A1%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BB%8E%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97%E8%BF%87%E6%B8%A1%E5%88%B0%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E5%9B%BE%E8%A1%A8/interactiveexperiences_heroimage.png" alt="Featured image of post 从影片渲染队列过渡到影片渲染图表" /></description></item><item><title>回调脚本</title><link>https://zentia.github.io/p/%E5%9B%9E%E8%B0%83%E8%84%9A%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9B%9E%E8%B0%83%E8%84%9A%E6%9C%AC/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9B%9E%E8%B0%83%E8%84%9A%E6%9C%AC/interactiveexperiences_heroimage.png" alt="Featured image of post 回调脚本" />&lt;h1 id="回调简介">回调简介
&lt;/h1>&lt;p>回调是向渲染作业添加前期/后期逻辑的好方法。影片渲染图表有一个回调系统，用于处理在作业/镜头运行之前和之后运行的脚本，从而为渲染添加额外的逻辑。&lt;/p></description></item><item><title>静止图像渲染</title><link>https://zentia.github.io/p/%E9%9D%99%E6%AD%A2%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E9%9D%99%E6%AD%A2%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E9%9D%99%E6%AD%A2%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/interactiveexperiences_heroimage.png" alt="Featured image of post 静止图像渲染" />&lt;p>通过影片渲染队列（Movie Render Queue），可以采用批处理的方式来渲染多个摄像机中的静止图像，而不必在Sequencer中执行复杂的步骤。在处理变体或迭代时，利用这种方式可以简化来自不同视点的大量静止图像的创建过程。这种方式非常适合构建建筑、汽车或产品设计领域的交付件。&lt;/p></description></item><item><title>距离场环境光遮蔽</title><link>https://zentia.github.io/p/%E8%B7%9D%E7%A6%BB%E5%9C%BA%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%B7%9D%E7%A6%BB%E5%9C%BA%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%B7%9D%E7%A6%BB%E5%9C%BA%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD/ue5-hero.png" alt="Featured image of post 距离场环境光遮蔽" />&lt;p>使用有向距离场体积能获得可移动天空光照的阴影；该有向距离场体积在各刚性网格体周围预计算，以产生中等范围的环境光遮蔽。在 虚幻引擎 中，这被称为 距离场环境光遮蔽（Distance Field Ambient Occlusion）（DFAO）。其支持动态场景变化；刚性网格体可移动或隐藏，其会影响遮蔽。与屏幕空间环境光遮蔽（SSAO）不同，遮蔽在场景空间遮挡物中进行计算，因此出屏丢失数据不会导致瑕疵。&lt;/p></description></item><item><title>使用自发光材质输入</title><link>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8F%91%E5%85%89%E6%9D%90%E8%B4%A8%E8%BE%93%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8F%91%E5%85%89%E6%9D%90%E8%B4%A8%E8%BE%93%E5%85%A5/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8F%91%E5%85%89%E6%9D%90%E8%B4%A8%E8%BE%93%E5%85%A5/ue5-hero.png" alt="Featured image of post 使用自发光材质输入" />&lt;p>在项目开发中，你可能需要用到自发光材质或发光材质。在UE中，Self-Illuminated和Emissive材质均称为自发光材质。&lt;/p></description></item><item><title>网格体距离场</title><link>https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E8%B7%9D%E7%A6%BB%E5%9C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E8%B7%9D%E7%A6%BB%E5%9C%BA/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E8%B7%9D%E7%A6%BB%E5%9C%BA/ue5-hero.png" alt="Featured image of post 网格体距离场" />&lt;p>虚幻引擎 使用 距离场（Distance Fields） 的强大功能来实现游戏中静态网格体Actor的动态环境光遮蔽和阴影。除此之外，Actor的网格体距离场表达还可用于其他一些特性，例如GPU粒子碰撞，甚至还可以使用材质编辑器创建动态流动贴图等等。&lt;/p>
&lt;p>继续阅读下面的内容可以了解网格体距离场的工作原理，以及可通过哪些方法把它应用在游戏中。&lt;/p>
&lt;h1 id="它的工作原理是什么">它的工作原理是什么？
&lt;/h1>&lt;p>此技术中使用的距离场是代表静态网格体表面的 有向距离场（Signed Distance Field） （SDF）。有向距离场在每个点将距离最近表面的距离保存到体积纹理中。网格体外的每个点保存的距离为正值，网格体内的每个点保存的距离为负值。以下示例跟踪并保存了为正的距离，以在稍后表现出树的形象。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E8%B7%9D%E7%A6%BB%E5%9C%BA/01-distance-field-positive-distance-tracing.png"
width="375"
height="429"
srcset="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E8%B7%9D%E7%A6%BB%E5%9C%BA/01-distance-field-positive-distance-tracing_hu_36100c03609f98e6.png 480w, https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E8%B7%9D%E7%A6%BB%E5%9C%BA/01-distance-field-positive-distance-tracing_hu_8f8a95f9058649b0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="87"
data-flex-basis="209px"
>&lt;/p>
&lt;p>SDF首个实用属性的作用是，在追踪光线时安全地跳过空白空间，因为到最近表面的距离已经明确（有时称这种方法为球体追踪）。只需区区几步就可以判定出交叉点。对距离场进行光线追踪将生成可见性效果， 也就是说如果光线和网格体交叉，光线就会投射出阴影。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E8%B7%9D%E7%A6%BB%E5%9C%BA/02-distance-field-sphere-tracing.png"
width="375"
height="425"
srcset="https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E8%B7%9D%E7%A6%BB%E5%9C%BA/02-distance-field-sphere-tracing_hu_aa1af62f49cd7211.png 480w, https://zentia.github.io/p/%E7%BD%91%E6%A0%BC%E4%BD%93%E8%B7%9D%E7%A6%BB%E5%9C%BA/02-distance-field-sphere-tracing_hu_aaab4b76362aa57b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="88"
data-flex-basis="211px"
>&lt;/p>
&lt;p>距离场第二个实用属性的作用是，在追踪光线时，通过追踪经过遮挡物的距离最近的光线就可以计算出近似的锥体交叉点，而不产生额外成本。这种近似法可以利用距离场来实现非常柔和的区域阴影和天空遮蔽。这个属性是距离场环境光遮蔽的关键，因为少量的锥体即可为接收器点的整个半球计算出柔和的可见性。&lt;/p></description></item><item><title>渲染通道</title><link>https://zentia.github.io/p/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/interactiveexperiences_heroimage.png" alt="Featured image of post 渲染通道" />&lt;p>电影渲染队列支持在单独的通道中渲染不同类型的输出图像，例如最终图像、对象ID和其他渲染相关通道。每个渲染通道设置将在单独的渲染模式中输出你的电影。然后，你可以在外部后期制作或所选的合成程序中使用它们。&lt;/p></description></item><item><title>异步计算</title><link>https://zentia.github.io/p/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97/ue5-hero.png" alt="Featured image of post 异步计算" />&lt;p>渲染硬件接口（RHI）现支持 Xbox One 的异步计算（AsyncCompute）。此法可运行与渲染异步的 dispatch() 调用，有效利用未使用的 GPU 资源（计算单元（CU）、寄存器和带宽）。异步计算使用单独的上下文，我们通过 RHI 函数同步渲染和计算上下文。Dr PIX 可用于识别从异步计算获益的区域。例如，特定渲染通道中半数 CU 均未使用，这些 CU 则可能被异步计算任务所利用。异步计算存在一些限制：&lt;/p></description></item><item><title>影片渲染队列</title><link>https://zentia.github.io/p/%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97/interactiveexperiences_heroimage.png" alt="Featured image of post 影片渲染队列" /></description></item><item><title>在材质中使用菲涅尔</title><link>https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%8F%B2%E6%B6%85%E5%B0%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%8F%B2%E6%B6%85%E5%B0%94/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%8F%B2%E6%B6%85%E5%B0%94/ue5-hero.png" alt="Featured image of post 在材质中使用菲涅尔" />&lt;p>在创建电影或过长动画时，你尝尝需要想办法更好地突显角色或场景的轮廓。这时你需要用到一种光照技术，称为边沿光照或边缘光照，它的原理是通过添加额外光源来帮区分角色轮廓与背景。虽然者能够很好适用于电影，但将额外光源添加到3D场景会增加额外的复杂度，使其很快变得难以管理。&lt;/p></description></item><item><title>在影片渲染图表中进行渲染编程</title><link>https://zentia.github.io/p/%E5%9C%A8%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E5%9B%BE%E8%A1%A8%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B8%B2%E6%9F%93%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9C%A8%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E5%9B%BE%E8%A1%A8%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B8%B2%E6%9F%93%E7%BC%96%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9C%A8%E5%BD%B1%E7%89%87%E6%B8%B2%E6%9F%93%E5%9B%BE%E8%A1%A8%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B8%B2%E6%9F%93%E7%BC%96%E7%A8%8B/interactiveexperiences_heroimage.png" alt="Featured image of post 在影片渲染图表中进行渲染编程" /></description></item><item><title>Unreal Insights</title><link>https://zentia.github.io/p/unreal-insights/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/unreal-insights/</guid><description>&lt;img src="https://zentia.github.io/p/unreal-insights/testingandoptimization-heroimg.png" alt="Featured image of post Unreal Insights" />&lt;p>Unreal Insights是一个遥测捕获和分析套件，它可以从您的项目中以高数据率捕获事件。Unreal Insights可以帮你识别出可能需要优化的数据区域。&lt;/p>
&lt;p>Unreal Insights的主要组成部分分为：&lt;/p>
&lt;ul>
&lt;li>Trace事件，包含了事件名称和字段名称参数，用于定义一个事件并指定事件应包括的字段。&lt;/li>
&lt;li>Unreal Trace Server，用于记录并保存来自应用程序的踪迹。&lt;/li>
&lt;li>Unreal Insights，对数据进行分析和可视化处理。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://zentia.github.io/p/unreal-insights/insightsdiagram.jpg"
width="1501"
height="415"
srcset="https://zentia.github.io/p/unreal-insights/insightsdiagram_hu_e7bdd9c06048a7b5.jpg 480w, https://zentia.github.io/p/unreal-insights/insightsdiagram_hu_2babbda7e923e17f.jpg 1024w"
loading="lazy"
alt="Unrael Insights框架的主要组件的可视化"
class="gallery-image"
data-flex-grow="361"
data-flex-basis="868px"
>&lt;/p>
&lt;p>Trace会话是自描述的，并且与不同的引擎发布版本兼容。它们被存储在.utrace文件中。任何同时生成的数据都存储在与Trace文件相同目录下的.ucache文件中。&lt;/p></description></item><item><title>创建人体皮肤</title><link>https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E4%BA%BA%E4%BD%93%E7%9A%AE%E8%82%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E4%BA%BA%E4%BD%93%E7%9A%AE%E8%82%A4/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E4%BA%BA%E4%BD%93%E7%9A%AE%E8%82%A4/ue5-hero.png" alt="Featured image of post 创建人体皮肤" />&lt;p>让人体皮肤拥有正确的渲染效果是一个非常复杂的话题，并没有一劳永逸的完美方案。为此，请将以下信息视为你工作的起始点，因为要获得逼真的图像，需要完成大量的工作。这是因为我们的眼睛经过非常良好的训练，能够探测人体面部很细微的细节。&lt;/p></description></item><item><title>会话浏览器</title><link>https://zentia.github.io/p/%E4%BC%9A%E8%AF%9D%E6%B5%8F%E8%A7%88%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BC%9A%E8%AF%9D%E6%B5%8F%E8%A7%88%E5%99%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BC%9A%E8%AF%9D%E6%B5%8F%E8%A7%88%E5%99%A8/testingandoptimization-heroimg.png" alt="Featured image of post 会话浏览器" /></description></item><item><title>实时渲染优化指南</title><link>https://zentia.github.io/p/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/ue5-hero.png" alt="Featured image of post 实时渲染优化指南" />&lt;p>本文提供了关于如何识别并优化移动设备性能的指南和最佳实践，同时介绍了如何在这种情况下获得最逼真的实时渲染功能。&lt;/p>
&lt;p>在本文中，你将了解：&lt;/p>
&lt;ul>
&lt;li>哪些因素会影响性能预算&lt;/li>
&lt;li>关于项目打包的最佳实践&lt;/li>
&lt;li>哪些工具可用于检测性能瓶颈&lt;/li>
&lt;/ul>
&lt;h1 id="了解你的性能预算">了解你的性能预算
&lt;/h1>&lt;p>开发项目时，应用程序的目标设备只有有限的可用资源，包括用来保存和处理对象的内存资源。在构建你的项目时，你必须决定将这些资源用于哪些地方。所以，你应该自行了解设备izai速度、线程、CPU和GPU带宽方面的能力，以及设备的内存、图形内存和可用磁盘控件，这些都是很重要的考量因素。&lt;/p></description></item><item><title>贴画材质</title><link>https://zentia.github.io/p/%E8%B4%B4%E7%94%BB%E6%9D%90%E8%B4%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%B4%B4%E7%94%BB%E6%9D%90%E8%B4%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%B4%B4%E7%94%BB%E6%9D%90%E8%B4%A8/randg_herobanner.png" alt="Featured image of post 贴画材质" />&lt;p>贴花是一种材质，可将材质的特征（例如基础颜色、粗糙度和发现）投射到关卡中的几何体上，从而对场景做出局部修改。这包括能够使用贴花Actor或贴花网格体直接投射到静态和骨骼网格体。&lt;/p></description></item><item><title>物体和角色动画制作</title><link>https://zentia.github.io/p/%E7%89%A9%E4%BD%93%E5%92%8C%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%89%A9%E4%BD%93%E5%92%8C%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%89%A9%E4%BD%93%E5%92%8C%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C/bannerimage.png" alt="Featured image of post 物体和角色动画制作" />&lt;h1 id="骨架网格体动画系统">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/skeletal-mesh-animation-system-in-unreal-engine" target="_blank" rel="noopener"
>骨架网格体动画系统&lt;/a>
&lt;/h1>&lt;h2 id="动画编辑器">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/animation-editors-in-unreal-engine" target="_blank" rel="noopener"
>动画编辑器&lt;/a>
&lt;/h2>&lt;h2 id="动画蓝图">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/animation-blueprints-in-unreal-engine" target="_blank" rel="noopener"
>动画蓝图&lt;/a>
&lt;/h2>&lt;h2 id="动画资产和功能">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/animation-assets-and-features-in-unreal-engine" target="_blank" rel="noopener"
>动画资产和功能&lt;/a>
&lt;/h2>&lt;h2 id="live-link">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/live-link-in-unreal-engine" target="_blank" rel="noopener"
>Live Link&lt;/a>
&lt;/h2>&lt;h2 id="动画调试和优化">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/animation-debugging-and-optimization-in-unreal-engine" target="_blank" rel="noopener"
>动画调试和优化&lt;/a>
&lt;/h2>&lt;h2 id="动画操作指南和示例">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/animation-workflow-guides-and-examples-in-unreal-engine" target="_blank" rel="noopener"
>动画操作指南和示例&lt;/a>
&lt;/h2>&lt;h1 id="过场动画的sequencer">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/cinematics-and-movie-making-in-unreal-engine" target="_blank" rel="noopener"
>过场动画的Sequencer&lt;/a>
&lt;/h1>&lt;h2 id="sequencer基础">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/how-to-make-movies-in-unreal-engine" target="_blank" rel="noopener"
>Sequencer基础&lt;/a>
&lt;/h2>&lt;h2 id="movie-render-pipeline">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/movie-render-pipeline-in-unreal-engine" target="_blank" rel="noopener"
>Movie Render Pipeline&lt;/a>
&lt;/h2>&lt;h2 id="sequencer概述">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-sequencer-movie-tool-overview" target="_blank" rel="noopener"
>Sequencer概述&lt;/a>
&lt;/h2>&lt;h2 id="sequencer中的摄像机">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/movie-and-cinematic-cameras-in-unreal-engine" target="_blank" rel="noopener"
>Sequencer中的摄像机&lt;/a>
&lt;/h2>&lt;h2 id="过长动画流程指南和示例">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/cinematic-workflow-guides-and-examples-in-unreal-engine" target="_blank" rel="noopener"
>过长动画流程指南和示例&lt;/a>
&lt;/h2>&lt;h1 id="控制绑定">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/control-rig-in-unreal-engine" target="_blank" rel="noopener"
>控制绑定&lt;/a>
&lt;/h1>&lt;h2 id="控制绑定快速入门指南">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/how-to-create-control-rigs-in-unreal-engine" target="_blank" rel="noopener"
>控制绑定快速入门指南&lt;/a>
&lt;/h2>&lt;h2 id="使用控制绑定制作动画">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/rigging-with-control-rig-in-unreal-engine" target="_blank" rel="noopener"
>使用控制绑定制作动画&lt;/a>
&lt;/h2>&lt;h2 id="使用控制绑定制作动画效果">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/animating-with-control-rig-in-unreal-engine" target="_blank" rel="noopener"
>使用控制绑定制作动画效果&lt;/a>
&lt;/h2>&lt;h1 id="虚幻引擎">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/paper-2d-overview-in-unreal-engine" target="_blank" rel="noopener"
>虚幻引擎&lt;/a>
&lt;/h1></description></item><item><title>Substrate材质</title><link>https://zentia.github.io/p/substrate%E6%9D%90%E8%B4%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/substrate%E6%9D%90%E8%B4%A8/</guid><description>&lt;img src="https://zentia.github.io/p/substrate%E6%9D%90%E8%B4%A8/randg_herobanner.png" alt="Featured image of post Substrate材质" />&lt;p>虚幻引擎主要提供了两种方法来为材质进行分层，以便在不同表现类型之间创建复杂的混合效果。这些方法使你能够在单个网格体的不同区域上应用不同的材质属性。虽然你可以使用纹理遮罩和其他基于像素的逻辑，在普通材质中实现类似效果，但本文中的两个系统能够生成更加刻度的材质图标，并且在需要对材质进行修改时，其编辑流程对美术师更加友好。&lt;/p></description></item><item><title>创建用户界面</title><link>https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/ue5-hero.png" alt="Featured image of post 创建用户界面" />&lt;h1 id="构建用户界面">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/basics-of-user-interface-development-in-unreal-engine" target="_blank" rel="noopener"
>构建用户界面&lt;/a>
&lt;/h1>&lt;h1 id="umg编辑器参考">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/umg-editor-reference-for-unreal-engine" target="_blank" rel="noopener"
>UMG编辑器参考&lt;/a>
&lt;/h1>&lt;h2 id="slate后缓冲区">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-slate-postbuffers-in-unreal-engine" target="_blank" rel="noopener"
>Slate后缓冲区&lt;/a>
&lt;/h2>&lt;h1 id="slate-ui框架">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/slate-user-interface-programming-framework-for-unreal-engine" target="_blank" rel="noopener"
>Slate UI框架&lt;/a>
&lt;/h1>&lt;h2 id="slate-架构">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/understanding-the-slate-ui-architecture-in-unreal-engine" target="_blank" rel="noopener"
>Slate 架构&lt;/a>
&lt;/h2>&lt;h2 id="slate裁剪系统">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-the-slate-clipping-system-in-unreal-engine" target="_blank" rel="noopener"
>Slate裁剪系统&lt;/a>
&lt;/h2>&lt;h3 id="启用控件裁剪">启用控件裁剪
&lt;/h3>&lt;p>对于所有UMG控件而言，用户可以调整所选控件 Details 面板中的 Clipping 属性。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/umgclippingproperty.png"
width="453"
height="52"
srcset="https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/umgclippingproperty_hu_4061aba67d46adab.png 480w, https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/umgclippingproperty_hu_3bff73fe51f99cb6.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="871"
data-flex-basis="2090px"
>&lt;/p>
&lt;p>如需在代码中启用裁剪，需要将&lt;code>EWidgetClipping&lt;/code>的裁剪属性设为以下其中一个状态：&lt;/p>
&lt;ul>
&lt;li>Inherit&lt;/li>
&lt;li>ClipToBounds&lt;/li>
&lt;li>ClipToBoundsWithoutIntersecting&lt;/li>
&lt;li>ClipToBoundsAlways&lt;/li>
&lt;li>OnDement&lt;/li>
&lt;/ul>
&lt;h1 id="文本格式设置本地化和字体">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/text-formatting-localization-and-fonts-in-unreal-engine" target="_blank" rel="noopener"
>文本格式设置、本地化和字体&lt;/a>
&lt;/h1>&lt;h1 id="优化用户界面">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/optimizing-user-interfaces-in-unreal-engine" target="_blank" rel="noopener"
>优化用户界面&lt;/a>
&lt;/h1>&lt;h1 id="测试和调试">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/testing-and-debugging-user-interfaces-in-unreal-engine" target="_blank" rel="noopener"
>测试和调试&lt;/a>
&lt;/h1>&lt;h1 id="ui开发插件">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/plugins-for-ui-development-in-unreal-engine" target="_blank" rel="noopener"
>UI开发插件&lt;/a>
&lt;/h1>&lt;h1 id="控件类型参考说明">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/widget-type-reference-for-umg-ui-designer-in-unreal-engine" target="_blank" rel="noopener"
>控件类型参考说明&lt;/a>
&lt;/h1>&lt;h1 id="用户界面教程和示例">&lt;a class="link" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/tutorials-and-examples-for-user-interfaces-in-unreal-engine" target="_blank" rel="noopener"
>用户界面教程和示例&lt;/a>
&lt;/h1></description></item><item><title>分层材质</title><link>https://zentia.github.io/p/%E5%88%86%E5%B1%82%E6%9D%90%E8%B4%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%88%86%E5%B1%82%E6%9D%90%E8%B4%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%88%86%E5%B1%82%E6%9D%90%E8%B4%A8/randg_herobanner.png" alt="Featured image of post 分层材质" />&lt;p>虚幻引擎主要提供了两种方法来为材质进行分层，以便在不同表现类型之间创建复杂的混合效果。这些方法使你能够在单个网格体的不同区域上应用不同的材质属性。虽然你可以使用纹理遮罩和其他基于像素的逻辑，在普通材质中实现类似效果，但本文中的两个系统能够生成更加刻度的材质图标，并且在需要对材质进行修改时，其编辑流程对美术师更加友好。&lt;/p></description></item><item><title>使用纹理遮罩</title><link>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E7%BA%B9%E7%90%86%E9%81%AE%E7%BD%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E7%BA%B9%E7%90%86%E9%81%AE%E7%BD%A9/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E7%BA%B9%E7%90%86%E9%81%AE%E7%BD%A9/ue5-hero.png" alt="Featured image of post 使用纹理遮罩" />&lt;p>在创建3D资产时，你可能会发现需要在同一材质中定义不同的表面类型。使用纹理遮罩（Texture Mask）是实现此目的的一种低成本的简单方法。该遮罩定义表面的哪些部分应收材质的哪个部分影响。&lt;/p>
&lt;p>本教程将介绍如何在虚幻引擎材质中使用纹理遮罩。&lt;/p>
&lt;h1 id="纹理遮罩">纹理遮罩
&lt;/h1></description></item><item><title>动态设计</title><link>https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E8%AE%BE%E8%AE%A1/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E6%80%81%E8%AE%BE%E8%AE%A1/motiondesign_docsbg.png" alt="Featured image of post 动态设计" /></description></item><item><title>经向动态模糊</title><link>https://zentia.github.io/p/%E7%BB%8F%E5%90%91%E5%8A%A8%E6%80%81%E6%A8%A1%E7%B3%8A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BB%8F%E5%90%91%E5%8A%A8%E6%80%81%E6%A8%A1%E7%B3%8A/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BB%8F%E5%90%91%E5%8A%A8%E6%80%81%E6%A8%A1%E7%B3%8A/ue5-hero.png" alt="Featured image of post 经向动态模糊" />&lt;p>虚幻引擎支持标准动态模糊，实现方式是假设对象表面上的点在帧间保持直线移动，然后利用其在上一帧所处位置的信息来应用模糊效果。&lt;/p>
&lt;p>此设置适用于从一个位置将对象移至另一位置。但在应用于单帧内旋转180°的对象时，例如飞速旋转的汽车车轮，此方法会有视觉误差。在本例中，动态模糊朝向与车轮一侧的点，然后假设其以知县运动至车轮另一侧，而非圆周运动。&lt;/p></description></item><item><title>可延展性设置</title><link>https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/ue5-hero.png" alt="Featured image of post 可延展性设置" />&lt;h1 id="可延展性设置">可延展性设置
&lt;/h1>&lt;p>要在编辑器中访问可延展性设置，可使用工具栏中的设置（Settings）菜单。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_viewqual.png"
width="870"
height="648"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_viewqual_hu_660a2bbe38fd2601.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_viewqual_hu_eb94a814a012fbd6.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="322px"
>&lt;/p>
&lt;h1 id="分辨率缩放">分辨率缩放
&lt;/h1>&lt;p>UE可以较低分辨率渲染场景，然后将图像延展到目标分辨率。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00007.png"
width="939"
height="353"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00007_hu_8b00d92bde1ea5f.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00007_hu_b363202e6dacd546.png 1024w"
loading="lazy"
alt="左：50%无AA，中间：50%有AA，右：100%（无分辨率缩放）有AA"
class="gallery-image"
data-flex-grow="266"
data-flex-basis="638px"
>&lt;/p>
&lt;h1 id="视图距离">视图距离
&lt;/h1>&lt;p>对象可以根据与查看者的距离而剔除。默认情况下，所有对象都不会随距离而剔除（所需最大绘制距离为0）。除了设计者指定的值之外，还有一个全局可延展性设置，其作用类似于乘数（r.ViewDistanceScale）。下图您可以看到一些草对象（所需最大绘制距离为1000）：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00006.png"
width="1431"
height="314"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00006_hu_d40726dcea105a47.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_00006_hu_9697e1379c2915c4.png 1024w"
loading="lazy"
alt="左： r.ViewDistanceScale 0.4，中间：r.ViewDistanceScale 0.7，右：r.ViewDistanceScale 1.0（默认值）"
class="gallery-image"
data-flex-grow="455"
data-flex-basis="1093px"
>&lt;/p>
&lt;h1 id="抗锯齿">抗锯齿
&lt;/h1>&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_aa_small.png"
width="920"
height="216"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_aa_small_hu_298278cc3782843.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/scaler_aa_small_hu_548e393c642400f7.png 1024w"
loading="lazy"
alt="从左开始：r.PostProcessAAQuality 0到6。前3个等于 视图（View）-&amp;gt;可延展性选项（Scalability Options）-&amp;gt;AA 设置中的 低（Low）、中（Medium）、高（High）、Epic 设置。"
class="gallery-image"
data-flex-grow="425"
data-flex-basis="1022px"
>&lt;/p>
&lt;h1 id="后期处理sgpostprocessquality">后期处理——sg.PostProcessQuality
&lt;/h1>&lt;h1 id="阴影sgshadowquality">阴影——sg.ShadowQuality
&lt;/h1>&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_shadowquallevels.png"
width="4065"
height="665"
srcset="https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_shadowquallevels_hu_83ca908e3725a514.png 480w, https://zentia.github.io/p/%E5%8F%AF%E5%BB%B6%E5%B1%95%E6%80%A7%E8%AE%BE%E7%BD%AE/sc_shadowquallevels_hu_a2c094256dc9599c.png 1024w"
loading="lazy"
alt="sg.ShadowQuality左侧设置为0，依次向右递增到3。"
class="gallery-image"
data-flex-grow="611"
data-flex-basis="1467px"
>&lt;/p>
&lt;p>视图（View）-&amp;gt;引擎可延展性设置（Engine Scalability Settings）-&amp;gt;阴影（Shadows） 选项根据[UE_InstallPath]/Engine/Config文件夹中 BaseScalability.ini 文件中的设置，调节动态阴影的质量。低（Low） 设置等于 sg.ShadowQuality 0，Epic 等于 sg.ShadowQuality 3。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>sg.ShadowQuality 0&lt;/th>
&lt;th>sg.ShadowQuality 1&lt;/th>
&lt;th>sg.ShadowQuality 2&lt;/th>
&lt;th>sg.ShadowQuality 3&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r.LightFunctionQuality=0&lt;/td>
&lt;td>r.LightFunctionQuality=1&lt;/td>
&lt;td>r.LightFunctionQuality=1&lt;/td>
&lt;td>r.LightFunctionQuality=1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.ShadowQuality=0&lt;/td>
&lt;td>r.ShadowQuality=2&lt;/td>
&lt;td>r.ShadowQuality=5&lt;/td>
&lt;td>r.ShadowQuality=5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.CSM.MaxCascades=1&lt;/td>
&lt;td>r.Shadow.CSM.MaxCascades=1&lt;/td>
&lt;td>r.Shadow.CSM.MaxCascades=2&lt;/td>
&lt;td>r.Shadow.CSM.MaxCascades=4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.MaxResolution=512&lt;/td>
&lt;td>r.Shadow.MaxResolution=1024&lt;/td>
&lt;td>r.Shadow.MaxResolution=1024&lt;/td>
&lt;td>r.Shadow.MaxResolution=1024&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.RadiusThreshold=0.06&lt;/td>
&lt;td>r.Shadow.RadiusThreshold=0.05&lt;/td>
&lt;td>r.Shadow.RadiusThreshold=0.03&lt;/td>
&lt;td>r.Shadow.RadiusThreshold=0.03&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.DistanceScale=0.6&lt;/td>
&lt;td>r.Shadow.DistanceScale=0.7&lt;/td>
&lt;td>r.Shadow.DistanceScale=0.85&lt;/td>
&lt;td>r.Shadow.DistanceScale=1.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r.Shadow.CSM.TransitionScale=0&lt;/td>
&lt;td>r.Shadow.CSM.TransitionScale=0.25&lt;/td>
&lt;td>r.Shadow.CSM.TransitionScale=0.8&lt;/td>
&lt;td>r.Shadow.CSM.TransitionScale=1.0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="纹理sgtexturequality">纹理——sg.TextureQuality
&lt;/h1>&lt;p>主流渲染引擎需要更多GPU内存（纹理、网格体、GBuffer、深度缓冲、阴影贴图）。其中一些根据屏幕分辨率缩放（例如GBuffer），另一些有特定的质量设置（例如，阴影贴图）。使用大量GPU内存的另一个因素是所用的纹理（通常压缩并流送）。您可以指示流送系统在管理上更主动一些（缩小池大小、剔除不用的纹理），或者在mip等级计算中拥有更少或更多细节。这样会影响图像质量、您能够注意到的纹理流送瑕疵数量以及游戏的运行流畅度（更新需要高成本内存传输）。结果不尽相同，具体取决于介质（例如，更快/更慢的硬盘/SSD）。从DVD/蓝光流送会大幅增加延迟，因此应当尽量避免。&lt;/p></description></item><item><title>世界分区</title><link>https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/ue5-hero.png" alt="Featured image of post 世界分区" />&lt;p>以往开发者在制作大型地图时，需要手动将其分为多个子关卡，然后在玩家穿越地形时使用关卡流送系统加载和卸载子关卡。 这样的方法往往导致多用户共用文件的问题，并且使得开发者难以同时审视整个地图。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/world-partition-in-fortnite.jpg"
width="1400"
height="788"
srcset="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/world-partition-in-fortnite_hu_91d1eb2243962d14.jpg 480w, https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/world-partition-in-fortnite_hu_ff0e820879f3d089.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>世界分区是一种自动数据管理和基于距离的关卡流送系统，为大型世界管理提供了完整的解决方案。 以前需要将单个持久关卡中的世界存储到网格单元格中，以便将大型关卡划分成子关卡，但现在的系统已经不需要如此操作，并且你能够使用自动流送系统，根据与流送源的距离来加载和卸载这些单元格。&lt;/p>
&lt;p>世界分区常常与以下功能搭配使用:&lt;/p>
&lt;ul>
&lt;li>一Actor一文件&lt;/li>
&lt;li>世界分区 - 数据层&lt;/li>
&lt;li>关卡实例&lt;/li>
&lt;li>世界分区 - 分层细节级别&lt;/li>
&lt;/ul>
&lt;h1 id="启用世界分区">启用世界分区
&lt;/h1>&lt;p>在虚幻引擎中启用世界分区的三种方法：&lt;/p>
&lt;ul>
&lt;li>使用游戏（Games）类别下的模板创建新项目。&lt;/li>
&lt;li>使用开放世界（Open World）模板创建新关卡。&lt;/li>
&lt;li>转换已有的关卡来使用世界分区。&lt;/li>
&lt;/ul>
&lt;h2 id="使用游戏模板创建你的项目">使用游戏模板创建你的项目
&lt;/h2>&lt;p>在游戏（Games）类目下的很多项目模板中，世界分区默认启用。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/create-project-template.png"
width="1400"
height="745"
srcset="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/create-project-template_hu_ded071323ed18978.png 480w, https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/create-project-template_hu_a880a6b477f82ce0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="451px"
>&lt;/p>
&lt;p>为了在创建新项目时化繁为简并提供可伸缩的解决方案，可使用世界设置（World Settings）下的启用流送（Enable Streaming）选项来启用或禁用网格单元格流送。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/enable-streaming.png"
width="417"
height="368"
srcset="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/enable-streaming_hu_db23652c95ed213f.png 480w, https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/enable-streaming_hu_1c88cab79037b656.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="271px"
>&lt;/p>
&lt;p>以下模板使用世界分区，但默认禁用启用流送（Enable Streaming）选项：&lt;/p>
&lt;ul>
&lt;li>空白（Blank）&lt;/li>
&lt;li>第一人称（First Person）&lt;/li>
&lt;li>第三人称（Third Person）&lt;/li>
&lt;li>俯视角（Top Down）&lt;/li>
&lt;li>高级载具（Vehicle Advanced）&lt;/li>
&lt;/ul>
&lt;h2 id="使用开放世界默认地图">使用开放世界默认地图
&lt;/h2>&lt;p>默认的开放世界（Open World）地图被设计为创建大型开放世界地图的起始参考，并且默认启用以下功能：&lt;/p>
&lt;ul>
&lt;li>世界分区&lt;/li>
&lt;li>一Actor一文件&lt;/li>
&lt;li>数据层&lt;/li>
&lt;li>分层细节级别&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/open-world-template.png"
width="1400"
height="733"
srcset="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/open-world-template_hu_9e8c218be7df2c.png 480w, https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/open-world-template_hu_9b87ccecafb50724.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="458px"
>&lt;/p>
&lt;p>该地图包括一个2km x 2km的地形示例，采用户外环境的地形材质和光照设定。 包括天空大气系统、天空光照、定向光源、指数高度雾、体积云。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/open-world-new-map.png"
width="533"
height="448"
srcset="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/open-world-new-map_hu_37b92cc47f74a1f4.png 480w, https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/open-world-new-map_hu_885c0f899c399548.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="118"
data-flex-basis="285px"
>&lt;/p>
&lt;p>在你的项目中使用默认的开放世界（Open World）类型地图：&lt;/p>
&lt;ol>
&lt;li>打开文件（File）菜单并选择新关卡（New Level）。&lt;/li>
&lt;li>选择开放世界（Open World）地图类型。&lt;/li>
&lt;li>点击创建（Create）按钮创建新地图。&lt;/li>
&lt;/ol>
&lt;h2 id="转换已有的关卡来使用世界分区">转换已有的关卡来使用世界分区
&lt;/h2>&lt;p>你可以使用工具（Tools）&amp;gt; 转换关卡（Convert Level）选项向任何关卡添加世界分区，或者使用世界分区转换Commandlet。&lt;/p>
&lt;p>使用世界分区转换Commandlet的步骤如下：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/commandlet-format-wp.png"
width="1400"
height="788"
srcset="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/commandlet-format-wp_hu_6552d1ba984b1c4.png 480w, https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/commandlet-format-wp_hu_b826c870e6b3c64f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>命令：&lt;code>UnrealEditor.exe QAGame -run=WorldPartitionConvertCommandlet Playground.umap -AllowCommandletRendering&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[/Script/UnrealEd.WorldPartitionConvertCommandlet]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> EditorHashClass=Class&amp;#39;/Script/Engine.WorldPartitionEditorSpatialHash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RuntimeHashClass=Class&amp;#39;/Script/Engine.WorldPartitionRuntimeSpatialHash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> LevelsGridPlacement=((&amp;#34;/Game/Maps/Highrise_Audio&amp;#34;, Bounds),(&amp;#34;/Game/Maps/Highrise_Collisions_Temp&amp;#34;, Bounds),(&amp;#34;/Game/Maps/Highrise_Gameplay&amp;#34;, Bounds),(&amp;#34;/Game/Maps/Highrise_Lights&amp;#34;, Bounds),(&amp;#34;/Game/Maps/Highrise_Vista&amp;#34;, AlwaysLoaded))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> HLODLayerAssetsPath=
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> DefaultHLODLayerName=
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [/Script/Engine.WorldPartitionEditorSpatialHash]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> CellSize=51200
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WorldImage=None
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WorldImageTopLeftW=(X=0.000000,Y=0.000000)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WorldImageBottomRightW=(X=0.000000,Y=0.000000)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [/Script/Engine.WorldPartitionRuntimeSpatialHash]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Grids=(GridName=&amp;#34;MainGrid&amp;#34;,CellSize=3200,LoadingRange=25600.000000,DebugColor=(R=0.500000,G=0.500000,B=0.500000,A=1.000000))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="使用世界分区">使用世界分区
&lt;/h1>&lt;p>世界分区系统将创建的世界储存在一个持久关卡文件中，并且使用可配置的运行时网格将空间划分为可流送的网格单元。 这些网格单元在运行时由流送源（比如玩家）控制加载和卸载。 这样一来，虚幻引擎只加载关卡中玩家能看到并与之互动的部分。&lt;/p>
&lt;h2 id="世界分区中的actor">世界分区中的Actor
&lt;/h2>&lt;p>编辑世界时，Actor可以被加入到任何地点，并根据其空间化加载（Is Spatially Loaded）的设置被自动分配至网格单元。该选项位于Actor细节（Details）面板的世界分区（World Partition）分段。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/world-partition-actor-options.png"
width="432"
height="607"
srcset="https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/world-partition-actor-options_hu_5f80f8adb3fc6de4.png 480w, https://zentia.github.io/p/%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/world-partition-actor-options_hu_3a92bc34823f8df0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="71"
data-flex-basis="170px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>选项&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>运行时网格（Runtime Grid）&lt;/td>
&lt;td>判定Actor被放置在哪一个分区网格。 如果为无（None），网格将会由分区系统决定。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>空间化加载（Is Spatially Loaded）&lt;/td>
&lt;td>确定Actor是否为空间化加载：若启用，该Actor将会在进入任何流送源的范围内且并未被分配至禁用的数据层时加载。若禁用，则只要没有被分配至禁用的数据层，该Actor就会被加载。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>体积雾</title><link>https://zentia.github.io/p/%E4%BD%93%E7%A7%AF%E9%9B%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BD%93%E7%A7%AF%E9%9B%BE/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BD%93%E7%A7%AF%E9%9B%BE/ue5-hero.png" alt="Featured image of post 体积雾" />&lt;p>体积雾（Volumetric Fog）时指数高度雾组件的一个部分。体积雾（Volumetric Fog）将计算摄像机视锥体中每个点的参与介质密度和照明，以支持不同的密度和影响雾的任意数量光源。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%93%E7%A7%AF%E9%9B%BE/volumetricfog.png"
width="947"
height="542"
srcset="https://zentia.github.io/p/%E4%BD%93%E7%A7%AF%E9%9B%BE/volumetricfog_hu_c0727b36b4fd701c.png 480w, https://zentia.github.io/p/%E4%BD%93%E7%A7%AF%E9%9B%BE/volumetricfog_hu_820a4bb94b1cc3d5.png 1024w"
loading="lazy"
alt="此场景中的体积雾来自于穿过拱门的定向光源，在周边区域中生成带阴影效果的雾气。"
class="gallery-image"
data-flex-grow="174"
data-flex-basis="419px"
>&lt;/p>
&lt;h1 id="体积雾控制">体积雾控制
&lt;/h1>&lt;p>设置和调整体积雾时，你可以全局控制它，也可以在场景中局部控制它。全局控制功能使你能够使用指数高度雾（Exponential Height Fog）组件控制整个场景的雾。局部控制功能使你能够通过在可以生成粒子的区域中使用粒子的方式控制雾。&lt;/p>
&lt;h2 id="全局控制">全局控制
&lt;/h2>&lt;p>要控制体积雾，你可以调整指数高度雾（Exponential Height Fog）中的属性和每个光源上的属性，以控制光源的贡献量。&lt;/p>
&lt;h2 id="指数高度雾">指数高度雾
&lt;/h2>&lt;h1 id="性能">性能
&lt;/h1>&lt;p>体积雾的GPU开销主要通过体积纹理分辨率控制，可在引擎可延展性的阴影级别设置它。&lt;/p></description></item><item><title>材质输入</title><link>https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E8%BE%93%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E8%BE%93%E5%85%A5/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E8%BE%93%E5%85%A5/ue5-hero.png" alt="Featured image of post 材质输入" />&lt;h1 id="输入和材质设置">输入和材质设置
&lt;/h1>&lt;p>当你在细节面板中更改特定材质属性时，你会发现主材质节点中的一些输入会变成白色（表示它们已启用），而其他则是不可用状态。&lt;/p>
&lt;p>以下三个属性控制材质中哪些输入可以启用：&lt;/p>
&lt;ul>
&lt;li>混合模式（Blend Mode）：控制材质如何与其背后（底下）的像素进行混合。&lt;/li>
&lt;li>着色模型（Shading Modle）：控制如何计算材质表面的光照效果。&lt;/li>
&lt;li>材质域（Material Domain）：控制材质的用途，例如，是作为表面一部分，是用作光照函数，还是用作后期处理材质。&lt;/li>
&lt;/ul>
&lt;h1 id="base-color">Base Color
&lt;/h1>&lt;p>Base Color定义了材质的整体颜色。原则上，Base Color表示的是表面反射的漫反射光，不包含任何镜面反射/高光效果。&lt;/p></description></item><item><title>处理音频</title><link>https://zentia.github.io/p/%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91/audio_landing_banner.png" alt="Featured image of post 处理音频" /></description></item><item><title>创建有光泽的材质</title><link>https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E6%9C%89%E5%85%89%E6%B3%BD%E7%9A%84%E6%9D%90%E8%B4%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E6%9C%89%E5%85%89%E6%B3%BD%E7%9A%84%E6%9D%90%E8%B4%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%88%9B%E5%BB%BA%E6%9C%89%E5%85%89%E6%B3%BD%E7%9A%84%E6%9D%90%E8%B4%A8/ue5-hero.png" alt="Featured image of post 创建有光泽的材质" />&lt;p>现实世界中的每个物体都有一定程序的光泽。在一些情况下这种光泽（或者反射度）很明显，比如镜子、镀铬或者玻璃。其它情况下光泽的差异比较细微，比如刷漆的木头，平整但不光滑的石头或者水泥。&lt;/p></description></item><item><title>使用折射</title><link>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%8A%98%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%8A%98%E5%B0%84/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E6%8A%98%E5%B0%84/ue5-hero.png" alt="Featured image of post 使用折射" />&lt;p>在项目开发中，你可能需要用到自发光材质或发光材质。在UE中，Self-Illuminated和Emissive材质均称为自发光材质。&lt;/p></description></item><item><title>在材质中使用次表面轮廓</title><link>https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AC%A1%E8%A1%A8%E9%9D%A2%E8%BD%AE%E5%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AC%A1%E8%A1%A8%E9%9D%A2%E8%BD%AE%E5%BB%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AC%A1%E8%A1%A8%E9%9D%A2%E8%BD%AE%E5%BB%93/ue5-hero.png" alt="Featured image of post 在材质中使用次表面轮廓" />&lt;p>在项目开发中，你可能需要用到自发光材质或发光材质。在UE中，Self-Illuminated和Emissive材质均称为自发光材质。&lt;/p></description></item><item><title>在材质中使用次表面散射</title><link>https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AC%A1%E8%A1%A8%E9%9D%A2%E6%95%A3%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AC%A1%E8%A1%A8%E9%9D%A2%E6%95%A3%E5%B0%84/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AC%A1%E8%A1%A8%E9%9D%A2%E6%95%A3%E5%B0%84/ue5-hero.png" alt="Featured image of post 在材质中使用次表面散射" />&lt;p>在项目开发中，你可能需要用到自发光材质或发光材质。在UE中，Self-Illuminated和Emissive材质均称为自发光材质。&lt;/p></description></item><item><title>在材质中使用透明度</title><link>https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%8F%E6%98%8E%E5%BA%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%8F%E6%98%8E%E5%BA%A6/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9C%A8%E6%9D%90%E8%B4%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%8F%E6%98%8E%E5%BA%A6/ue5-hero.png" alt="Featured image of post 在材质中使用透明度" />&lt;p>在项目开发中，你可能需要用到自发光材质或发光材质。在UE中，Self-Illuminated和Emissive材质均称为自发光材质。&lt;/p></description></item><item><title>Core Redirects</title><link>https://zentia.github.io/p/core-redirects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/core-redirects/</guid><description>&lt;img src="https://zentia.github.io/p/core-redirects/ue5-hero.png" alt="Featured image of post Core Redirects" /></description></item><item><title>编程子系统</title><link>https://zentia.github.io/p/%E7%BC%96%E7%A8%8B%E5%AD%90%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BC%96%E7%A8%8B%E5%AD%90%E7%B3%BB%E7%BB%9F/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BC%96%E7%A8%8B%E5%AD%90%E7%B3%BB%E7%BB%9F/ue5-hero.png" alt="Featured image of post 编程子系统" /></description></item><item><title>材质数据类型</title><link>https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%9D%90%E8%B4%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ue5-hero.png" alt="Featured image of post 材质数据类型" />&lt;p>数据在材质编辑器中表示和操作方式是虚幻引擎材质中很重要的一个概念。&lt;/p></description></item><item><title>动画插槽</title><link>https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E6%8F%92%E6%A7%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E6%8F%92%E6%A7%BD/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E6%8F%92%E6%A7%BD/ue5-hero.png" alt="Featured image of post 动画插槽" />&lt;p>为角色创建复杂的动画时，可能需要在动画蓝图中创建代理区域用来插入一次性的动画。为此可以使用 插槽（Slots），这是一种可以添加至动画蓝图各处的节点，用于叠加并播放动画。插槽通常和动画蒙太奇一起使用，但也可以与Sequencer一起使用。&lt;/p></description></item><item><title>动画蒙太奇</title><link>https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E8%92%99%E5%A4%AA%E5%A5%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E8%92%99%E5%A4%AA%E5%A5%87/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E8%92%99%E5%A4%AA%E5%A5%87/ue5-hero.png" alt="Featured image of post 动画蒙太奇" />&lt;p>你可以使用动画蒙太奇（Animation Montage）（简称蒙太奇（Montage））来讲多个动画序列（Animation Sequence）合并为单个资产并通过蓝图播放。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E8%92%99%E5%A4%AA%E5%A5%87/montagedemo.gif"
width="1060"
height="535"
srcset="https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E8%92%99%E5%A4%AA%E5%A5%87/montagedemo_hu_603da3b7f909075d.gif 480w, https://zentia.github.io/p/%E5%8A%A8%E7%94%BB%E8%92%99%E5%A4%AA%E5%A5%87/montagedemo_hu_ceb3b24a67a5a715.gif 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="475px"
>&lt;/p>
&lt;p>蒙太奇除了可以让你将多个动画序列合并为动画外，还可以切分多个蒙太奇分段（Montage Sections），以便在运行时，按一定逻辑以任何顺序动态播放。&lt;/p></description></item><item><title>根运动</title><link>https://zentia.github.io/p/%E6%A0%B9%E8%BF%90%E5%8A%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%A0%B9%E8%BF%90%E5%8A%A8/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%A0%B9%E8%BF%90%E5%8A%A8/ue5-hero.png" alt="Featured image of post 根运动" />&lt;p>通过根运动（Root Motion）动画，你可以用动画数据驱动角色的动作，从而在关卡中创建更真实的动作。&lt;/p>
&lt;h1 id="先决条件">先决条件
&lt;/h1>&lt;ul>
&lt;li>你的项目需要包含一个角色，并且其骨架包含一个根骨骼。&lt;/li>
&lt;li>你的项目需要包含一个动画序列或者蒙太奇，并且为其骨架的根骨骼指定了动作数据。&lt;/li>
&lt;/ul></description></item><item><title>混合空间</title><link>https://zentia.github.io/p/%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4/ue5-hero.png" alt="Featured image of post 混合空间" />&lt;p>你可以使用动画蒙太奇（Animation Montage）（简称蒙太奇（Montage））来讲多个动画序列（Animation Sequence）合并为单个资产并通过蓝图播放。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4/montagedemo.gif"
width="1060"
height="535"
srcset="https://zentia.github.io/p/%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4/montagedemo_hu_603da3b7f909075d.gif 480w, https://zentia.github.io/p/%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4/montagedemo_hu_ceb3b24a67a5a715.gif 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="475px"
>&lt;/p>
&lt;p>蒙太奇除了可以让你将多个动画序列合并为动画外，还可以切分多个蒙太奇分段（Montage Sections），以便在运行时，按一定逻辑以任何顺序动态播放。&lt;/p></description></item><item><title>任务系统</title><link>https://zentia.github.io/p/%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/ue5-hero.png" alt="Featured image of post 任务系统" /></description></item><item><title>生成和销毁Actor</title><link>https://zentia.github.io/p/%E7%94%9F%E6%88%90%E5%92%8C%E9%94%80%E6%AF%81actor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%94%9F%E6%88%90%E5%92%8C%E9%94%80%E6%AF%81actor/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%94%9F%E6%88%90%E5%92%8C%E9%94%80%E6%AF%81actor/ue5-hero.png" alt="Featured image of post 生成和销毁Actor" />&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">AActor&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">UWorld&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">SpawnActor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">UClass&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Class&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">FName&lt;/span> &lt;span class="n">InName&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">FVector&lt;/span> &lt;span class="k">const&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Location&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">FRotator&lt;/span> &lt;span class="k">const&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Rotation&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AActor&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Template&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">bNoCollisionFail&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">bRemoteOwned&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AActor&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Owner&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">APawn&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Instigator&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">bNoFail&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ULevel&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">OverrideLevel&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">bDeferConstruction&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>使用弹簧臂组件</title><link>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E5%BC%B9%E7%B0%A7%E8%87%82%E7%BB%84%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E5%BC%B9%E7%B0%A7%E8%87%82%E7%BB%84%E4%BB%B6/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E5%BC%B9%E7%B0%A7%E8%87%82%E7%BB%84%E4%BB%B6/ue5-hero.png" alt="Featured image of post 使用弹簧臂组件" />&lt;p>在此操作指南教程中，你将添加弹簧臂组件（USpringArmComponent），并将其作为摄像机组件的父项。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E5%BC%B9%E7%B0%A7%E8%87%82%E7%BB%84%E4%BB%B6/springarm_shared1.gif"
width="640"
height="360"
srcset="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E5%BC%B9%E7%B0%A7%E8%87%82%E7%BB%84%E4%BB%B6/springarm_shared1_hu_1083b47c4e967914.gif 480w, https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E5%BC%B9%E7%B0%A7%E8%87%82%E7%BB%84%E4%BB%B6/springarm_shared1_hu_c26e11a820c741ea.gif 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p></description></item><item><title>使用媒体</title><link>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E5%AA%92%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E5%AA%92%E4%BD%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E4%BD%BF%E7%94%A8%E5%AA%92%E4%BD%93/bannerimage_workingwithmedia.png" alt="Featured image of post 使用媒体" /></description></item><item><title>图形编程</title><link>https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/ue5-hero.png" alt="Featured image of post 图形编程" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>引擎中的渲染器模块管理并渲染场景，而场景拥有和每个世界场景相关的可渲染信息。它包括所有绘制规则和着色器的定义。&lt;/p>
&lt;p>RHI 模块是渲染 API 的接口，是图形编程的另一个关键组件。图形编程介绍包含许多可研究的键类、设置和变量，以下子页面包含详细的渲染要点。&lt;/p></description></item><item><title>图形编程介绍</title><link>https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D/ue5-hero.png" alt="Featured image of post 图形编程介绍" />&lt;h1 id="入门">入门
&lt;/h1>&lt;p>虚幻引擎中有许多渲染代码，因此要通过粗略的观察来迅速了解渲染状况较为困难。阅读代码时，比较好的入手之处是&lt;code>FDefferedShadingSceneRenderer::Render&lt;/code>，这是渲染线程中渲染新帧之处。此外，执行profilegpu命令并查看绘制事件也很有帮助。然后，您可以在Visual Studio中对绘制事件名称进行Find in Files操作，找出对应的C++实现。&lt;/p></description></item><item><title>线程渲染</title><link>https://zentia.github.io/p/%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/ue5-hero.png" alt="Featured image of post 线程渲染" />&lt;h1 id="渲染线程">渲染线程
&lt;/h1>&lt;p>在虚幻引擎中，整个渲染器在其自身的线程中执行操作，该线程位于游戏线程的一两帧后。&lt;/p>
&lt;p>执行渲染操作时，必须仔细地考虑内存读写，确保线程安全，以及行为的确定性。功能行为取决于两个线程之间的执行速度差，这种情况被称作竞争条件。需要尽量避免竞争条件的出现，因为它们难以重现；且因为速度差的缘故，它们可能依赖于机器、平台、调试器或配置。这类 bug 很难进行调试，所花费的修复时间约为可重现的普通 bug 的 10 倍。&lt;/p></description></item><item><title>移动组件</title><link>https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E7%BB%84%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E7%BB%84%E4%BB%B6/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%A7%BB%E5%8A%A8%E7%BB%84%E4%BB%B6/ue5-hero.png" alt="Featured image of post 移动组件" />&lt;p>在此操作指南教程中，你将添加弹簧臂组件（USpringArmComponent），并将其作为摄像机组件的父项。&lt;/p></description></item><item><title>着色器开发</title><link>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91/ue5-hero.png" alt="Featured image of post 着色器开发" />&lt;h1 id="快速入门">快速入门
&lt;/h1>&lt;p>处理着色器时，请务必将&lt;code>r.ShaderDevelopmentMode&lt;/code>设置为1，以将其启用。最简单的方法是编辑&lt;code>ConsoleVariables.ini&lt;/code>，以便每次加载时都进行启用。这将启用“出错时重试”以及与着色器开发的日志和警告。&lt;/p>
&lt;p>请使用&lt;code>Ctrl+Shift+.&lt;/code>，这样会执行recompileshaders changed命令。这个命令应该在你将更改保存到Unreal Shader (.usf)文件后执行。&lt;/p></description></item><item><title>资产异步加载</title><link>https://zentia.github.io/p/%E8%B5%84%E4%BA%A7%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%B5%84%E4%BA%A7%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%B5%84%E4%BA%A7%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/ue5-hero.png" alt="Featured image of post 资产异步加载" />&lt;p>虚幻引擎（UE）中有很多方法可以简化资产数据的异步加载流程。这些新方法在开发中以及对设备上的烘培数据的作用相同，因此无需维护两条按需加载数据的代码路径。按需引用和加载数据通常有两种方法：&lt;/p>
&lt;h1 id="fsoftobjectpaths和tsoftobjectptr">FSoftObjectPaths和TSoftObjectPtr
&lt;/h1>&lt;h1 id="资源注册表和对象库">资源注册表和对象库
&lt;/h1>&lt;h1 id="streamablemanager和异步加载">StreamableManager和异步加载
&lt;/h1></description></item><item><title>建立你的开发流程</title><link>https://zentia.github.io/p/%E5%BB%BA%E7%AB%8B%E4%BD%A0%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%BB%BA%E7%AB%8B%E4%BD%A0%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%BB%BA%E7%AB%8B%E4%BD%A0%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/productionpipelines-topicimg.png" alt="Featured image of post 建立你的开发流程" /></description></item><item><title>屏幕百分比与时序上采样</title><link>https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/ue5-hero.png" alt="Featured image of post 屏幕百分比与时序上采样" />&lt;p>屏幕百分比 是一种分辨率调节技术，用于渲染分辨率低于或高于实际显示图像的图像。通过调节屏幕百分比，你的游戏可以在性能和图像分辨率之间保持平衡。&lt;/p>
&lt;p>在虚幻引擎4（UE4）4.19版之前，你只需要更改屏幕百分比，但现在它分成了渲染管道中的两类缩放：主要和次要空间放大。&lt;/p>
&lt;ul>
&lt;li>主要空间放大（Primary Spatial Upscaling） 就是以前使用的屏幕百分比功能。它的基本理念是以较低的分辨率渲染画面，然后先放大，再绘制用户界面（UI）。&lt;/li>
&lt;li>次要空间放大（Secondary Spatial Upscaling） 执行第二次也是最终的空间放大传递，与主要放大传递无关。&lt;/li>
&lt;/ul>
&lt;h1 id="主要屏幕百分比">主要屏幕百分比
&lt;/h1>&lt;p>主要空间放大（即主要屏幕百分比）的工作方式是按屏幕百分比渲染屏幕分辨率，然后进行缩放以适应你的当前屏幕分辨率。如果使用较低的屏幕百分比（或较低的分辨率），然后放大，就称为上采样。或者，在屏幕百分比增大之后（按较高的分辨率渲染），会缩小到当前屏幕的分辨率，这称为 超级取样。这一切都发生在绘制用户界面（UI）之前，可能对性能产生影响。&lt;/p>
&lt;p>关于屏幕分辨率如何对组成屏幕上所渲染图像的所有缓冲区渲染目标起作用并使其组成一个GPU帧的概念，可以作如下说明：&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/noupscaling.png"
width="3438"
height="756"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/noupscaling_hu_a56b0b94ff49f685.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/noupscaling_hu_68d8d1e071c3ada9.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="454"
data-flex-basis="1091px"
>&lt;/p>
&lt;p>对于每个GPU帧，所有渲染目标在管道中自始至终使用其全分辨率。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialupscale.png"
width="3846"
height="894"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialupscale_hu_fd607ba54dfd06c.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialupscale_hu_d615b3a5f061052b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="430"
data-flex-basis="1032px"
>&lt;/p>
&lt;p>在使用空间放大的情况下，在UI之前绘制的一切都根据所用的屏幕百分比使用或高或低的分辨率。屏幕百分比已经降低（从UI之前变窄的渲染目标可以看出），为渲染目标产生了降低分辨率的图像。空间缩放发生在UI之前，将图像缩放至将要输出的屏幕分辨率。例如，如果当前分辨率设置为1920x1080，并且使用83%的屏幕分辨率，那么渲染目标的大小将调整为近似的1600x900分辨率，然后重新放大到1920x1080。&lt;/p>
&lt;h2 id="空间放大质量">空间放大质量
&lt;/h2>&lt;p>在放大渲染目标时，可以使用以下控制台变量定义放大质量：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.Upscale.Quality
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它控制屏幕百分比和全屏窗口模式缩放3D渲染的质量&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>上采样质量数值&lt;/th>
&lt;th>上采样结果&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>最接近的过滤&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>简单双线&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>定向模糊，带有非锐化遮罩上采样&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>5-tap Catmull-Rom双立方插值，近似Lanczos 2（默认）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>13-tap Lanczos 3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>36-tap高斯过滤非锐化遮罩（成本非常高，但很适合极端上采样）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>或者，你可以使用下列控制台变量来控制如何处理色调映射器传递：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.Tonemapper.MergeWithUpscale.Mode
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>色调映射器集成了一个简单的颜色空间空间放大，可以因为性能原因而使用值 1 来启用它。但是，如果材质后期处理在色调映射器之后插入，那么色调映射器就不会执行放大。它将重新使用主要空间放大，就像被禁用了一样。&lt;/p>
&lt;h1 id="时序抗锯齿上采样">时序抗锯齿上采样
&lt;/h1>&lt;p>除了主要空间放大外，主要屏幕分辨率还支持第二种放大技术：时序上采样。在时序抗锯齿上采样（TAAU）中，不是先使用时序抗锯齿（TAA）执行临时集成，然后再执行主要空间放大，实际上这两者是同时发生的。它们也可以收敛为比仅使用空间放大时更锐利的图像，不过这样做的成本也会比较高，因为要在较高的分辨率下运行更多后期处理。动态分辨率还可以隐藏主要屏幕百分比更改，从而更频繁地进行更改，尽可能接近地匹配GPU预算。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialandtemporalupsample.png"
width="3438"
height="900"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialandtemporalupsample_hu_c8f09a40596542b4.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/spatialandtemporalupsample_hu_ddb8b500a85c5109.png 1024w"
loading="lazy"
alt="TAAU在管道中发生得比较早，这导致在其后的传递会以较高的分辨率渲染，因此以较高的成本产生更为锐利的图像。"
class="gallery-image"
data-flex-grow="382"
data-flex-basis="916px"
>&lt;/p>
&lt;p>应该注意的是，在使用时序上采样时，不同的后期处理顺序不会因为增加TAAU而改变，因为它只是取代了TAA。真正的差别是，在TAAU之前进行的所有处理都将先使用较低的分辨率，然后上采样到TAAU传递之后的分辨率。在4.19版之前，是假定后期处理中的分辨率始终不变。&lt;/p>
&lt;blockquote>
&lt;p>在主要屏幕百分比降低后，到干净的全分辨率输出的收敛会改变。因此，一些原有的TAA瑕疵会变得更明显。例如在非常细的几何体上，锯齿可能成为问题，增加在降低主要屏幕百分比时丢失此几何体细节的概率。&lt;/p>&lt;/blockquote>
&lt;h2 id="启用时序上采样">启用时序上采样
&lt;/h2>&lt;p>要使用时序抗锯齿上采样，你需要进入&amp;quot;项目设置（Project Setting）&amp;ldquo;中找到 时序上采样（Temporal Upsampling），更简单的办法是使用下列控制台变量：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.TemporalAA.Upsampling 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果使用空间放大的主要屏幕百分比较低，在降低分辨率时，可能丢失重要细节。例如，对于铁链栅栏或者车头的格栅，当使用时序抗锯齿时，可能在较远的距离比较难以看清细节。如果启用TAAU，就可以在仍然使用降低的屏幕百分比的情况下减少这一问题。&lt;/p>
&lt;h2 id="automatic-view-texture-mip-bias">Automatic View Texture Mip Bias
&lt;/h2>&lt;p>因为屏幕百分比会导致几何体以较低的像素密度渲染，所以时序上采样需要更多来自 表面 和 延迟贴花 材质域的纹理信息才能保持输出锐利度不变。为此，在默认情况下可以使用纹理取样表达式 Automatic View Mip Bias。&lt;/p>
&lt;p>纹理取样表达式可使用 Automatic View Mip Bias 来切换是否应该通过逐视图的Mip偏差对纹理进行取样，从而使时序抗锯齿具有更锐利的输出。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbias.png"
width="738"
height="341"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbias_hu_1bd7afd8befa9033.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbias_hu_b711cde2c84d739e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;p>对于高频纹理（例如下面的示例），自动Mip偏差在较低的屏幕百分比下可能问题较多。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/hftexture.png"
width="512"
height="512"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/hftexture_hu_58bc6f70ef516626.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/hftexture_hu_72b2ecfa6ec94149.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>&lt;/p>
&lt;p>在这种情况下，可以使用Mip偏差输入来补偿，或者选择不使用 Automatic View Mip Bias。&lt;/p>
&lt;p>&lt;img src="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbiasunchecked.png"
width="738"
height="341"
srcset="https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbiasunchecked_hu_2d727bab8ab3de8d.png 480w, https://zentia.github.io/p/%E5%B1%8F%E5%B9%95%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B8%8A%E9%87%87%E6%A0%B7/automaticviewmipbiasunchecked_hu_dc4107ed014c88b3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;blockquote>
&lt;p>Automatic View Mip Bias 仅发生在启用TAAU的情况下。常规抗锯齿方法（TAA、MSAA和FXAA）将无法使用此选项。&lt;/p>&lt;/blockquote>
&lt;h2 id="实现抗锯齿质量的着色器性能permutation">实现抗锯齿质量的着色器性能Permutation
&lt;/h2>&lt;p>和TAA一样，临时放大采样附带用于实现后期处理质量3和4的更快着色器Permutation。着色器Permutation换来的是一定的质量，能够在主机平台上发布60Hz运行的作品。质量设置与设置后期处理质量时已经使用的设置相似。此外还应牢记，TAAU需要比TAA更多的工作，因为它是在较高的分辨率下运行，并且在TAAU传递之后还有后期处理。&lt;/p>
&lt;p>可以使用下列控制台变量调节后期处理质量：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">r.PostProcessAAQuality
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>值得注意的是，时序上采样之后的后期处理是在全分辨率下运行的，所以禁用TAA将使它们在较低的分辨率下运行，这是因为它们将在最后进行空间放大，从而加快后期处理的速度。请使用命令profileGPU来调查每次传递中GPU性能的明细，使用的是什么传递，以及大部分预算用在哪里。&lt;/p>
&lt;p>下表说明了使用这些范围中的主要屏幕百分比值设置时你可以期待的结果：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>屏幕范围&lt;/th>
&lt;th>百分比&lt;/th>
&lt;th>备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>50%&lt;/td>
&lt;td>71%&lt;/td>
&lt;td>这是提高性能的最快方法，因为它在内存中使用较小的本地数据存储（LDS）块。如果目标是在台式机和游戏机上时序上采样到4K，这是理想的选择。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>71%&lt;/td>
&lt;td>100%&lt;/td>
&lt;td>对于台式机和游戏机上的普通DPI（每英寸点数）渲染是理想选择。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>100%&lt;/td>
&lt;td>200%&lt;/td>
&lt;td>如果要使动态分辨率在不被用于渲染目标的GPU内存限制的前提下具有超过100%的理论可能，那么这是理想选择。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>纹理流送</title><link>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81/</guid><description>&lt;img src="https://zentia.github.io/p/%E7%BA%B9%E7%90%86%E6%B5%81%E9%80%81/ue5-hero.png" alt="Featured image of post 纹理流送" />&lt;p>纹理流送系统，又称纹理流送器，是引擎中负责提高和降低每个纹理分辨率的部分。这能让你有用出色的视觉效果的同时，可以有效管理内存。&lt;/p>
&lt;h1 id="入门">入门
&lt;/h1></description></item><item><title>分享和发布项目</title><link>https://zentia.github.io/p/%E5%88%86%E4%BA%AB%E5%92%8C%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%88%86%E4%BA%AB%E5%92%8C%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%88%86%E4%BA%AB%E5%92%8C%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE/ue5-hero.png" alt="Featured image of post 分享和发布项目" /></description></item><item><title>虚拟纹理</title><link>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/</guid><description>&lt;img src="https://zentia.github.io/p/%E8%99%9A%E6%8B%9F%E7%BA%B9%E7%90%86/ue5-hero.png" alt="Featured image of post 虚拟纹理" />&lt;p>利用项目对虚拟纹理的这次hi，可在运行时以更低内存占用率和更高一致性创建和使用大尺寸纹理。&lt;/p>
&lt;h1 id="虚拟纹理方法">虚拟纹理方法
&lt;/h1>&lt;p>虚幻引擎4(UE4)支持两种虚拟纹理方法：运行时虚拟纹理 (RVT) 和 流送虚拟纹理 (SVT)。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运行时虚拟纹理&lt;/th>
&lt;th>流送虚拟纹理&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>支持超高纹理分辨率。&lt;/td>
&lt;td>支持超高纹理分辨率。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>按需将纹素数据缓存于内存中。&lt;/td>
&lt;td>按需将纹素数据缓存于内存中。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>运行时由GPU生成的纹素数据。&lt;/td>
&lt;td>在硬盘中烘焙和加载纹素数据。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>非常适用于可按需渲染的纹理数据，如过程纹理或合成分层材质。&lt;/td>
&lt;td>非常适用于生成时间较长的纹理数据，如光照贴图或美术师创建的大型细节纹理。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="运行时虚拟纹理">运行时虚拟纹理
&lt;/h2>&lt;p>利用 运行时虚拟纹理 可有效渲染过程生成或分层的复杂材质，使运行时虚拟纹理适用于渲染复杂的地形材质。其能改善地形样条、网格体和材质贴花，及一般地形与对象混合的渲染性能和工作流程。&lt;/p>
&lt;blockquote>
&lt;p>欲了解更多详情，参见运行时虚拟纹理。&lt;/p>&lt;/blockquote></description></item><item><title>光照半透明</title><link>https://zentia.github.io/p/%E5%85%89%E7%85%A7%E5%8D%8A%E9%80%8F%E6%98%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%85%89%E7%85%A7%E5%8D%8A%E9%80%8F%E6%98%8E/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%85%89%E7%85%A7%E5%8D%8A%E9%80%8F%E6%98%8E/ue5-hero.png" alt="Featured image of post 光照半透明" />&lt;p>半透明效果通常可以归为几类：体积类、稠密到足以具备法线信息的体积类，以及表面类。每一类都需要不同的光照技术，因此材质必须指定应该使用的半透明光照模式。&lt;/p>
&lt;p>光照半透明的大部分光照是通过一系列围绕视锥体定向的级联体积纹理获得的。因此对于体积内部的任何一个点，都可以通过一次正向传递了解光照信息，但缺点是体积纹理的分辨率相当低，而且智能覆盖以观察者为起点的有限景深范围。&lt;/p></description></item><item><title>可视性和遮挡剔除</title><link>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%8F%AF%E8%A7%86%E6%80%A7%E5%92%8C%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4/randg_herobanner.png" alt="Featured image of post 可视性和遮挡剔除" />&lt;p>虚幻引擎提供了可视性和遮挡剔除方法。这些剔除方法用于优化游戏性能。每种方法都可以通过设置是否应绘制到屏幕上来减少关卡中的可见Actor数量。部分方法（如视锥体和硬件遮挡查询）可以同时使用，或者更好的适应特定设备和平台（如用于虚拟显示的轮询遮挡）。&lt;/p></description></item><item><title>剔除距离体积</title><link>https://zentia.github.io/p/%E5%89%94%E9%99%A4%E8%B7%9D%E7%A6%BB%E4%BD%93%E7%A7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E5%89%94%E9%99%A4%E8%B7%9D%E7%A6%BB%E4%BD%93%E7%A7%AF/</guid><description>&lt;img src="https://zentia.github.io/p/%E5%89%94%E9%99%A4%E8%B7%9D%E7%A6%BB%E4%BD%93%E7%A7%AF/randg_herobanner.png" alt="Featured image of post 剔除距离体积" />&lt;p>剔除距离体积（Cull Distance Volume） 是非常有用的优化工具，它定义绘制（显现）该体积中的Actor的距离。这些体积可存储任意数量的&amp;quot;大小&amp;quot;和&amp;quot;距离&amp;quot;组合（称为 剔除距离对）。这些剔除距离对会被映射到Actor（沿其最长有效维度）的边界，然后指定给关卡中的该Actor实例。剔除距离体积（Cull Distance Volume）对于优化包含精细内部空间的大型室外关卡非常有用。当室内空间小到可被视为不重要时，可以剔除它们。&lt;/p></description></item><item><title>构建HLOD网格体</title><link>https://zentia.github.io/p/%E6%9E%84%E5%BB%BAhlod%E7%BD%91%E6%A0%BC%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%9E%84%E5%BB%BAhlod%E7%BD%91%E6%A0%BC%E4%BD%93/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%9E%84%E5%BB%BAhlod%E7%BD%91%E6%A0%BC%E4%BD%93/hero-image.png" alt="Featured image of post 构建HLOD网格体" />&lt;p>为了使用分层细节级别（Hierarchical Level of Detail）（HLOD）模型，你必须完成两个步骤才能在关卡中设置HLOD模型。首先，你必须生成群集。群集会根据你在群集生成设置（Cluster Generation Settings）中指定设置对关卡的Actor进行分支。&lt;/p></description></item><item><title>HLOD概述</title><link>https://zentia.github.io/p/hlod%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/hlod%E6%A6%82%E8%BF%B0/</guid><description>&lt;img src="https://zentia.github.io/p/hlod%E6%A6%82%E8%BF%B0/ue5-hero.png" alt="Featured image of post HLOD概述" />&lt;p>&lt;img src="https://zentia.github.io/p/hlod%E6%A6%82%E8%BF%B0/hlod_howto_header.png"
width="1200"
height="385"
srcset="https://zentia.github.io/p/hlod%E6%A6%82%E8%BF%B0/hlod_howto_header_hu_4a191df7dee53d2.png 480w, https://zentia.github.io/p/hlod%E6%A6%82%E8%BF%B0/hlod_howto_header_hu_f900d6a75c83d61d.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="311"
data-flex-basis="748px"
>
就其最简单的形式而言，分层细节级别（Hierarchical Level of Detail）（简称HLOD）将预先存在的静态网格体Actor组合为一个单一的HLOD代理模型和材质（带有图谱纹理）。因为HLOD可以将每个代理模型的多个绘制调用减少为一个调用，而不是每个静态网格体Actor一个绘制条用，因此使用它可以提升性能。生成HLOD代理模型时，可以调整几个参数，这些参数有助于定义如何将静态网格体Actor作为群集分组在一起，它们最终被编译到代理模型中。&lt;/p></description></item><item><title>技能系统组件与属性</title><link>https://zentia.github.io/p/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%B1%9E%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%B1%9E%E6%80%A7/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%B1%9E%E6%80%A7/hero-image.png" alt="Featured image of post 技能系统组件与属性" />&lt;p>技能系统组件（UAbilitySystemComponent）是Actor和游戏玩法技能组件（Gameplay Ability System）之间的桥梁。&lt;/p></description></item><item><title>水体Actor</title><link>https://zentia.github.io/p/%E6%B0%B4%E4%BD%93actor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/p/%E6%B0%B4%E4%BD%93actor/</guid><description>&lt;img src="https://zentia.github.io/p/%E6%B0%B4%E4%BD%93actor/hero-image.png" alt="Featured image of post 水体Actor" />&lt;p>你可以使用水体Actor在关卡中定义水的位置、形状，以及睡眠过渡效果。水体是由许多的水网格体块组成，并由水网格体Actor（Water Mesh Actor）管理。这个actor决定了所有水体（water body）的质量和属性。你只需将水网格体actor放置在需要渲染水体的区域。之后，虚幻引擎会自动生成所需的网格体。系统会将所有水体渲染成单一的水网格体图块，实现平滑无缝的过渡效果。&lt;/p>
&lt;h1 id="水体的种类">水体的种类
&lt;/h1>&lt;p>有几种水体Actor可供选择。&lt;/p>
&lt;ul>
&lt;li>海洋、湖泊和河流水体。它们的区别在于组成它们的样条线使用了保存不同类型的数据。&lt;/li>
&lt;li>自定义类型。它同样有一个用于查询数据的样条，但你需要用静态网格体来定义形状。&lt;/li>
&lt;li>岛屿类型。用于在已定义的样条区域内升高地形。&lt;/li>
&lt;/ul></description></item><item><title>Search</title><link>https://zentia.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zentia.github.io/search/</guid><description/></item></channel></rss>